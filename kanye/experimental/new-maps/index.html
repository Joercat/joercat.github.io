<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Olive Delights</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #fff; }
        
        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #0f0f23);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 300;
            text-align: center;
        }
        .menu-overlay.hidden { display: none; }
        
        #start-screen h1 { color: #ffd700; font-size: 48px; text-shadow: 0 0 30px #ff8c00; margin-bottom: 10px; }
        #start-screen h2 { color: #ccc; font-size: 20px; margin-bottom: 20px; }
        
        .menu-section { background: rgba(0,0,0,0.5); padding: 15px 25px; border-radius: 8px; margin: 10px auto; text-align: center; max-width: 400px; }
        .menu-section h3 { color: #ffd700; margin-bottom: 10px; }
        .menu-section p, .menu-section label { color: #ddd; font-size: 13px; line-height: 1.6; }
        
        .menu-btn {
            padding: 15px 40px; font-size: 18px; margin: 5px;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white; border: none; cursor: pointer;
            font-family: inherit; border-radius: 4px;
        }
        .menu-btn:hover { transform: scale(1.05); }
        .menu-btn.secondary { background: linear-gradient(135deg, #555, #444); }
        .menu-btn.small { padding: 8px 20px; font-size: 14px; }
        
        .coins-display { color: #ffd700; font-size: 18px; margin: 10px 0; }
        
        .highscores { color: #4ade80; font-size: 14px; }
        .highscores span { display: block; margin: 3px 0; }
        
        .settings-row { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; color: #ddd; gap: 15px; }
        .settings-row select, .settings-row input { background: #333; color: #fff; border: 1px solid #555; padding: 5px 10px; border-radius: 4px; }
        
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px; }
        .shop-item { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center; color: #fff; }
        .shop-item img { width: 48px; height: 48px; image-rendering: pixelated; }
        .shop-item.owned { border: 2px solid #4ade80; }
        .shop-item.selected { border: 2px solid #ffd700; box-shadow: 0 0 10px #ffd700; }
        .shop-item small { color: #ccc; }
        
        .upgrade-item { background: rgba(255,255,255,0.05); padding: 8px; margin: 5px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: #ddd; }
        .upgrade-item.owned { background: rgba(74,222,128,0.2); }
        .upgrade-item span { color: #fff; }
        
        .tab-buttons { display: flex; gap: 5px; margin-bottom: 15px; justify-content: center; }
        .tab-btn { padding: 8px 15px; background: #333; color: #ccc; border: none; cursor: pointer; border-radius: 4px; }
        .tab-btn.active { background: #ff8c00; color: #fff; }
        .tab-content { display: none; max-width: 450px; margin: 0 auto; }
        .tab-content.active { display: block; }
        
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 4px; height: 4px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 4px #fff; }
        
        #stamina-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 200px; height: 8px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; }
        #stamina-bar { height: 100%; width: 100%; background: linear-gradient(90deg, #4ade80, #22c55e); border-radius: 3px; transition: width 0.1s; }
        #stamina-bar.infinite { background: linear-gradient(90deg, #fbbf24, #f59e0b); animation: pulse 0.3s infinite alternate; }
        #stamina-bar.boosted { background: linear-gradient(90deg, #f472b6, #ec4899); }
        @keyframes pulse { from { opacity: 0.7; } to { opacity: 1; } }
        
        #hud-coins { position: absolute; top: 20px; left: 120px; color: #ffd700; font-size: 18px; }
        #timer { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 20px; }
        #floor-indicator { position: absolute; top: 50px; left: 20px; color: #88ccff; font-size: 16px; }
        #kanye-floor { position: absolute; top: 75px; left: 20px; color: #ff8888; font-size: 14px; opacity: 0; }
        #warning { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: #ff4444; font-size: 24px; opacity: 0; text-shadow: 0 0 20px #ff0000; }
        #shield-indicator { position: absolute; top: 140px; left: 50%; transform: translateX(-50%); color: #4ade80; font-size: 18px; opacity: 0; }
        #pickup-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, 50px); color: #4ade80; font-size: 20px; opacity: 0; text-shadow: 0 0 10px #000; transition: opacity 0.3s; }
        
        #powerups-display { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        .powerup-slot { width: 50px; height: 50px; background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; display: flex; align-items: center; justify-content: center; position: relative; }
        .powerup-slot.active { border-color: #4ade80; box-shadow: 0 0 10px #4ade80; }
        
        #minimap { position: absolute; top: 20px; right: 20px; width: 160px; height: 160px; background: rgba(0,0,0,0.9); border: 2px solid rgba(255,255,255,0.4); border-radius: 4px; }
        #minimap-canvas { width: 100%; height: 100%; }
        #minimap-floor { position: absolute; top: 185px; right: 20px; width: 160px; text-align: center; color: #88ccff; font-size: 12px; background: rgba(0,0,0,0.7); padding: 4px; border-radius: 4px; }
        
        .vignette { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 45; background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%); }
        #fear-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: rgba(100,0,0,0.4); opacity: 0; z-index: 50; }
        #freeze-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: rgba(100,200,255,0.2); opacity: 0; z-index: 48; }
        
        #death-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(80, 0, 0, 0.95); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 200; }
        #death-screen h1 { color: #fff; font-size: 64px; text-shadow: 0 0 30px #ff0000; margin-bottom: 20px; }
        #death-screen p { color: #fcc; font-size: 20px; margin-bottom: 10px; }
        #death-screen .coins-earned { color: #ffd700; font-size: 24px; margin: 15px 0; }
        
        #pause-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 250; }
        #pause-screen h1 { color: #fff; font-size: 48px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="start-screen" class="menu-overlay">
        <h1>ü´í OLIVE DELIGHTS ü´í</h1>
        <h2>Escape the Nextbot</h2>
        
        <div class="coins-display">üí∞ Coins: <span id="total-coins">0</span></div>
        
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="showTab('play')">PLAY</button>
            <button class="tab-btn" onclick="showTab('shop')">SHOP</button>
            <button class="tab-btn" onclick="showTab('upgrades')">UPGRADES</button>
            <button class="tab-btn" onclick="showTab('settings')">SETTINGS</button>
        </div>
        
        <!-- PLAY TAB -->
        <div id="tab-play" class="tab-content active">
            <div class="menu-section">
                <h3>üèÜ TOP 3 RUNS</h3>
                <div class="highscores" id="highscores">
                    <span>1. --:--</span>
                    <span>2. --:--</span>
                    <span>3. --:--</span>
                </div>
            </div>
            
            <div class="menu-section">
                <p><strong>CONTROLS:</strong><br>
                WASD - Move | <span id="sprint-key-display">SHIFT</span> - Sprint | SPACE - Jump<br>
                ESC - Pause Menu</p>
            </div>
            
            <div class="menu-section">
                <label><input type="checkbox" id="start-shield-toggle"> Start with Shield (5 coins)</label>
            </div>
            
            <button class="menu-btn" onclick="startGame()">START GAME</button>
        </div>
        
        <!-- SHOP TAB -->
        <div id="tab-shop" class="tab-content">
            <div class="menu-section">
                <h3>üé≠ KANYE SKINS</h3>
                <div class="shop-grid" id="skin-shop"></div>
            </div>
        </div>
        
        <!-- UPGRADES TAB -->
        <div id="tab-upgrades" class="tab-content">
            <div class="menu-section">
                <h3>‚ùÑÔ∏è ICE UPGRADES</h3>
                <div id="ice-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>‚ö° SPEED UPGRADES</h3>
                <div id="speed-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>üõ°Ô∏è SHIELD UPGRADES</h3>
                <div id="shield-upgrades"></div>
            </div>
        </div>
        
        <!-- SETTINGS TAB -->
        <div id="tab-settings" class="tab-content">
            <div class="menu-section">
                <h3>‚öôÔ∏è SETTINGS</h3>
                <div class="settings-row">
                    <label>Sprint Key:</label>
                    <select id="sprint-key-select" onchange="updateSprintKey()">
                        <option value="ShiftLeft">Left Shift</option>
                        <option value="ShiftRight">Right Shift</option>
                        <option value="ControlLeft">Left Ctrl</option>
                        <option value="KeyC">C</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label>Mouse Sensitivity:</label>
                    <input type="range" id="sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
                </div>
                <div class="settings-row">
                    <label>Music Volume:</label>
                    <input type="range" id="music-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
                </div>
                <div class="settings-row">
                    <label>Show Minimap:</label>
                    <input type="checkbox" id="minimap-toggle" checked onchange="updateMinimapToggle()">
                </div>
            </div>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="ui">
        <div id="crosshair"></div>
        <div id="stamina-container"><div id="stamina-bar"></div></div>
        <div id="powerups-display">
            <div class="powerup-slot" id="slot-ice"><span style="color:#666;font-size:24px;">‚ùÑÔ∏è</span></div>
            <div class="powerup-slot" id="slot-speed"><span style="color:#666;font-size:24px;">‚ö°</span></div>
            <div class="powerup-slot" id="slot-shield"><span style="color:#666;font-size:24px;">üõ°Ô∏è</span></div>
        </div>
        <div id="warning">‚ö†Ô∏è HE'S CLOSE ‚ö†Ô∏è</div>
        <div id="shield-indicator">üõ°Ô∏è SHIELD ACTIVE</div>
        <div id="timer">0:00</div>

        <div id="hud-coins">üí∞ 0</div>
        <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
        <div id="minimap-floor">Map: Backrooms</div>
        <div id="pickup-msg"></div>
    </div>
    
    <div class="vignette"></div>
    <div id="fear-overlay"></div>
    <div id="freeze-overlay"></div>

    <!-- PAUSE SCREEN -->
    <div id="pause-screen">
        <h1>‚è∏Ô∏è PAUSED</h1>
        <div class="menu-section">
            <div class="settings-row">
                <label>Music Volume:</label>
                <input type="range" id="pause-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
            </div>
            <div class="settings-row">
                <label>Sensitivity:</label>
                <input type="range" id="pause-sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
            </div>
        </div>
        <button class="menu-btn" onclick="resumeGame()">RESUME</button>
        <button class="menu-btn secondary" onclick="quitGame()">QUIT (Lose Coins)</button>
    </div>

    <!-- DEATH SCREEN -->
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Kanye caught you...</p>
        <p id="survival-time">Survived: 0:00</p>
        <p class="coins-earned" id="coins-earned">+0 coins</p>
        <button class="menu-btn" onclick="restartGame()">TRY AGAIN</button>
        <button class="menu-btn secondary" onclick="returnToMenu()">MAIN MENU</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============ SAVE DATA ============
        let saveData = {
            coins: 0,
            highscores: [],
            ownedSkins: ['default'],
            selectedSkin: 'default',
            upgrades: { ice: 0, speed: 0, shield: 0 },
            settings: { sprintKey: 'ShiftLeft', sensitivity: 5, musicVolume: 100, minimapEnabled: true }
        };

        function loadSaveData() {
            try {
                const saved = localStorage.getItem('oliveDelights');
                if (saved) saveData = { ...saveData, ...JSON.parse(saved) };
            } catch(e) {}
            updateUI();
        }

        function saveSaveData() {
            try { localStorage.setItem('oliveDelights', JSON.stringify(saveData)); } catch(e) {}
        }

        // ============ SHOP DATA ============
        const SKINS = [
            { id: 'default', name: 'Classic Kanye', url: 'https://joercat.github.io/kanye.png', cost: 0 },
            { id: 'kanye2', name: 'Alt Kanye', url: 'https://joercat.github.io/kanye2.png', cost: 100 }
        ];

        const UPGRADES = {
            ice: [
                { level: 1, cost: 10, desc: '+1 sec freeze' },
                { level: 2, cost: 15, desc: '+3 sec freeze' },
                { level: 3, cost: 25, desc: '+3 sec freeze + 3 sec half speed' }
            ],
            speed: [
                { level: 1, cost: 10, desc: '+3 sec duration' },
                { level: 2, cost: 15, desc: '+5 sec duration' },
                { level: 3, cost: 25, desc: '+5 sec + speed boost' }
            ],
            shield: [
                { level: 1, cost: 10, desc: '+1 sec freeze on block' },
                { level: 2, cost: 15, desc: '+2 sec freeze on block' },
                { level: 3, cost: 25, desc: '2 hits + 2 sec freeze' }
            ]
        };

        // ============ GAME STATE ============
        let gameStarted = false;
        let isPaused = false;
        let isDead = false;
        let startTime = 0;
        let sessionCoins = 0;
        let sprintKeyCode = 'ShiftLeft';
        let mouseSensitivity = 0.002;
        let musicVolumeMultiplier = 1;

        // ============ THREE.JS ============
        let scene, camera, renderer;
        let wallTexture, floorTexture;

        // ============ PLAYER ============
        const player = {
            x: 0, y: 1.6, z: 0,
            yaw: 0, pitch: 0,
            onGround: true, vy: 0,
            shieldHits: 0,
            infiniteStamina: false,
            infiniteStaminaTimer: 0,
            speedBoost: false,
            speedBoostTimer: 0
        };

        // ============ KANYE ============
        const kanye = {
            x: 0, z: 0, y: 1.25, vx: 0, vz: 0,
            sprite: null, pathTimer: 0,
            path: [], pathIndex: 0,
            frozen: false, frozenTimer: 0,
            halfSpeed: false, halfSpeedTimer: 0,
            turnSpeed: 3.5, maxSpeed: 7.5,
            currentSkinUrl: '',
            floor: 1,
            targetFloor: 1
        };

        // ============ ENTITIES ============
        const powerups = [];
        const coins = [];
        const POWERUP_TYPES = ['ice', 'speed', 'shield'];

        // ============ INPUT ============
        const keys = {};
        let isLocked = false;
        let stamina = 100;
        let isSprinting = false;

        // ============ AUDIO ============
        let audioCtx, audioBuffer, audioSource, gainNode;
        let audioReady = false;
        let audioPlaying = false;

        // ============ MAP CONFIG ============
        const CELL = 4;
        const GRID_SIZE = 25;
        const WALL_H = 3.5;
        const FLOOR_HEIGHT = WALL_H + 0.5;

        let maze = [];
        let walkableCells = [];
        let currentMap = 'backrooms'; // 'backrooms', 'warehouse', 'hospital'

        const textureLoader = new THREE.TextureLoader();

        // ============ UI FUNCTIONS ============
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tab-' + tabId).classList.add('active');
            event.target.classList.add('active');
        }

        function updateUI() {
            document.getElementById('total-coins').textContent = saveData.coins;
            document.getElementById('sprint-key-display').textContent = 
                saveData.settings.sprintKey.replace('ShiftLeft', 'SHIFT').replace('ShiftRight', 'R-SHIFT')
                .replace('ControlLeft', 'CTRL').replace('KeyC', 'C');
            
            // Highscores
            const hsDiv = document.getElementById('highscores');
            hsDiv.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const time = saveData.highscores[i];
                const span = document.createElement('span');
                if (time) {
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    span.textContent = `${i + 1}. ${mins}:${secs.toString().padStart(2, '0')}`;
                } else {
                    span.textContent = `${i + 1}. --:--`;
                }
                hsDiv.appendChild(span);
            }
            
            // Skins shop
            const skinShop = document.getElementById('skin-shop');
            skinShop.innerHTML = '';
            SKINS.forEach(skin => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (saveData.ownedSkins.includes(skin.id)) div.classList.add('owned');
                if (saveData.selectedSkin === skin.id) div.classList.add('selected');
                div.innerHTML = `<img src="${skin.url}"><br><small>${skin.name}</small><br>`;
                if (!saveData.ownedSkins.includes(skin.id)) {
                    div.innerHTML += `<button class="menu-btn small" onclick="buySkin('${skin.id}')">${skin.cost} üí∞</button>`;
                } else if (saveData.selectedSkin !== skin.id) {
                    div.innerHTML += `<button class="menu-btn small" onclick="selectSkin('${skin.id}')">SELECT</button>`;
                } else {
                    div.innerHTML += `<small style="color:#4ade80;">EQUIPPED</small>`;
                }
                skinShop.appendChild(div);
            });
            
            // Upgrades
            ['ice', 'speed', 'shield'].forEach(type => {
                const container = document.getElementById(type + '-upgrades');
                container.innerHTML = '';
                UPGRADES[type].forEach((upg, idx) => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    if (saveData.upgrades[type] >= upg.level) div.classList.add('owned');
                    div.innerHTML = `<span>Lv${upg.level}: ${upg.desc}</span>`;
                    if (saveData.upgrades[type] >= upg.level) {
                        div.innerHTML += `<span style="color:#4ade80;">‚úì</span>`;
                    } else if (saveData.upgrades[type] === upg.level - 1) {
                        div.innerHTML += `<button class="menu-btn small" onclick="buyUpgrade('${type}', ${upg.level})">${upg.cost} üí∞</button>`;
                    } else {
                        div.innerHTML += `<span style="color:#666;">üîí</span>`;
                    }
                    container.appendChild(div);
                });
            });
            
            // Settings
            document.getElementById('sprint-key-select').value = saveData.settings.sprintKey;
            document.getElementById('sensitivity').value = saveData.settings.sensitivity;
            document.getElementById('music-volume').value = saveData.settings.musicVolume;
            document.getElementById('minimap-toggle').checked = saveData.settings.minimapEnabled !== false;
            
            sprintKeyCode = saveData.settings.sprintKey;
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            
            // Apply minimap visibility
            const minimapVisible = saveData.settings.minimapEnabled !== false;
            document.getElementById('minimap').style.display = minimapVisible ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = minimapVisible ? 'block' : 'none';
        }

        function buySkin(skinId) {
            const skin = SKINS.find(s => s.id === skinId);
            if (skin && saveData.coins >= skin.cost && !saveData.ownedSkins.includes(skinId)) {
                saveData.coins -= skin.cost;
                saveData.ownedSkins.push(skinId);
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function selectSkin(skinId) {
            if (saveData.ownedSkins.includes(skinId)) {
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function buyUpgrade(type, level) {
            const upg = UPGRADES[type].find(u => u.level === level);
            if (upg && saveData.coins >= upg.cost && saveData.upgrades[type] === level - 1) {
                saveData.coins -= upg.cost;
                saveData.upgrades[type] = level;
                saveSaveData();
                updateUI();
            }
        }

        function updateSprintKey() {
            saveData.settings.sprintKey = document.getElementById('sprint-key-select').value;
            sprintKeyCode = saveData.settings.sprintKey;
            saveSaveData();
            updateUI();
        }

        function updateSensitivity() {
            const val = document.getElementById('sensitivity').value || document.getElementById('pause-sensitivity').value;
            saveData.settings.sensitivity = parseInt(val);
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            saveSaveData();
        }

        function updateMusicVolume() {
            const val = document.getElementById('music-volume').value || document.getElementById('pause-volume').value;
            saveData.settings.musicVolume = parseInt(val);
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            saveSaveData();
        }

        function updateMinimapToggle() {
            saveData.settings.minimapEnabled = document.getElementById('minimap-toggle').checked;
            saveSaveData();
            document.getElementById('minimap').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
        }

        // ============ TEXTURES ============
        function loadTextures(callback) {
            let loaded = 0;
            const checkDone = () => { loaded++; if (loaded === 2) callback(); };

            wallTexture = textureLoader.load('https://joercat.github.io/wall.png', checkDone, undefined, checkDone);
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;

            floorTexture = textureLoader.load('https://joercat.github.io/floor.jpg', checkDone, undefined, checkDone);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(GRID_SIZE * 2, GRID_SIZE * 2);
        }

        // ============ AUDIO ============
        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioCtx.createGain();
                gainNode.gain.value = 0;
                gainNode.connect(audioCtx.destination);
                
                const resp = await fetch('https://joercat.github.io/olive.wav');
                const buf = await resp.arrayBuffer();
                audioBuffer = await audioCtx.decodeAudioData(buf);
                audioReady = true;
            } catch(e) { console.log('Audio failed:', e); }
        }

        function setAudioVolume(vol) {
            if (!audioReady) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            // Don't play audio if paused
            if (isPaused) {
                if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                return;
            }
            
            if (!audioPlaying && vol > 0) {
                audioSource = audioCtx.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.loop = true;
                audioSource.connect(gainNode);
                audioSource.start();
                audioPlaying = true;
            }
            
            const finalVol = Math.min(1, vol * musicVolumeMultiplier);
            if (gainNode) gainNode.gain.setTargetAtTime(finalVol, audioCtx.currentTime, 0.1);
        }

        function stopAudio() {
            if (audioSource) { try { audioSource.stop(); } catch(e) {} audioSource = null; audioPlaying = false; }
            if (gainNode) gainNode.gain.value = 0;
        }
        
        function pauseAudio() {
            if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        }

        // ============ MAZE GENERATION ============
        function generateMaze() {
            maze = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                maze[x] = [];
                for (let z = 0; z < GRID_SIZE; z++) {
                    maze[x][z] = 1;
                }
            }

            const stack = [];
            maze[1][1] = 0;
            stack.push({x: 1, z: 1});

            while (stack.length > 0) {
                const cur = stack[stack.length - 1];
                const dirs = [{dx: 0, dz: -2}, {dx: 0, dz: 2}, {dx: -2, dz: 0}, {dx: 2, dz: 0}];
                
                for (let i = dirs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                }

                let found = false;
                for (const d of dirs) {
                    const nx = cur.x + d.dx;
                    const nz = cur.z + d.dz;
                    
                    if (nx > 0 && nx < GRID_SIZE - 1 && nz > 0 && nz < GRID_SIZE - 1 && maze[nx][nz] === 1) {
                        maze[cur.x + d.dx / 2][cur.z + d.dz / 2] = 0;
                        maze[nx][nz] = 0;
                        stack.push({x: nx, z: nz});
                        found = true;
                        break;
                    }
                }
                if (!found) stack.pop();
            }

            for (let x = 2; x < GRID_SIZE - 2; x++) {
                for (let z = 2; z < GRID_SIZE - 2; z++) {
                    if (maze[x][z] === 1 && Math.random() < 0.2) {
                        let floors = 0;
                        if (maze[x-1][z] === 0) floors++;
                        if (maze[x+1][z] === 0) floors++;
                        if (maze[x][z-1] === 0) floors++;
                        if (maze[x][z+1] === 0) floors++;
                        if (floors >= 2) maze[x][z] = 0;
                    }
                }
            }

            walkableCells = [];
            for (let x = 1; x < GRID_SIZE - 1; x++) {
                for (let z = 1; z < GRID_SIZE - 1; z++) {
                    if (maze[x][z] === 0) walkableCells.push({x, z});
                }
            }
        }

        // ============ COORDINATE HELPERS ============
        function gridToWorld(gx, gz) {
            return { x: (gx - GRID_SIZE / 2 + 0.5) * CELL, z: (gz - GRID_SIZE / 2 + 0.5) * CELL };
        }

        function worldToGrid(wx, wz) {
            return { x: Math.floor(wx / CELL + GRID_SIZE / 2), z: Math.floor(wz / CELL + GRID_SIZE / 2) };
        }

        function isWalkableWorld(wx, wz, radius = 0.35) {
            const checks = [
                {x: wx, z: wz},
                {x: wx - radius, z: wz - radius},
                {x: wx + radius, z: wz - radius},
                {x: wx - radius, z: wz + radius},
                {x: wx + radius, z: wz + radius}
            ];
            
            for (const c of checks) {
                const g = worldToGrid(c.x, c.z);
                if (g.x < 0 || g.x >= GRID_SIZE || g.z < 0 || g.z >= GRID_SIZE) return false;
                if (!maze[g.x] || maze[g.x][g.z] !== 0) return false;
            }
            return true;
        }

        function isWalkableGrid(gx, gz) {
            if (gx < 0 || gx >= GRID_SIZE || gz < 0 || gz >= GRID_SIZE) return false;
            return maze[gx] && maze[gx][gz] === 0;
        }

        // ============ BUILD WORLD ============
        function buildWorld() {
            // Get map-specific materials and colors
            let wallMat, floorMat, ceilMat, fogColor, ambientColor;
            
            if (currentMap === 'backrooms') {
                // Classic backrooms - yellow walls, carpet floor
                wallMat = new THREE.MeshBasicMaterial({ map: wallTexture });
                floorMat = new THREE.MeshBasicMaterial({ map: floorTexture });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                fogColor = 0x1a1a1a;
                ambientColor = 0xfff5e0;
            } else if (currentMap === 'warehouse') {
                // Industrial warehouse - gray concrete, metal shelves
                wallMat = new THREE.MeshBasicMaterial({ color: 0x4a4a4a });
                floorMat = new THREE.MeshBasicMaterial({ color: 0x3a3a3a });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                fogColor = 0x0a0a0a;
                ambientColor = 0xcccccc;
            } else if (currentMap === 'hospital') {
                // Abandoned hospital - white/green walls, tile floor
                wallMat = new THREE.MeshBasicMaterial({ color: 0xd4e6d4 });
                floorMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                fogColor = 0x1a2a1a;
                ambientColor = 0xe0ffe0;
            }
            
            // Update scene fog and background
            scene.background = new THREE.Color(fogColor);
            scene.fog = new THREE.Fog(fogColor, 2, 35);

            // Build walls
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x][z] === 1) {
                        const pos = gridToWorld(x, z);
                        const geo = new THREE.BoxGeometry(CELL, WALL_H, CELL);
                        const wall = new THREE.Mesh(geo, wallMat);
                        wall.position.set(pos.x, WALL_H / 2, pos.z);
                        scene.add(wall);
                    }
                }
            }

            // Ground
            const floorGeo = new THREE.PlaneGeometry(GRID_SIZE * CELL, GRID_SIZE * CELL);
            const floor1 = new THREE.Mesh(floorGeo, floorMat);
            floor1.rotation.x = -Math.PI / 2;
            floor1.position.y = 0.01;
            scene.add(floor1);

            // Ceiling
            const ceiling1 = new THREE.Mesh(floorGeo.clone(), ceilMat);
            ceiling1.rotation.x = Math.PI / 2;
            ceiling1.position.y = WALL_H;
            scene.add(ceiling1);
            
            // Add map-specific decorations
            if (currentMap === 'warehouse') {
                addWarehouseDecorations();
            } else if (currentMap === 'hospital') {
                addHospitalDecorations();
            }
            
            // Add lighting
            scene.add(new THREE.AmbientLight(ambientColor, 0.9));
        }
        
        // Warehouse decorations - crates, barrels, shelving units
        function addWarehouseDecorations() {
            const crateMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const barrelMat = new THREE.MeshBasicMaterial({ color: 0x2255aa });
            const shelfMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            
            // Add random crates and barrels in walkable areas
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(30, shuffled.length);
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                // Random offset within cell
                const offsetX = (Math.random() - 0.5) * CELL * 0.3;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.3;
                
                if (Math.random() < 0.6) {
                    // Crate stack (1-3 crates)
                    const stackHeight = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < stackHeight; j++) {
                        const crate = new THREE.Mesh(
                            new THREE.BoxGeometry(0.8, 0.8, 0.8),
                            crateMat
                        );
                        crate.position.set(pos.x + offsetX, 0.4 + j * 0.8, pos.z + offsetZ);
                        scene.add(crate);
                    }
                } else {
                    // Barrel
                    const barrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 1.2, 12),
                        barrelMat
                    );
                    barrel.position.set(pos.x + offsetX, 0.6, pos.z + offsetZ);
                    scene.add(barrel);
                }
            }
            
            // Add some tall shelving units along walls
            for (let i = decorCount; i < decorCount + 15 && i < shuffled.length; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                // Check if adjacent to wall
                const nearWall = !isWalkableGrid(cell.x - 1, cell.z) || 
                                 !isWalkableGrid(cell.x + 1, cell.z) ||
                                 !isWalkableGrid(cell.x, cell.z - 1) ||
                                 !isWalkableGrid(cell.x, cell.z + 1);
                
                if (nearWall) {
                    const shelf = new THREE.Mesh(
                        new THREE.BoxGeometry(CELL * 0.8, WALL_H * 0.7, 0.5),
                        shelfMat
                    );
                    shelf.position.set(pos.x, WALL_H * 0.35, pos.z);
                    scene.add(shelf);
                }
            }
        }
        
        // Hospital decorations - gurneys, medical equipment, debris
        function addHospitalDecorations() {
            const gurneyMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const sheetMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const equipMat = new THREE.MeshBasicMaterial({ color: 0x446688 });
            const bloodMat = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
            
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(25, shuffled.length);
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const offsetX = (Math.random() - 0.5) * CELL * 0.3;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.3;
                
                const type = Math.random();
                
                if (type < 0.3) {
                    // Gurney with sheet
                    const gurneyGroup = new THREE.Group();
                    
                    // Frame
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.1, 2),
                        gurneyMat
                    );
                    frame.position.y = 0.7;
                    gurneyGroup.add(frame);
                    
                    // Legs
                    for (let lx = -0.3; lx <= 0.3; lx += 0.6) {
                        for (let lz = -0.8; lz <= 0.8; lz += 1.6) {
                            const leg = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.7, 0.08),
                                gurneyMat
                            );
                            leg.position.set(lx, 0.35, lz);
                            gurneyGroup.add(leg);
                        }
                    }
                    
                    // Sheet/mattress
                    const sheet = new THREE.Mesh(
                        new THREE.BoxGeometry(0.7, 0.15, 1.8),
                        sheetMat
                    );
                    sheet.position.y = 0.82;
                    gurneyGroup.add(sheet);
                    
                    gurneyGroup.position.set(pos.x + offsetX, 0, pos.z + offsetZ);
                    gurneyGroup.rotation.y = Math.random() * Math.PI;
                    scene.add(gurneyGroup);
                    
                } else if (type < 0.5) {
                    // Medical equipment (IV stand, monitor)
                    const stand = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.15, 1.8, 8),
                        gurneyMat
                    );
                    stand.position.set(pos.x + offsetX, 0.9, pos.z + offsetZ);
                    scene.add(stand);
                    
                    const monitor = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.25, 0.1),
                        equipMat
                    );
                    monitor.position.set(pos.x + offsetX, 1.7, pos.z + offsetZ);
                    scene.add(monitor);
                    
                } else if (type < 0.7) {
                    // Wheelchair
                    const wheelchairMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.1, 0.5),
                        wheelchairMat
                    );
                    seat.position.set(pos.x + offsetX, 0.5, pos.z + offsetZ);
                    scene.add(seat);
                    
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.6, 0.1),
                        wheelchairMat
                    );
                    back.position.set(pos.x + offsetX, 0.8, pos.z + offsetZ - 0.2);
                    scene.add(back);
                    
                } else {
                    // Blood stain on floor (flat plane)
                    const stain = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5),
                        bloodMat
                    );
                    stain.rotation.x = -Math.PI / 2;
                    stain.position.set(pos.x + offsetX, 0.02, pos.z + offsetZ);
                    scene.add(stain);
                }
            }
        }

        // ============ A* PATHFINDING ============
        function findPath(startGx, startGz, endGx, endGz) {
            if (!isWalkableGrid(startGx, startGz) || !isWalkableGrid(endGx, endGz)) return [];

            const key = (x, z) => x * 1000 + z;
            const open = [{x: startGx, z: startGz, g: 0, f: 0}];
            const closed = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            gScore.set(key(startGx, startGz), 0);

            const h = (x, z) => Math.abs(x - endGx) + Math.abs(z - endGz);

            let iterations = 0;
            while (open.length > 0 && iterations < 2000) {
                iterations++;
                
                let bestIdx = 0;
                for (let i = 1; i < open.length; i++) {
                    if (open[i].f < open[bestIdx].f) bestIdx = i;
                }
                const cur = open.splice(bestIdx, 1)[0];
                const curKey = key(cur.x, cur.z);

                if (cur.x === endGx && cur.z === endGz) {
                    const path = [];
                    let k = curKey;
                    while (cameFrom.has(k)) {
                        path.unshift({x: Math.floor(k / 1000), z: k % 1000});
                        k = cameFrom.get(k);
                    }
                    return path;
                }

                closed.add(curKey);

                const neighbors = [
                    {x: cur.x + 1, z: cur.z},
                    {x: cur.x - 1, z: cur.z},
                    {x: cur.x, z: cur.z + 1},
                    {x: cur.x, z: cur.z - 1}
                ];

                for (const n of neighbors) {
                    if (!isWalkableGrid(n.x, n.z)) continue;
                    const nKey = key(n.x, n.z);
                    if (closed.has(nKey)) continue;

                    const tentG = (gScore.get(curKey) || 0) + 1;
                    
                    if (tentG < (gScore.get(nKey) || Infinity)) {
                        cameFrom.set(nKey, curKey);
                        gScore.set(nKey, tentG);
                        const f = tentG + h(n.x, n.z);
                        
                        const existing = open.find(o => o.x === n.x && o.z === n.z);
                        if (!existing) open.push({x: n.x, z: n.z, g: tentG, f: f});
                        else existing.f = f;
                    }
                }
            }
            return [];
        }

        // ============ CREATE KANYE ============
        function createKanye() {
            const skinUrl = SKINS.find(s => s.id === saveData.selectedSkin)?.url || SKINS[0].url;
            kanye.currentSkinUrl = skinUrl;
            
            textureLoader.load(skinUrl, (tex) => {
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                const mat = new THREE.SpriteMaterial({ map: tex });
                kanye.sprite = new THREE.Sprite(mat);
                kanye.sprite.scale.set(2.5, 2.5, 1);
                scene.add(kanye.sprite);
                kanye.sprite.position.set(kanye.x, 1.25, kanye.z);
            });
        }

        // ============ CREATE POWERUPS ============
        function createPowerups() {
            powerups.forEach(p => { if (p.sprite) scene.remove(p.sprite); });
            powerups.length = 0;

            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const urls = {
                ice: 'https://joercat.github.io/ice.png',
                speed: 'https://joercat.github.io/speed.png',
                shield: 'https://joercat.github.io/shield.png'
            };

            for (let i = 0; i < 12 && i < shuffled.length; i++) {
                const type = POWERUP_TYPES[i % 3];
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);

                textureLoader.load(urls[type], (tex) => {
                    tex.magFilter = THREE.NearestFilter;
                    const mat = new THREE.SpriteMaterial({ map: tex });
                    const sprite = new THREE.Sprite(mat);
                    sprite.scale.set(1.2, 1.2, 1);
                    sprite.position.set(pos.x, 0.8, pos.z);
                    scene.add(sprite);
                    
                    powerups.push({ type, x: pos.x, z: pos.z, sprite, collected: false });
                });
            }
        }

        // ============ CREATE COINS ============
        function createCoins() {
            coins.forEach(c => { if (c.sprite) scene.remove(c.sprite); });
            coins.length = 0;
            spawnCoins();
        }

        function spawnCoins() {
            const available = walkableCells.filter(cell => {
                const pos = gridToWorld(cell.x, cell.z);
                return !coins.some(c => !c.collected && Math.hypot(c.x - pos.x, c.z - pos.z) < 2);
            });
            
            const shuffled = available.sort(() => Math.random() - 0.5);
            const toSpawn = 5 - coins.filter(c => !c.collected).length;
            
            for (let i = 0; i < toSpawn && i < shuffled.length; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                textureLoader.load('https://joercat.github.io/coin.png', (tex) => {
                    tex.magFilter = THREE.NearestFilter;
                    const mat = new THREE.SpriteMaterial({ map: tex });
                    const sprite = new THREE.Sprite(mat);
                    sprite.scale.set(0.8, 0.8, 1);
                    sprite.position.set(pos.x, 0.6, pos.z);
                    scene.add(sprite);
                    
                    coins.push({ x: pos.x, z: pos.z, sprite, collected: false });
                });
            }
        }

        // ============ SPAWN ENTITIES ============
        function spawnEntities() {
            if (walkableCells.length < 10) return;

            const pIdx = Math.floor(Math.random() * walkableCells.length);
            const pCell = walkableCells[pIdx];
            const pPos = gridToWorld(pCell.x, pCell.z);
            player.x = pPos.x;
            player.z = pPos.z;
            player.y = 1.6;
            player.yaw = 0;
            player.pitch = 0;
            player.vy = 0;
            player.onGround = true;
            player.shieldHits = 0;
            player.infiniteStamina = false;
            player.speedBoost = false;
            player.floor = 1;

            // Start with shield if purchased
            if (document.getElementById('start-shield-toggle').checked && saveData.coins >= 5) {
                saveData.coins -= 5;
                player.shieldHits = saveData.upgrades.shield >= 3 ? 2 : 1;
                document.getElementById('shield-indicator').style.opacity = '1';
                document.getElementById('slot-shield').classList.add('active');
                saveSaveData();
                updateUI();
            }

            let maxDist = 0;
            let kCell = walkableCells[0];
            for (const c of walkableCells) {
                const pos = gridToWorld(c.x, c.z);
                const d = Math.hypot(pos.x - player.x, pos.z - player.z);
                if (d > maxDist) { maxDist = d; kCell = c; }
            }
            const kPos = gridToWorld(kCell.x, kCell.z);
            kanye.x = kPos.x;
            kanye.z = kPos.z;
            kanye.vx = 0;
            kanye.vz = 0;
            kanye.pathTimer = 0;
            kanye.path = [];
            kanye.frozen = false;
            kanye.halfSpeed = false;
            kanye.floor = 1;

            if (kanye.sprite) kanye.sprite.position.set(kanye.x, 1.25, kanye.z);
            camera.position.set(player.x, player.y, player.z);

            createPowerups();
            createCoins();
        }

        // ============ UPDATE PLAYER ============
        function updatePlayer(dt) {
            if (!isLocked || isPaused) return;

            const walkSpeed = 6.0;
            let sprintSpeed = 8.5;
            
            // Speed boost upgrade
            if (player.speedBoost) {
                player.speedBoostTimer -= dt;
                sprintSpeed = 9.5;
                if (player.speedBoostTimer <= 0) player.speedBoost = false;
            }
            
            const jumpPower = 6.0;
            const gravity = 18;

            if (player.infiniteStamina) {
                player.infiniteStaminaTimer -= dt;
                if (player.infiniteStaminaTimer <= 0) {
                    player.infiniteStamina = false;
                    document.getElementById('stamina-bar').classList.remove('infinite');
                    document.getElementById('stamina-bar').classList.remove('boosted');
                }
            }

            const wantSprint = isSprinting && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']);
            if (wantSprint && !player.infiniteStamina) {
                if (stamina > 0) stamina = Math.max(0, stamina - dt * 20);
            } else if (!wantSprint) {
                stamina = Math.min(100, stamina + dt * 15);
            }
            
            const canSprint = wantSprint && (stamina > 0 || player.infiniteStamina);
            const moveSpeed = canSprint ? sprintSpeed : walkSpeed;
            
            document.getElementById('stamina-bar').style.width = (player.infiniteStamina ? 100 : stamina) + '%';

            const forwardX = -Math.sin(player.yaw);
            const forwardZ = -Math.cos(player.yaw);
            const rightX = Math.cos(player.yaw);
            const rightZ = -Math.sin(player.yaw);

            let moveX = 0, moveZ = 0;
            if (keys['KeyW']) { moveX += forwardX; moveZ += forwardZ; }
            if (keys['KeyS']) { moveX -= forwardX; moveZ -= forwardZ; }
            if (keys['KeyD']) { moveX += rightX; moveZ += rightZ; }
            if (keys['KeyA']) { moveX -= rightX; moveZ -= rightZ; }

            const len = Math.hypot(moveX, moveZ);
            if (len > 0) {
                moveX = (moveX / len) * moveSpeed;
                moveZ = (moveZ / len) * moveSpeed;
            }

            if (keys['Space'] && player.onGround) {
                player.vy = jumpPower;
                player.onGround = false;
            }

            player.vy -= gravity * dt;

            let newX = player.x + moveX * dt;
            let newZ = player.z + moveZ * dt;
            let newY = player.y + player.vy * dt;

            if (!isWalkableWorld(newX, player.z, 0.35)) newX = player.x;
            if (!isWalkableWorld(newX, newZ, 0.35)) newZ = player.z;

            player.x = newX;
            player.z = newZ;

            // Ground and ceiling collision
            if (newY < 1.6) { newY = 1.6; player.vy = 0; player.onGround = true; }
            if (newY > WALL_H - 0.3) { newY = WALL_H - 0.3; player.vy = 0; }
            player.y = newY;

            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;
            
            checkPowerupCollection();
            checkCoinCollection();
        }

        // ============ POWERUP COLLECTION ============
        function checkPowerupCollection() {
            for (const p of powerups) {
                if (p.collected) continue;
                const dist = Math.hypot(p.x - player.x, p.z - player.z);
                if (dist < 1.5) {
                    p.collected = true;
                    if (p.sprite) scene.remove(p.sprite);
                    activatePowerup(p.type);
                }
            }
        }

        function activatePowerup(type) {
            const msg = document.getElementById('pickup-msg');
            const upg = saveData.upgrades;
            
            if (type === 'ice') {
                let freezeTime = 3;
                if (upg.ice >= 1) freezeTime += 1;
                if (upg.ice >= 2) freezeTime += 2;
                if (upg.ice >= 3) { freezeTime += 0; kanye.halfSpeed = true; kanye.halfSpeedTimer = 3; }
                
                kanye.frozen = true;
                kanye.frozenTimer = freezeTime;
                document.getElementById('freeze-overlay').style.opacity = '1';
                msg.textContent = `‚ùÑÔ∏è KANYE FROZEN FOR ${freezeTime} SECONDS!`;
                document.getElementById('slot-ice').classList.add('active');
                setTimeout(() => document.getElementById('slot-ice').classList.remove('active'), freezeTime * 1000);
                
            } else if (type === 'speed') {
                let duration = 10;
                if (upg.speed >= 1) duration += 3;
                if (upg.speed >= 2) duration += 2;
                if (upg.speed >= 3) { player.speedBoost = true; player.speedBoostTimer = 5; }
                
                player.infiniteStamina = true;
                player.infiniteStaminaTimer = duration;
                document.getElementById('stamina-bar').classList.add('infinite');
                if (upg.speed >= 3) document.getElementById('stamina-bar').classList.add('boosted');
                msg.textContent = `‚ö° INFINITE STAMINA FOR ${duration} SECONDS!`;
                document.getElementById('slot-speed').classList.add('active');
                setTimeout(() => document.getElementById('slot-speed').classList.remove('active'), duration * 1000);
                
            } else if (type === 'shield') {
                if (player.shieldHits > 0) {
                    msg.textContent = 'üõ°Ô∏è SHIELD ALREADY ACTIVE!';
                } else {
                    player.shieldHits = upg.shield >= 3 ? 2 : 1;
                    document.getElementById('shield-indicator').style.opacity = '1';
                    msg.textContent = upg.shield >= 3 ? 'üõ°Ô∏è DOUBLE SHIELD ACQUIRED!' : 'üõ°Ô∏è SHIELD ACQUIRED!';
                    document.getElementById('slot-shield').classList.add('active');
                }
            }
            
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 2000);
        }

        // ============ COIN COLLECTION ============
        function checkCoinCollection() {
            let needRespawn = false;
            for (const c of coins) {
                if (c.collected) continue;
                const dist = Math.hypot(c.x - player.x, c.z - player.z);
                if (dist < 1.5) {
                    c.collected = true;
                    if (c.sprite) scene.remove(c.sprite);
                    sessionCoins++;
                    document.getElementById('hud-coins').textContent = 'üí∞ ' + sessionCoins;
                    needRespawn = true;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = 'üí∞ +1 COIN';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 1000);
                }
            }
            if (needRespawn) setTimeout(spawnCoins, 2000);
        }

        // ============ UPDATE KANYE ============
        function updateKanye(dt) {
            if (!kanye.sprite || isPaused) return;

            if (kanye.frozen) {
                kanye.frozenTimer -= dt;
                if (kanye.frozenTimer <= 0) {
                    kanye.frozen = false;
                    document.getElementById('freeze-overlay').style.opacity = '0';
                }
                kanye.sprite.material.color.setHex(kanye.frozen ? 0x88ccff : 0xffffff);
                return;
            }
            
            if (kanye.halfSpeed) {
                kanye.halfSpeedTimer -= dt;
                if (kanye.halfSpeedTimer <= 0) kanye.halfSpeed = false;
            }

            const kanyeMaxSpeed = kanye.halfSpeed ? 4.5 : 7.5;
            const kanyeTurnSpeed = 3.5;
            
            kanye.pathTimer -= dt;
            if (kanye.pathTimer <= 0) {
                kanye.pathTimer = 0.35;
                
                const kGrid = worldToGrid(kanye.x, kanye.z);
                const pGrid = worldToGrid(player.x, player.z);
                
                // Chase player with prediction
                const predX = player.x + (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ? 
                    -Math.sin(player.yaw) * 3 : 0);
                const predZ = player.z + (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ? 
                    -Math.cos(player.yaw) * 3 : 0);
                const predGrid = worldToGrid(predX, predZ);
                
                let path = findPath(kGrid.x, kGrid.z, predGrid.x, predGrid.z);
                if (path.length === 0) path = findPath(kGrid.x, kGrid.z, pGrid.x, pGrid.z);
                
                kanye.path = path;
                kanye.pathIndex = 0;
            }

            let targetX = player.x;
            let targetZ = player.z;

            if (kanye.path.length > 0) {
                while (kanye.pathIndex < kanye.path.length) {
                    const node = kanye.path[kanye.pathIndex];
                    const nodePos = gridToWorld(node.x, node.z);
                    const distToNode = Math.hypot(nodePos.x - kanye.x, nodePos.z - kanye.z);
                    if (distToNode < 1.5 && kanye.pathIndex < kanye.path.length - 1) {
                        kanye.pathIndex++;
                    } else {
                        targetX = nodePos.x;
                        targetZ = nodePos.z;
                        break;
                    }
                }
            }

            const dx = targetX - kanye.x;
            const dz = targetZ - kanye.z;
            const dist = Math.hypot(dx, dz);

            if (dist > 0.1) {
                const desiredVx = (dx / dist) * kanyeMaxSpeed;
                const desiredVz = (dz / dist) * kanyeMaxSpeed;

                kanye.vx += (desiredVx - kanye.vx) * kanyeTurnSpeed * dt;
                kanye.vz += (desiredVz - kanye.vz) * kanyeTurnSpeed * dt;

                const speed = Math.hypot(kanye.vx, kanye.vz);
                if (speed > kanyeMaxSpeed) {
                    kanye.vx = (kanye.vx / speed) * kanyeMaxSpeed;
                    kanye.vz = (kanye.vz / speed) * kanyeMaxSpeed;
                }
            }

            let newX = kanye.x + kanye.vx * dt;
            let newZ = kanye.z + kanye.vz * dt;

            if (!isWalkableWorld(newX, kanye.z, 0.4)) { newX = kanye.x; kanye.vx *= -0.3; }
            if (!isWalkableWorld(kanye.x, newZ, 0.4)) { newZ = kanye.z; kanye.vz *= -0.3; }
            
            kanye.x = newX;
            kanye.z = newZ;
            
            // Position Kanye sprite at correct height
            kanye.sprite.position.set(kanye.x, 1.25, kanye.z);

            const distToPlayer = Math.hypot(kanye.x - player.x, kanye.z - player.z);

            const audioRange = 70;
            let vol = distToPlayer < audioRange ? Math.pow(1 - (distToPlayer / audioRange), 0.5) : 0;
            setAudioVolume(vol);

            const fear = document.getElementById('fear-overlay');
            const warn = document.getElementById('warning');
            if (distToPlayer < 20) {
                fear.style.opacity = (1 - distToPlayer / 20) * 0.6;
                warn.style.opacity = distToPlayer < 10 ? 1 : 0;
            } else {
                fear.style.opacity = 0;
                warn.style.opacity = 0;
            }

            if (distToPlayer < 1.2) {
                if (player.shieldHits > 0) {
                    player.shieldHits--;
                    
                    let freezeOnBlock = 0;
                    if (saveData.upgrades.shield >= 1) freezeOnBlock = 1;
                    if (saveData.upgrades.shield >= 2) freezeOnBlock = 2;
                    if (saveData.upgrades.shield >= 3) freezeOnBlock = 2;
                    
                    if (freezeOnBlock > 0) {
                        kanye.frozen = true;
                        kanye.frozenTimer = freezeOnBlock;
                    }
                    
                    if (player.shieldHits <= 0) {
                        document.getElementById('shield-indicator').style.opacity = '0';
                        document.getElementById('slot-shield').classList.remove('active');
                    }
                    
                    const bounceDir = Math.atan2(kanye.z - player.z, kanye.x - player.x);
                    kanye.x += Math.cos(bounceDir) * 8;
                    kanye.z += Math.sin(bounceDir) * 8;
                    kanye.vx = Math.cos(bounceDir) * 10;
                    kanye.vz = Math.sin(bounceDir) * 10;
                    
                    if (!isWalkableWorld(kanye.x, kanye.z, 0.4)) {
                        const kGrid = worldToGrid(kanye.x, kanye.z);
                        for (let r = 1; r < 10; r++) {
                            let found = false;
                            for (let ddx = -r; ddx <= r && !found; ddx++) {
                                for (let ddz = -r; ddz <= r && !found; ddz++) {
                                    if (isWalkableGrid(kGrid.x + ddx, kGrid.z + ddz)) {
                                        const pos = gridToWorld(kGrid.x + ddx, kGrid.z + ddz);
                                        kanye.x = pos.x;
                                        kanye.z = pos.z;
                                        found = true;
                                    }
                                }
                            }
                            if (found) break;
                        }
                    }
                    
                    kanye.pathTimer = 0;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = player.shieldHits > 0 ? 'üõ°Ô∏è SHIELD BLOCKED! 1 HIT LEFT!' : 'üõ°Ô∏è SHIELD BLOCKED KANYE!';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 2000);
                } else {
                    killPlayer();
                }
            }
        }

        // ============ MINIMAP ============
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const scale = w / GRID_SIZE;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);

            ctx.fillStyle = '#444';
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x] && maze[x][z] === 1) {
                        ctx.fillRect(x * scale, z * scale, scale, scale);
                    }
                }
            }
            
            // Powerups
            for (const p of powerups) {
                if (p.collected) continue;
                const px = (p.x / CELL + GRID_SIZE / 2) * scale;
                const pz = (p.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = p.type === 'ice' ? '#88ccff' : p.type === 'speed' ? '#ffcc00' : '#44ff44';
                ctx.beginPath();
                ctx.arc(px, pz, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Coins
            for (const c of coins) {
                if (c.collected) continue;
                const cx = (c.x / CELL + GRID_SIZE / 2) * scale;
                const cz = (c.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(cx, cz, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            const playerMapX = (player.x / CELL + GRID_SIZE / 2) * scale;
            const playerMapZ = (player.z / CELL + GRID_SIZE / 2) * scale;
            
            ctx.fillStyle = '#4f4';
            ctx.beginPath();
            ctx.arc(playerMapX, playerMapZ, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#4f4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerMapX, playerMapZ);
            const dirLen = 14;
            const dirX = playerMapX - Math.sin(player.yaw) * dirLen;
            const dirZ = playerMapZ - Math.cos(player.yaw) * dirLen;
            ctx.lineTo(dirX, dirZ);
            ctx.stroke();

            const kanyeMapX = (kanye.x / CELL + GRID_SIZE / 2) * scale;
            const kanyeMapZ = (kanye.z / CELL + GRID_SIZE / 2) * scale;
            ctx.fillStyle = kanye.frozen ? '#88ccff' : '#f44';
            ctx.beginPath();
            ctx.arc(kanyeMapX, kanyeMapZ, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Update map label
            const mapNames = { backrooms: 'üè¢ Backrooms', warehouse: 'üè≠ Warehouse', hospital: 'üè• Hospital' };
            document.getElementById('minimap-floor').textContent = mapNames[currentMap] || 'Unknown';
        }

        // ============ TIMER ============
        function updateTimer() {
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ============ DEATH ============
        function killPlayer() {
            if (isDead) return;
            isDead = true;
            
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            
            // Add highscore
            saveData.highscores.push(elapsed);
            saveData.highscores.sort((a, b) => b - a);
            saveData.highscores = saveData.highscores.slice(0, 3);
            
            // Add coins
            saveData.coins += sessionCoins;
            saveSaveData();
            
            document.getElementById('survival-time').textContent = `Survived: ${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('coins-earned').textContent = `+${sessionCoins} coins`;
            document.getElementById('death-screen').style.display = 'flex';
            
            stopAudio();
            document.exitPointerLock();
        }

        // ============ PAUSE ============
        function togglePause() {
            if (!gameStarted || isDead) return;
            
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            
            if (isPaused) {
                pauseAudio();
                document.exitPointerLock();
            } else {
                renderer.domElement.requestPointerLock();
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pause-screen').style.display = 'none';
            renderer.domElement.requestPointerLock();
        }

        function quitGame() {
            // Don't add coins when quitting
            sessionCoins = 0;
            returnToMenu();
        }

        function returnToMenu() {
            gameStarted = false;
            isPaused = false;
            isDead = false;
            
            stopAudio();
            document.exitPointerLock();
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('start-screen').classList.remove('hidden');
            
            updateUI();
        }

        // ============ INIT ============
        function init() {
            loadSaveData();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 2, 30);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'low-power' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);
            document.body.appendChild(renderer.domElement);

            const mmCanvas = document.getElementById('minimap-canvas');
            mmCanvas.width = 160;
            mmCanvas.height = 160;

            loadTextures(() => {
                generateMaze();
                buildWorld();
                createKanye();
            });

            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === sprintKeyCode) isSprinting = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape' && gameStarted && !isDead) {
                    e.preventDefault();
                    togglePause();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === sprintKeyCode) isSprinting = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isLocked || !gameStarted || isDead || isPaused) return;
                player.yaw -= e.movementX * mouseSensitivity;
                player.pitch -= e.movementY * mouseSensitivity;
                player.pitch = Math.max(-1.4, Math.min(1.4, player.pitch));
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === renderer.domElement;
            });

            renderer.domElement.addEventListener('click', () => {
                if (gameStarted && !isDead && !isPaused) renderer.domElement.requestPointerLock();
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ============ GAME LOOP ============
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            if (gameStarted && !isDead && !isPaused) {
                updatePlayer(dt);
                updateKanye(dt);
                updateMinimap();
                updateTimer();
            }

            renderer.render(scene, camera);
        }

        // ============ START / RESTART ============
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            gameStarted = true;
            startTime = Date.now();
            stamina = 100;
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            
            // Randomly select a map
            const maps = ['backrooms', 'warehouse', 'hospital'];
            currentMap = maps[Math.floor(Math.random() * maps.length)];
            
            // Rebuild the world with the new map
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            generateMaze();
            buildWorld();
            createKanye();
            
            spawnEntities();
            initAudio();
            renderer.domElement.requestPointerLock();
        }

        function restartGame() {
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            
            // Randomly select a new map
            const maps = ['backrooms', 'warehouse', 'hospital'];
            currentMap = maps[Math.floor(Math.random() * maps.length)];
            
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            
            isDead = false;
            stamina = 100;
            startTime = Date.now();
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            kanye.pathTimer = 0;
            kanye.frozen = false;
            kanye.halfSpeed = false;
            kanye.vx = 0;
            kanye.vz = 0;
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('fear-overlay').style.opacity = 0;
            document.getElementById('warning').style.opacity = 0;
            document.getElementById('freeze-overlay').style.opacity = 0;
            document.getElementById('shield-indicator').style.opacity = 0;
            document.getElementById('stamina-bar').classList.remove('infinite');
            document.getElementById('stamina-bar').classList.remove('boosted');
            document.querySelectorAll('.powerup-slot').forEach(s => s.classList.remove('active'));
            
            renderer.domElement.requestPointerLock();
        }

        init();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
