<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sakura Chronicles: The Ethereal Realms</title>
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
        }

        #application-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* ========== LOADING SCREEN ========== */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0d0015 0%, #1a0030 50%, #0d0015 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-logo {
            font-size: 64px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .loading-title {
            font-size: 48px;
            background: linear-gradient(90deg, #ff69b4, #00ffff, #ff69b4);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .loading-subtitle {
            font-size: 20px;
            color: #888;
            margin-bottom: 50px;
        }

        .loading-bar-outer {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #ff69b4, #00ffff);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px #ff69b4;
        }

        .loading-status {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        }

        .loading-tips {
            position: absolute;
            bottom: 80px;
            max-width: 500px;
            text-align: center;
            color: #555;
            font-style: italic;
            padding: 0 20px;
        }

        /* ========== CHARACTER CREATION ========== */
        #characterCreation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, rgba(13,0,21,0.95), rgba(26,0,48,0.95));
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 8000;
        }

        .creation-container {
            background: linear-gradient(145deg, rgba(30,10,50,0.9), rgba(50,20,70,0.9));
            border: 2px solid rgba(255,105,180,0.5);
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(255,105,180,0.3);
        }

        .creation-title {
            text-align: center;
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #ff69b4, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .creation-section {
            margin-bottom: 30px;
        }

        .creation-section h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .creation-section input[type="text"] {
            width: 100%;
            padding: 15px 20px;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,105,180,0.5);
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            outline: none;
            transition: all 0.3s ease;
        }

        .creation-section input[type="text"]:focus {
            border-color: #ff69b4;
            box-shadow: 0 0 20px rgba(255,105,180,0.4);
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .class-card {
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .class-card:hover {
            border-color: #ff69b4;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255,105,180,0.3);
        }

        .class-card.selected {
            border-color: #00ffff;
            background: rgba(0,255,255,0.1);
            box-shadow: 0 0 30px rgba(0,255,255,0.4);
        }

        .class-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .class-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #fff;
        }

        .class-desc {
            font-size: 11px;
            color: #888;
            line-height: 1.4;
        }

        .class-stats {
            margin-top: 10px;
            font-size: 10px;
            color: #666;
        }

        .start-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            border: none;
            border-radius: 30px;
            color: #fff;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .start-button:hover {
            transform: scale(1.02);
            box-shadow: 0 0 40px rgba(255,105,180,0.6);
        }

        .start-button:active {
            transform: scale(0.98);
        }

        /* ========== GAME UI ========== */
        #gameUI {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        #gameUI > * {
            pointer-events: auto;
        }

        /* Player Stats Panel */
        .stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20,5,35,0.9), rgba(40,15,60,0.85));
            border: 2px solid rgba(255,105,180,0.4);
            border-radius: 15px;
            padding: 20px;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        .player-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,105,180,0.3);
        }

        .player-avatar {
            width: 55px;
            height: 55px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            border: 3px solid #ff69b4;
            margin-right: 15px;
            box-shadow: 0 0 15px rgba(255,105,180,0.5);
        }

        .player-info h2 {
            font-size: 18px;
            color: #fff;
            margin-bottom: 4px;
        }

        .player-info p {
            font-size: 12px;
            color: #888;
        }

        .player-info p span {
            color: #00ffff;
        }

        .stat-bar {
            margin-bottom: 12px;
        }

        .stat-bar-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .stat-bar-label {
            color: #aaa;
        }

        .stat-bar-value {
            color: #fff;
        }

        .stat-bar-track {
            height: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
            border-radius: 4px 4px 0 0;
        }

        .health-fill { background: linear-gradient(90deg, #e53935, #ff5252); }
        .mana-fill { background: linear-gradient(90deg, #1e88e5, #42a5f5); }
        .stamina-fill { background: linear-gradient(90deg, #43a047, #66bb6a); }
        .exp-fill { background: linear-gradient(90deg, #8e24aa, #ab47bc); }

        .player-resources {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 13px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .resource-gold { color: #ffd700; }
        .resource-gems { color: #00ffff; }
        .resource-sp { color: #ff69b4; }

        /* Minimap */
        .minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(0,255,255,0.4);
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-player {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            border: 2px solid #fff;
            z-index: 10;
        }

        /* Quest Log */
        .quest-panel {
            position: absolute;
            top: 220px;
            right: 20px;
            width: 280px;
            max-height: 350px;
            background: linear-gradient(145deg, rgba(20,5,35,0.9), rgba(40,15,60,0.85));
            border: 2px solid rgba(255,215,0,0.4);
            border-radius: 15px;
            padding: 15px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .quest-panel h3 {
            color: #ffd700;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
        }

        .quest-item {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quest-item:hover {
            background: rgba(255,215,0,0.1);
            transform: translateX(5px);
        }

        .quest-item.main { border-left-color: #ff69b4; }
        .quest-item.side { border-left-color: #00ffff; }
        .quest-item.hidden { border-left-color: #9932cc; }

        .quest-title {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .quest-desc {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        .quest-progress-bar {
            height: 4px;
            background: rgba(0,0,0,0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .quest-progress-fill {
            height: 100%;
            background: #ffd700;
            transition: width 0.3s ease;
        }

        /* Hotbar */
        .hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0,0,0,0.6);
            padding: 12px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255,105,180,0.3);
            backdrop-filter: blur(10px);
        }

        .hotbar-slot {
            width: 55px;
            height: 55px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .hotbar-slot:hover {
            border-color: #ff69b4;
            transform: translateY(-3px);
        }

        .hotbar-slot.selected {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }

        .hotbar-slot .slot-key {
            position: absolute;
            top: 3px;
            left: 6px;
            font-size: 10px;
            color: #666;
        }

        .hotbar-slot .slot-count {
            position: absolute;
            bottom: 3px;
            right: 6px;
            font-size: 10px;
            background: rgba(0,0,0,0.7);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .hotbar-slot .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s linear;
        }

        /* Dialogue Box */
        .dialogue-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            max-width: 90vw;
            background: linear-gradient(145deg, rgba(20,5,35,0.95), rgba(40,15,60,0.95));
            border: 2px solid rgba(0,255,255,0.4);
            border-radius: 15px;
            padding: 20px;
            display: none;
            backdrop-filter: blur(10px);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .dialogue-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0,255,255,0.3);
        }

        .dialogue-portrait {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #1a237e, #311b92);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            border: 3px solid #00ffff;
            margin-right: 15px;
        }

        .dialogue-speaker h3 {
            color: #00ffff;
            font-size: 18px;
            margin-bottom: 3px;
        }

        .dialogue-speaker p {
            color: #666;
            font-size: 12px;
        }

        .dialogue-text {
            font-size: 15px;
            line-height: 1.7;
            color: #ddd;
            min-height: 50px;
            margin-bottom: 15px;
        }

        .dialogue-choices {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dialogue-choice {
            padding: 12px 20px;
            background: rgba(0,255,255,0.1);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            font-size: 14px;
        }

        .dialogue-choice:hover {
            background: rgba(0,255,255,0.2);
            border-color: #00ffff;
            transform: translateX(10px);
        }

        .dialogue-choice::before {
            content: '‚ñ∏ ';
            color: #00ffff;
        }

        /* Combat UI */
        .combat-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(30,5,15,0.95), rgba(60,10,25,0.95));
            border: 2px solid rgba(255,0,0,0.5);
            border-radius: 20px;
            padding: 30px;
            min-width: 400px;
            display: none;
            backdrop-filter: blur(10px);
        }

        .combat-header {
            text-align: center;
            font-size: 24px;
            color: #ff4444;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .enemy-display {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .enemy-name {
            font-size: 20px;
            color: #ff6666;
            margin-bottom: 10px;
        }

        .enemy-level {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
        }

        .enemy-hp-bar {
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #cc0000, #ff4444);
            transition: width 0.3s ease;
        }

        .enemy-hp-text {
            font-size: 12px;
            color: #aaa;
        }

        .combat-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .combat-btn {
            padding: 15px;
            border: 2px solid;
            border-radius: 10px;
            background: rgba(0,0,0,0.4);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .combat-btn:hover {
            transform: scale(1.03);
        }

        .combat-btn.attack { border-color: #ff4444; }
        .combat-btn.attack:hover { background: rgba(255,68,68,0.2); box-shadow: 0 0 20px rgba(255,68,68,0.4); }

        .combat-btn.skill { border-color: #4488ff; }
        .combat-btn.skill:hover { background: rgba(68,136,255,0.2); box-shadow: 0 0 20px rgba(68,136,255,0.4); }

        .combat-btn.defend { border-color: #44ff44; }
        .combat-btn.defend:hover { background: rgba(68,255,68,0.2); box-shadow: 0 0 20px rgba(68,255,68,0.4); }

        .combat-btn.item { border-color: #ffaa44; }
        .combat-btn.item:hover { background: rgba(255,170,68,0.2); box-shadow: 0 0 20px rgba(255,170,68,0.4); }

        .combat-btn.flee {
            grid-column: span 2;
            border-color: #888;
        }
        .combat-btn.flee:hover { background: rgba(136,136,136,0.2); }

        /* Interaction Prompt */
        .interaction-prompt {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ffff;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 15px;
            display: none;
            animation: promptPulse 1.5s ease infinite;
        }

        @keyframes promptPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0,255,255,0.3); }
            50% { box-shadow: 0 0 25px rgba(0,255,255,0.6); }
        }

        .interaction-prompt span {
            color: #00ffff;
            font-weight: bold;
        }

        /* Notifications */
        .notifications-container {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            pointer-events: none;
        }

        .notification {
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            animation: notifyIn 0.4s ease, notifyOut 0.4s ease 3s forwards;
            white-space: nowrap;
        }

        @keyframes notifyIn {
            from { opacity: 0; transform: translateY(-20px) scale(0.8); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes notifyOut {
            to { opacity: 0; transform: translateY(-10px); }
        }

        .notification.quest { background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000; }
        .notification.item { background: linear-gradient(135deg, #00c853, #00e676); color: #000; }
        .notification.level { background: linear-gradient(135deg, #aa00ff, #e040fb); }
        .notification.combat { background: linear-gradient(135deg, #ff1744, #ff5252); }
        .notification.secret { background: linear-gradient(135deg, #ff69b4, #ff1493); }

        /* Damage Numbers */
        .damage-number {
            position: fixed;
            font-weight: bold;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes damageFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.3); opacity: 0; }
        }

        .damage-number.player { color: #ff4444; font-size: 24px; }
        .damage-number.enemy { color: #ffff00; font-size: 22px; }
        .damage-number.crit { color: #ff8800; font-size: 32px; }
        .damage-number.heal { color: #44ff44; font-size: 22px; }

        /* Controls Help */
        .controls-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 15px;
            font-size: 11px;
            max-width: 200px;
        }

        .controls-panel h4 {
            color: #ff69b4;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .controls-panel p {
            margin: 4px 0;
            color: #888;
        }

        .controls-panel span {
            color: #00ffff;
            font-weight: bold;
        }

        /* Skill Menu */
        .skill-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20,5,35,0.95), rgba(40,15,60,0.95));
            border: 2px solid rgba(170,0,255,0.5);
            border-radius: 20px;
            padding: 30px;
            min-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            backdrop-filter: blur(10px);
        }

        .skill-menu h2 {
            text-align: center;
            color: #aa00ff;
            margin-bottom: 25px;
        }

        .skill-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .skill-node {
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .skill-node:hover {
            border-color: #aa00ff;
            box-shadow: 0 0 20px rgba(170,0,255,0.4);
        }

        .skill-node.unlocked {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
        }

        .skill-node.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .skill-node .skill-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .skill-node .skill-name {
            font-size: 12px;
            margin-bottom: 5px;
        }

        .skill-node .skill-cost {
            font-size: 10px;
            color: #ffd700;
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(145deg, rgba(40,20,60,0.98), rgba(80,40,100,0.98));
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 2000;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .achievement-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .achievement-icon {
            font-size: 70px;
            margin-bottom: 15px;
            animation: bounce 0.6s ease infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }

        .achievement-title {
            font-size: 26px;
            color: #ffd700;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .achievement-desc {
            color: #aaa;
            font-size: 14px;
        }

        /* Time/Weather Display */
        .time-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .time-icon {
            font-size: 20px;
        }

        /* Enemy HP Floating Bar */
        .floating-hp {
            position: absolute;
            width: 60px;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .floating-hp-bar {
            height: 6px;
            background: rgba(0,0,0,0.7);
            border-radius: 3px;
            overflow: hidden;
        }

        .floating-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.2s ease;
        }

        .floating-hp-name {
            font-size: 10px;
            text-align: center;
            color: #ff6666;
            text-shadow: 1px 1px 2px #000;
            margin-bottom: 2px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ff69b4, #00ffff);
            border-radius: 4px;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .stats-panel { 
                transform: scale(0.85); 
                transform-origin: top left;
            }
            .quest-panel { 
                display: none; 
            }
            .minimap-container {
                width: 120px;
                height: 120px;
            }
            .hotbar-slot {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            .dialogue-container {
                width: 95vw;
            }
            .class-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-logo">üå∏</div>
        <h1 class="loading-title">Sakura Chronicles</h1>
        <p class="loading-subtitle">The Ethereal Realms</p>
        <div class="loading-bar-outer">
            <div class="loading-bar-inner" id="loadingBar" style="width: 0%"></div>
        </div>
        <p class="loading-status" id="loadingStatus">Initializing...</p>
        <p class="loading-tips" id="loadingTip">Tip: Talk to every NPC - some hold secrets to hidden quests!</p>
    </div>

    <!-- Character Creation -->
    <div id="characterCreation">
        <div class="creation-container">
            <h1 class="creation-title">üå∏ Create Your Hero üå∏</h1>
            
            <div class="creation-section">
                <h3>Character Name</h3>
                <input type="text" id="charName" placeholder="Enter your name..." maxlength="16">
            </div>

            <div class="creation-section">
                <h3>Choose Your Class</h3>
                <div class="class-grid">
                    <div class="class-card" data-class="warrior">
                        <div class="class-icon">‚öîÔ∏è</div>
                        <div class="class-name">Blade Dancer</div>
                        <div class="class-desc">Master of melee combat with high HP and devastating sword techniques</div>
                        <div class="class-stats">HP++ | STR++ | DEF+</div>
                    </div>
                    <div class="class-card" data-class="mage">
                        <div class="class-icon">üîÆ</div>
                        <div class="class-name">Spirit Weaver</div>
                        <div class="class-desc">Harnesses elemental magic with powerful area spells</div>
                        <div class="class-stats">MP++ | INT++ | MAG+</div>
                    </div>
                    <div class="class-card" data-class="archer">
                        <div class="class-icon">üèπ</div>
                        <div class="class-name">Wind Walker</div>
                        <div class="class-desc">Swift and precise with deadly ranged attacks</div>
                        <div class="class-stats">AGI++ | CRIT++ | DEX+</div>
                    </div>
                    <div class="class-card" data-class="healer">
                        <div class="class-icon">‚ú®</div>
                        <div class="class-name">Light Bringer</div>
                        <div class="class-desc">Support class with healing and protective abilities</div>
                        <div class="class-stats">MP++ | HEAL++ | LUCK+</div>
                    </div>
                    <div class="class-card" data-class="assassin">
                        <div class="class-icon">üó°Ô∏è</div>
                        <div class="class-name">Shadow Blade</div>
                        <div class="class-desc">Stealth specialist with critical strike mastery</div>
                        <div class="class-stats">CRIT++ | AGI++ | STR+</div>
                    </div>
                    <div class="class-card" data-class="summoner">
                        <div class="class-icon">üêâ</div>
                        <div class="class-name">Beast Caller</div>
                        <div class="class-desc">Summons mythical creatures to fight alongside you</div>
                        <div class="class-stats">INT++ | MP+ | LUCK+</div>
                    </div>
                </div>
            </div>

            <button class="start-button" id="startBtn">Begin Your Journey</button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="application-canvas"></canvas>

    <!-- Game UI -->
    <div id="gameUI">
        <!-- Time Display -->
        <div class="time-display">
            <span class="time-icon" id="timeIcon">‚òÄÔ∏è</span>
            <span id="timeText">Day 1 - Morning</span>
        </div>

        <!-- Player Stats -->
        <div class="stats-panel">
            <div class="player-header">
                <div class="player-avatar" id="playerAvatar">‚öîÔ∏è</div>
                <div class="player-info">
                    <h2 id="playerName">Hero</h2>
                    <p>Level <span id="playerLevel">1</span> ‚Ä¢ <span id="playerClass">Warrior</span></p>
                </div>
            </div>

            <div class="stat-bar">
                <div class="stat-bar-header">
                    <span class="stat-bar-label">‚ù§Ô∏è Health</span>
                    <span class="stat-bar-value"><span id="curHP">100</span>/<span id="maxHP">100</span></span>
                </div>
                <div class="stat-bar-track">
                    <div class="stat-bar-fill health-fill" id="hpBar" style="width: 100%"></div>
                </div>
            </div>

            <div class="stat-bar">
                <div class="stat-bar-header">
                    <span class="stat-bar-label">üíé Mana</span>
                    <span class="stat-bar-value"><span id="curMP">50</span>/<span id="maxMP">50</span></span>
                </div>
                <div class="stat-bar-track">
                    <div class="stat-bar-fill mana-fill" id="mpBar" style="width: 100%"></div>
                </div>
            </div>

            <div class="stat-bar">
                <div class="stat-bar-header">
                    <span class="stat-bar-label">‚ö° Stamina</span>
                    <span class="stat-bar-value"><span id="curSP">100</span>/<span id="maxSP">100</span></span>
                </div>
                <div class="stat-bar-track">
                    <div class="stat-bar-fill stamina-fill" id="spBar" style="width: 100%"></div>
                </div>
            </div>

            <div class="stat-bar">
                <div class="stat-bar-header">
                    <span class="stat-bar-label">‚≠ê Experience</span>
                    <span class="stat-bar-value"><span id="curXP">0</span>/<span id="xpNeeded">100</span></span>
                </div>
                <div class="stat-bar-track">
                    <div class="stat-bar-fill exp-fill" id="xpBar" style="width: 0%"></div>
                </div>
            </div>

            <div class="player-resources">
                <div class="resource resource-gold">üí∞ <span id="goldAmount">100</span></div>
                <div class="resource resource-gems">üí† <span id="gemAmount">0</span></div>
                <div class="resource resource-sp">üéØ <span id="skillPts">0</span> SP</div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="minimap-container">
            <canvas class="minimap-canvas" id="minimapCanvas" width="180" height="180"></canvas>
            <div class="minimap-player"></div>
        </div>

        <!-- Quest Log -->
        <div class="quest-panel">
            <h3>üìú Quest Log</h3>
            <div id="questList"></div>
        </div>

        <!-- Hotbar -->
        <div class="hotbar">
            <div class="hotbar-slot selected" data-slot="0">
                <span class="slot-key">1</span>
                ‚öîÔ∏è
            </div>
            <div class="hotbar-slot" data-slot="1">
                <span class="slot-key">2</span>
                üõ°Ô∏è
            </div>
            <div class="hotbar-slot" data-slot="2">
                <span class="slot-key">3</span>
                üß™
                <span class="slot-count">5</span>
            </div>
            <div class="hotbar-slot" data-slot="3">
                <span class="slot-key">4</span>
            </div>
            <div class="hotbar-slot" data-slot="4">
                <span class="slot-key">5</span>
            </div>
            <div class="hotbar-slot" data-slot="5">
                <span class="slot-key">6</span>
            </div>
            <div class="hotbar-slot" data-slot="6">
                <span class="slot-key">7</span>
            </div>
            <div class="hotbar-slot" data-slot="7">
                <span class="slot-key">8</span>
            </div>
        </div>

        <!-- Dialogue -->
        <div class="dialogue-container" id="dialogueBox">
            <div class="dialogue-header">
                <div class="dialogue-portrait" id="dialoguePortrait">üë§</div>
                <div class="dialogue-speaker">
                    <h3 id="dialogueName">NPC Name</h3>
                    <p id="dialogueTitle">Title</p>
                </div>
            </div>
            <div class="dialogue-text" id="dialogueText"></div>
            <div class="dialogue-choices" id="dialogueChoices"></div>
        </div>

        <!-- Combat UI -->
        <div class="combat-ui" id="combatUI">
            <div class="combat-header">‚öîÔ∏è COMBAT ‚öîÔ∏è</div>
            <div class="enemy-display">
                <div class="enemy-name" id="combatEnemyName">Enemy</div>
                <div class="enemy-level" id="combatEnemyLevel">Level 1</div>
                <div class="enemy-hp-bar">
                    <div class="enemy-hp-fill" id="combatEnemyHP" style="width: 100%"></div>
                </div>
                <div class="enemy-hp-text"><span id="combatEnemyCurHP">100</span> / <span id="combatEnemyMaxHP">100</span></div>
            </div>
            <div class="combat-actions">
                <button class="combat-btn attack" id="btnAttack">‚öîÔ∏è Attack</button>
                <button class="combat-btn skill" id="btnSkill">üîÆ Skills</button>
                <button class="combat-btn defend" id="btnDefend">üõ°Ô∏è Defend</button>
                <button class="combat-btn item" id="btnItem">üß™ Items</button>
                <button class="combat-btn flee" id="btnFlee">üèÉ Flee</button>
            </div>
        </div>

        <!-- Interaction Prompt -->
        <div class="interaction-prompt" id="interactionPrompt">
            Press <span>E</span> to interact
        </div>

        <!-- Notifications -->
        <div class="notifications-container" id="notifications"></div>

        <!-- Controls -->
        <div class="controls-panel">
            <h4>üéÆ Controls</h4>
            <p><span>WASD</span> - Move</p>
            <p><span>SHIFT</span> - Sprint</p>
            <p><span>SPACE</span> - Jump</p>
            <p><span>E</span> - Interact</p>
            <p><span>F</span> - Attack</p>
            <p><span>Q</span> - Special</p>
            <p><span>TAB</span> - Inventory</p>
            <p><span>M</span> - Map</p>
        </div>

        <!-- Skill Menu -->
        <div class="skill-menu" id="skillMenu">
            <h2>üîÆ Skill Tree</h2>
            <div class="skill-grid" id="skillGrid"></div>
            <button class="start-button" style="margin-top: 20px;" id="closeSkillMenu">Close</button>
        </div>
    </div>

    <!-- Achievement Popup -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon" id="achievementIcon">üèÜ</div>
        <h2 class="achievement-title" id="achievementTitle">Achievement Unlocked!</h2>
        <p class="achievement-desc" id="achievementDesc">Description</p>
    </div>

    <script>
    // =====================================================
    // SAKURA CHRONICLES - PLAYCANVAS EDITION
    // Optimized 3D Anime Action RPG
    // =====================================================

    (function() {
        'use strict';

        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            WORLD_SIZE: 500,
            CHUNK_SIZE: 50,
            VIEW_DISTANCE: 150,
            DAY_LENGTH: 600, // seconds for full day cycle
            GRAVITY: -20,
            PLAYER_SPEED: 8,
            SPRINT_MULTIPLIER: 1.7,
            JUMP_FORCE: 10,
            INTERACTION_RANGE: 4,
            AGGRO_RANGE: 15
        };

        // ==================== GAME STATE ====================
        const GameState = {
            LOADING: 'loading',
            CHARACTER_CREATE: 'character_create',
            PLAYING: 'playing',
            DIALOGUE: 'dialogue',
            COMBAT: 'combat',
            PAUSED: 'paused',
            CUTSCENE: 'cutscene'
        };

        // ==================== MAIN GAME CLASS ====================
        class SakuraChronicles {
            constructor() {
                this.state = GameState.LOADING;
                this.app = null;
                this.player = null;
                this.camera = null;
                this.systems = {};
                this.entities = {
                    npcs: [],
                    enemies: [],
                    items: [],
                    interactables: []
                };
                this.gameTime = 0;
                this.dayTime = 0;
                this.flags = {};
                this.easterEggs = [];
            }

            async initialize() {
                await this.initPlayCanvas();
                await this.loadAssets();
                this.initSystems();
                this.showCharacterCreation();
            }

            async initPlayCanvas() {
                const canvas = document.getElementById('application-canvas');
                
                this.app = new pc.Application(canvas, {
                    mouse: new pc.Mouse(canvas),
                    keyboard: new pc.Keyboard(window),
                    touch: 'ontouchstart' in window ? new pc.TouchDevice(canvas) : null,
                    graphicsDeviceOptions: {
                        antialias: true,
                        alpha: false,
                        preserveDrawingBuffer: false,
                        preferWebGl2: true
                    }
                });

                this.app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                this.app.setCanvasResolution(pc.RESOLUTION_AUTO);
                
                // Enable features
                this.app.scene.ambientLight = new pc.Color(0.3, 0.3, 0.4);
                this.app.scene.gammaCorrection = pc.GAMMA_SRGB;
                this.app.scene.toneMapping = pc.TONEMAP_ACES;
                this.app.scene.exposure = 1.2;
                this.app.scene.skyboxMip = 2;

                // Fog for atmosphere
                this.app.scene.fog = pc.FOG_LINEAR;
                this.app.scene.fogColor = new pc.Color(0.5, 0.6, 0.7);
                this.app.scene.fogStart = 50;
                this.app.scene.fogEnd = 200;

                this.app.start();

                window.addEventListener('resize', () => {
                    this.app.resizeCanvas();
                });

                this.updateLoadingProgress(20, 'PlayCanvas initialized...');
            }

            async loadAssets() {
                // Since we're creating procedural content, simulate asset loading
                const steps = [
                    { progress: 30, text: 'Loading world data...' },
                    { progress: 45, text: 'Generating terrain...' },
                    { progress: 60, text: 'Creating NPCs...' },
                    { progress: 75, text: 'Spawning enemies...' },
                    { progress: 90, text: 'Loading quests...' },
                    { progress: 100, text: 'Ready!' }
                ];

                for (const step of steps) {
                    await this.delay(200 + Math.random() * 300);
                    this.updateLoadingProgress(step.progress, step.text);
                }

                await this.delay(500);
            }

            initSystems() {
                this.systems.input = new InputSystem(this);
                this.systems.world = new WorldSystem(this);
                this.systems.player = new PlayerSystem(this);
                this.systems.combat = new CombatSystem(this);
                this.systems.dialogue = new DialogueSystem(this);
                this.systems.quest = new QuestSystem(this);
                this.systems.inventory = new InventorySystem(this);
                this.systems.ui = new UISystem(this);
                this.systems.audio = new AudioSystem(this);
                this.systems.particle = new ParticleSystem(this);
                this.systems.achievement = new AchievementSystem(this);
            }

            showCharacterCreation() {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('characterCreation').style.display = 'flex';
                this.state = GameState.CHARACTER_CREATE;

                // Class selection
                const classCards = document.querySelectorAll('.class-card');
                classCards.forEach(card => {
                    card.addEventListener('click', () => {
                        classCards.forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                    });
                });

                // Select first by default
                classCards[0].classList.add('selected');

                // Start button
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startGame();
                });
            }

            startGame() {
                const name = document.getElementById('charName').value.trim() || 'Hero';
                const selectedClass = document.querySelector('.class-card.selected');
                const playerClass = selectedClass ? selectedClass.dataset.class : 'warrior';

                document.getElementById('characterCreation').style.display = 'none';
                document.getElementById('gameUI').style.display = 'block';

                // Initialize game world
                this.systems.world.createWorld();
                this.systems.player.create(name, playerClass);
                this.systems.quest.initialize();

                // Setup camera
                this.setupCamera();

                // Setup lighting
                this.setupLighting();

                // Start game loop
                this.state = GameState.PLAYING;
                this.app.on('update', (dt) => this.update(dt));

                // Show intro
                setTimeout(() => {
                    this.systems.dialogue.start('elder_sakura', 'intro');
                    this.systems.ui.notify('Welcome to Sakura Village!', 'quest');
                }, 1500);
            }

            setupCamera() {
                this.camera = new pc.Entity('MainCamera');
                this.camera.addComponent('camera', {
                    clearColor: new pc.Color(0.4, 0.5, 0.6),
                    fov: 60,
                    nearClip: 0.1,
                    farClip: 1000
                });
                this.camera.setPosition(0, 15, 25);
                this.camera.lookAt(0, 0, 0);
                this.app.root.addChild(this.camera);
            }

            setupLighting() {
                // Directional light (sun)
                this.sunLight = new pc.Entity('Sun');
                this.sunLight.addComponent('light', {
                    type: 'directional',
                    color: new pc.Color(1, 0.95, 0.9),
                    intensity: 1.2,
                    castShadows: true,
                    shadowBias: 0.2,
                    shadowDistance: 100,
                    shadowResolution: 2048,
                    normalOffsetBias: 0.05
                });
                this.sunLight.setEulerAngles(45, 135, 0);
                this.app.root.addChild(this.sunLight);

                // Ambient hemisphere
                this.app.scene.ambientLight = new pc.Color(0.4, 0.4, 0.5);

                // Accent lights for anime feel
                const pinkLight = new pc.Entity('PinkLight');
                pinkLight.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(1, 0.4, 0.7),
                    intensity: 0.3,
                    range: 50
                });
                pinkLight.setPosition(-30, 20, 20);
                this.app.root.addChild(pinkLight);

                const cyanLight = new pc.Entity('CyanLight');
                cyanLight.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0, 1, 1),
                    intensity: 0.2,
                    range: 40
                });
                cyanLight.setPosition(30, 15, -20);
                this.app.root.addChild(cyanLight);
            }

            update(dt) {
                if (this.state !== GameState.PLAYING && 
                    this.state !== GameState.DIALOGUE &&
                    this.state !== GameState.COMBAT) return;

                this.gameTime += dt;
                this.updateDayNightCycle(dt);

                this.systems.input.update(dt);
                this.systems.player.update(dt);
                this.systems.world.update(dt);
                this.systems.combat.update(dt);
                this.systems.particle.update(dt);
                this.systems.ui.update(dt);
                
                this.updateCamera(dt);
            }

            updateDayNightCycle(dt) {
                this.dayTime += dt / CONFIG.DAY_LENGTH;
                if (this.dayTime >= 1) this.dayTime = 0;

                const t = this.dayTime;
                let timeText, timeIcon;
                let sunIntensity = 1.2;
                let ambientColor = new pc.Color(0.4, 0.4, 0.5);
                let fogColor = new pc.Color(0.5, 0.6, 0.7);

                if (t < 0.25) {
                    // Morning
                    timeText = 'Morning';
                    timeIcon = 'üåÖ';
                    const blend = t / 0.25;
                    sunIntensity = 0.6 + blend * 0.6;
                    fogColor = new pc.Color(0.6 + blend * 0.1, 0.5 + blend * 0.1, 0.5);
                } else if (t < 0.5) {
                    // Day
                    timeText = 'Day';
                    timeIcon = '‚òÄÔ∏è';
                    sunIntensity = 1.2;
                } else if (t < 0.75) {
                    // Evening
                    timeText = 'Evening';
                    timeIcon = 'üåá';
                    const blend = (t - 0.5) / 0.25;
                    sunIntensity = 1.2 - blend * 0.8;
                    fogColor = new pc.Color(0.7 - blend * 0.3, 0.4, 0.3 + blend * 0.2);
                    ambientColor = new pc.Color(0.4 - blend * 0.2, 0.3 - blend * 0.1, 0.4);
                } else {
                    // Night
                    timeText = 'Night';
                    timeIcon = 'üåô';
                    sunIntensity = 0.2;
                    fogColor = new pc.Color(0.1, 0.1, 0.2);
                    ambientColor = new pc.Color(0.15, 0.15, 0.25);
                }

                const day = Math.floor(this.gameTime / CONFIG.DAY_LENGTH) + 1;
                document.getElementById('timeText').textContent = `Day ${day} - ${timeText}`;
                document.getElementById('timeIcon').textContent = timeIcon;

                this.sunLight.light.intensity = sunIntensity;
                this.app.scene.ambientLight = ambientColor;
                this.app.scene.fogColor = fogColor;
            }

            updateCamera(dt) {
                if (!this.player) return;

                const playerPos = this.player.getPosition();
                const cameraOffset = new pc.Vec3(0, 12, 20);
                
                // Rotate offset based on camera rotation
                const rotation = this.systems.input.cameraRotation;
                const rotatedOffset = new pc.Vec3(
                    Math.sin(rotation) * cameraOffset.z,
                    cameraOffset.y,
                    Math.cos(rotation) * cameraOffset.z
                );

                const targetPos = new pc.Vec3().add2(playerPos, rotatedOffset);
                const currentPos = this.camera.getPosition();
                
                // Smooth follow
                currentPos.lerp(currentPos, targetPos, dt * 5);
                this.camera.setPosition(currentPos);
                this.camera.lookAt(playerPos.x, playerPos.y + 2, playerPos.z);
            }

            updateLoadingProgress(percent, text) {
                document.getElementById('loadingBar').style.width = percent + '%';
                document.getElementById('loadingStatus').textContent = text;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ==================== INPUT SYSTEM ====================
        class InputSystem {
            constructor(game) {
                this.game = game;
                this.keys = {};
                this.mouse = { x: 0, y: 0, dx: 0, dy: 0 };
                this.cameraRotation = 0;
                this.isPointerLocked = false;

                this.setupListeners();
            }

            setupListeners() {
                const keyboard = this.game.app.keyboard;
                const mouse = this.game.app.mouse;

                // Key mapping
                this.keyMap = {
                    [pc.KEY_W]: 'forward',
                    [pc.KEY_S]: 'backward',
                    [pc.KEY_A]: 'left',
                    [pc.KEY_D]: 'right',
                    [pc.KEY_SPACE]: 'jump',
                    [pc.KEY_SHIFT]: 'sprint',
                    [pc.KEY_E]: 'interact',
                    [pc.KEY_F]: 'attack',
                    [pc.KEY_Q]: 'special',
                    [pc.KEY_TAB]: 'inventory',
                    [pc.KEY_M]: 'map',
                    [pc.KEY_K]: 'skills',
                    [pc.KEY_ESCAPE]: 'menu'
                };

                // Number keys for hotbar
                for (let i = 1; i <= 8; i++) {
                    this.keyMap[pc.KEY_0 + i] = `hotbar${i}`;
                }

                // Mouse movement
                if (mouse) {
                    mouse.on(pc.EVENT_MOUSEMOVE, (event) => {
                        this.mouse.dx = event.dx;
                        this.mouse.dy = event.dy;
                        
                        if (this.isPointerLocked || event.buttons[pc.MOUSEBUTTON_RIGHT]) {
                            this.cameraRotation -= event.dx * 0.003;
                        }
                    });

                    mouse.on(pc.EVENT_MOUSEDOWN, (event) => {
                        if (event.button === pc.MOUSEBUTTON_LEFT) {
                            this.keys.attack = true;
                        }
                    });

                    mouse.on(pc.EVENT_MOUSEUP, (event) => {
                        if (event.button === pc.MOUSEBUTTON_LEFT) {
                            this.keys.attack = false;
                        }
                    });
                }

                // Pointer lock
                document.addEventListener('click', () => {
                    if (this.game.state === GameState.PLAYING) {
                        document.body.requestPointerLock?.();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === document.body;
                });
            }

            update(dt) {
                const keyboard = this.game.app.keyboard;

                // Update key states
                Object.entries(this.keyMap).forEach(([keyCode, action]) => {
                    this.keys[action] = keyboard.isPressed(parseInt(keyCode));
                });

                // Handle single-press actions
                if (keyboard.wasPressed(pc.KEY_E)) {
                    this.game.systems.player.interact();
                }

                if (keyboard.wasPressed(pc.KEY_K)) {
                    this.game.systems.ui.toggleSkillMenu();
                }

                if (keyboard.wasPressed(pc.KEY_ESCAPE)) {
                    if (this.game.state === GameState.DIALOGUE) {
                        this.game.systems.dialogue.close();
                    }
                }

                // Reset mouse delta
                this.mouse.dx = 0;
                this.mouse.dy = 0;
            }

            isPressed(action) {
                return this.keys[action] || false;
            }

            wasPressed(action) {
                return this.game.app.keyboard.wasPressed(this.getKeyCode(action));
            }

            getKeyCode(action) {
                for (const [code, act] of Object.entries(this.keyMap)) {
                    if (act === action) return parseInt(code);
                }
                return null;
            }
        }

        // ==================== WORLD SYSTEM ====================
        class WorldSystem {
            constructor(game) {
                this.game = game;
                this.chunks = new Map();
                this.respawnPoint = new pc.Vec3(0, 0, 0);
            }

            createWorld() {
                this.createTerrain();
                this.createSakuraVillage();
                this.createForest();
                this.createMountains();
                this.createCaverns();
                this.spawnNPCs();
                this.spawnEnemies();
                this.createEasterEggs();
            }

            createTerrain() {
                // Main ground
                const ground = new pc.Entity('Ground');
                ground.addComponent('render', {
                    type: 'plane'
                });
                ground.setLocalScale(CONFIG.WORLD_SIZE, 1, CONFIG.WORLD_SIZE);
                
                // Create ground material
                const groundMat = new pc.StandardMaterial();
                groundMat.diffuse = new pc.Color(0.2, 0.5, 0.2);
                groundMat.update();
                ground.render.meshInstances[0].material = groundMat;

                // Add collision for physics
                ground.addComponent('collision', {
                    type: 'box',
                    halfExtents: new pc.Vec3(CONFIG.WORLD_SIZE / 2, 0.5, CONFIG.WORLD_SIZE / 2)
                });
                ground.addComponent('rigidbody', {
                    type: 'static'
                });

                this.game.app.root.addChild(ground);

                // Create some terrain variation with additional geometry
                this.createHills();
                this.createWaterBodies();
                this.createPaths();
            }

            createHills() {
                const hillPositions = [
                    { x: 80, z: 60, scale: 20, height: 8 },
                    { x: -70, z: 80, scale: 25, height: 10 },
                    { x: 100, z: -80, scale: 30, height: 12 },
                    { x: -90, z: -60, scale: 18, height: 6 }
                ];

                hillPositions.forEach((hill, i) => {
                    const entity = new pc.Entity(`Hill${i}`);
                    entity.addComponent('render', {
                        type: 'sphere'
                    });
                    entity.setPosition(hill.x, hill.height / 2 - 2, hill.z);
                    entity.setLocalScale(hill.scale, hill.height, hill.scale);

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = new pc.Color(0.25, 0.45, 0.2);
                    mat.update();
                    entity.render.meshInstances[0].material = mat;

                    entity.addComponent('collision', {
                        type: 'sphere',
                        radius: hill.scale / 2
                    });
                    entity.addComponent('rigidbody', {
                        type: 'static'
                    });

                    this.game.app.root.addChild(entity);
                });
            }

            createWaterBodies() {
                // Lake
                const lake = new pc.Entity('Lake');
                lake.addComponent('render', {
                    type: 'cylinder'
                });
                lake.setPosition(60, 0.1, -40);
                lake.setLocalScale(50, 0.2, 50);

                const waterMat = new pc.StandardMaterial();
                waterMat.diffuse = new pc.Color(0.1, 0.4, 0.7);
                waterMat.opacity = 0.7;
                waterMat.blendType = pc.BLEND_NORMAL;
                waterMat.update();
                lake.render.meshInstances[0].material = waterMat;

                this.game.app.root.addChild(lake);

                // River
                this.createRiver();
            }

            createRiver() {
                const riverPoints = [
                    { x: -100, z: 50 },
                    { x: -60, z: 40 },
                    { x: -20, z: 30 },
                    { x: 20, z: 35 },
                    { x: 60, z: -40 }
                ];

                for (let i = 0; i < riverPoints.length - 1; i++) {
                    const start = riverPoints[i];
                    const end = riverPoints[i + 1];
                    
                    const segment = new pc.Entity(`RiverSegment${i}`);
                    segment.addComponent('render', {
                        type: 'box'
                    });

                    const midX = (start.x + end.x) / 2;
                    const midZ = (start.z + end.z) / 2;
                    const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2));
                    const angle = Math.atan2(end.z - start.z, end.x - start.x);

                    segment.setPosition(midX, 0.1, midZ);
                    segment.setLocalScale(length, 0.1, 8);
                    segment.setEulerAngles(0, -angle * (180 / Math.PI), 0);

                    const waterMat = new pc.StandardMaterial();
                    waterMat.diffuse = new pc.Color(0.1, 0.5, 0.8);
                    waterMat.opacity = 0.6;
                    waterMat.blendType = pc.BLEND_NORMAL;
                    waterMat.update();
                    segment.render.meshInstances[0].material = waterMat;

                    this.game.app.root.addChild(segment);
                }
            }

            createPaths() {
                const pathColor = new pc.Color(0.5, 0.45, 0.35);
                
                const paths = [
                    { start: { x: 0, z: 5 }, end: { x: 0, z: -50 }, width: 4 },
                    { start: { x: 0, z: 5 }, end: { x: 50, z: 5 }, width: 4 },
                    { start: { x: 0, z: 5 }, end: { x: -50, z: 30 }, width: 3 }
                ];

                paths.forEach((path, i) => {
                    const segment = new pc.Entity(`Path${i}`);
                    segment.addComponent('render', {
                        type: 'box'
                    });

                    const midX = (path.start.x + path.end.x) / 2;
                    const midZ = (path.start.z + path.end.z) / 2;
                    const length = Math.sqrt(
                        Math.pow(path.end.x - path.start.x, 2) + 
                        Math.pow(path.end.z - path.start.z, 2)
                    );
                    const angle = Math.atan2(path.end.z - path.start.z, path.end.x - path.start.x);

                    segment.setPosition(midX, 0.05, midZ);
                    segment.setLocalScale(length, 0.1, path.width);
                    segment.setEulerAngles(0, -angle * (180 / Math.PI), 0);

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = pathColor;
                    mat.update();
                    segment.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(segment);
                });
            }

            createSakuraVillage() {
                // Create sakura trees around village
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const radius = 25 + Math.random() * 30;
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 15;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 15;
                    
                    this.createSakuraTree(x, z);
                }

                // Create buildings
                this.createBuilding(-12, -8, 'Sakura Inn', { w: 10, h: 8, d: 8 }, 0xf5deb3);
                this.createBuilding(15, -5, 'General Store', { w: 7, h: 6, d: 6 }, 0xdeb887);
                this.createBuilding(-20, 12, 'Blacksmith', { w: 9, h: 7, d: 8 }, 0x696969);
                this.createBuilding(12, 18, 'Elder\'s House', { w: 12, h: 10, d: 10 }, 0x8b0000);
                this.createBuilding(-5, 25, 'Training Dojo', { w: 15, h: 6, d: 12 }, 0xffffff);
                this.createBuilding(28, 8, 'Potion Shop', { w: 6, h: 5, d: 5 }, 0x9932cc);

                // Village well (Easter egg)
                this.createWell(0, 8);

                // Shrine
                this.createShrine(0, -30);

                // Decorations
                this.createVillageDecorations();
            }

            createSakuraTree(x, z) {
                const tree = new pc.Entity('SakuraTree');

                // Trunk
                const trunk = new pc.Entity('Trunk');
                trunk.addComponent('render', { type: 'cylinder' });
                trunk.setLocalScale(0.6, 6, 0.6);
                trunk.setLocalPosition(0, 3, 0);
                
                const trunkMat = new pc.StandardMaterial();
                trunkMat.diffuse = new pc.Color(0.4, 0.25, 0.15);
                trunkMat.update();
                trunk.render.meshInstances[0].material = trunkMat;
                tree.addChild(trunk);

                // Foliage (multiple pink spheres)
                const foliageColor = new pc.Color(
                    0.95 + Math.random() * 0.05,
                    0.6 + Math.random() * 0.2,
                    0.7 + Math.random() * 0.15
                );

                for (let i = 0; i < 5; i++) {
                    const foliage = new pc.Entity(`Foliage${i}`);
                    foliage.addComponent('render', { type: 'sphere' });
                    
                    const size = 2 + Math.random() * 1.5;
                    foliage.setLocalScale(size, size * 0.8, size);
                    foliage.setLocalPosition(
                        (Math.random() - 0.5) * 3,
                        6 + Math.random() * 2,
                        (Math.random() - 0.5) * 3
                    );

                    const foliageMat = new pc.StandardMaterial();
                    foliageMat.diffuse = foliageColor;
                    foliageMat.update();
```javascript
                    foliage.render.meshInstances[0].material = foliageMat;
                    tree.addChild(foliage);
                }

                tree.setPosition(x, 0, z);
                tree.addComponent('collision', {
                    type: 'cylinder',
                    radius: 0.5,
                    height: 6
                });
                tree.addComponent('rigidbody', { type: 'static' });

                this.game.app.root.addChild(tree);
            }

            createBuilding(x, z, name, size, colorHex) {
                const building = new pc.Entity(name);

                // Main structure
                const walls = new pc.Entity('Walls');
                walls.addComponent('render', { type: 'box' });
                walls.setLocalScale(size.w, size.h, size.d);
                walls.setLocalPosition(0, size.h / 2, 0);

                const wallMat = new pc.StandardMaterial();
                wallMat.diffuse = new pc.Color(
                    ((colorHex >> 16) & 255) / 255,
                    ((colorHex >> 8) & 255) / 255,
                    (colorHex & 255) / 255
                );
                wallMat.update();
                walls.render.meshInstances[0].material = wallMat;
                building.addChild(walls);

                // Roof (Japanese style)
                const roof = new pc.Entity('Roof');
                roof.addComponent('render', { type: 'cone' });
                roof.setLocalScale(Math.max(size.w, size.d) * 1.3, size.h * 0.5, Math.max(size.w, size.d) * 1.3);
                roof.setLocalPosition(0, size.h + size.h * 0.25, 0);

                const roofMat = new pc.StandardMaterial();
                roofMat.diffuse = new pc.Color(0.15, 0.1, 0.1);
                roofMat.update();
                roof.render.meshInstances[0].material = roofMat;
                building.addChild(roof);

                // Door
                const door = new pc.Entity('Door');
                door.addComponent('render', { type: 'box' });
                door.setLocalScale(1.5, 3, 0.2);
                door.setLocalPosition(0, 1.5, size.d / 2 + 0.1);

                const doorMat = new pc.StandardMaterial();
                doorMat.diffuse = new pc.Color(0.4, 0.25, 0.1);
                doorMat.update();
                door.render.meshInstances[0].material = doorMat;
                building.addChild(door);

                // Windows
                for (let i = -1; i <= 1; i += 2) {
                    const window = new pc.Entity('Window');
                    window.addComponent('render', { type: 'box' });
                    window.setLocalScale(1.2, 1.2, 0.15);
                    window.setLocalPosition(i * (size.w / 3), size.h * 0.6, size.d / 2 + 0.1);

                    const windowMat = new pc.StandardMaterial();
                    windowMat.diffuse = new pc.Color(0.6, 0.8, 1);
                    windowMat.emissive = new pc.Color(0.1, 0.15, 0.2);
                    windowMat.update();
                    window.render.meshInstances[0].material = windowMat;
                    building.addChild(window);
                }

                // Lanterns
                this.createLantern(building, -size.w / 2 - 0.8, 3, size.d / 2);
                this.createLantern(building, size.w / 2 + 0.8, 3, size.d / 2);

                building.setPosition(x, 0, z);
                
                // Collision
                building.addComponent('collision', {
                    type: 'box',
                    halfExtents: new pc.Vec3(size.w / 2, size.h / 2, size.d / 2)
                });
                building.collision.linearOffset = new pc.Vec3(0, size.h / 2, 0);
                building.addComponent('rigidbody', { type: 'static' });

                building.tags.add('building');
                building.userData = { name: name, type: 'building' };

                this.game.app.root.addChild(building);
                this.game.entities.interactables.push({
                    entity: building,
                    type: 'building',
                    name: name
                });
            }

            createLantern(parent, x, y, z) {
                const lantern = new pc.Entity('Lantern');

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'box' });
                body.setLocalScale(0.4, 0.6, 0.4);

                const bodyMat = new pc.StandardMaterial();
                bodyMat.diffuse = new pc.Color(1, 0.3, 0.1);
                bodyMat.emissive = new pc.Color(0.5, 0.15, 0.05);
                bodyMat.update();
                body.render.meshInstances[0].material = bodyMat;
                lantern.addChild(body);

                // Light
                const light = new pc.Entity('Light');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(1, 0.6, 0.3),
                    intensity: 0.5,
                    range: 10,
                    castShadows: false
                });
                lantern.addChild(light);

                lantern.setLocalPosition(x, y, z);
                parent.addChild(lantern);
            }

            createWell(x, z) {
                const well = new pc.Entity('VillageWell');

                // Base
                const base = new pc.Entity('Base');
                base.addComponent('render', { type: 'cylinder' });
                base.setLocalScale(3, 1, 3);
                base.setLocalPosition(0, 0.5, 0);

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.5, 0.5, 0.5);
                stoneMat.update();
                base.render.meshInstances[0].material = stoneMat;
                well.addChild(base);

                // Inner dark
                const inner = new pc.Entity('Inner');
                inner.addComponent('render', { type: 'cylinder' });
                inner.setLocalScale(2, 1.1, 2);
                inner.setLocalPosition(0, 0.5, 0);

                const darkMat = new pc.StandardMaterial();
                darkMat.diffuse = new pc.Color(0.02, 0.02, 0.05);
                darkMat.update();
                inner.render.meshInstances[0].material = darkMat;
                well.addChild(inner);

                // Roof supports
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const post = new pc.Entity(`Post${i}`);
                    post.addComponent('render', { type: 'box' });
                    post.setLocalScale(0.15, 2.5, 0.15);
                    post.setLocalPosition(Math.cos(angle) * 1.3, 2.25, Math.sin(angle) * 1.3);

                    const woodMat = new pc.StandardMaterial();
                    woodMat.diffuse = new pc.Color(0.4, 0.25, 0.15);
                    woodMat.update();
                    post.render.meshInstances[0].material = woodMat;
                    well.addChild(post);
                }

                // Roof
                const roof = new pc.Entity('Roof');
                roof.addComponent('render', { type: 'cone' });
                roof.setLocalScale(3.5, 1.5, 3.5);
                roof.setLocalPosition(0, 4.25, 0);

                const roofMat = new pc.StandardMaterial();
                roofMat.diffuse = new pc.Color(0.5, 0.1, 0.1);
                roofMat.update();
                roof.render.meshInstances[0].material = roofMat;
                well.addChild(roof);

                well.setPosition(x, 0, z);
                well.tags.add('interactable');
                well.userData = {
                    type: 'well',
                    name: 'Village Well',
                    coinsThrown: 0,
                    isEasterEgg: true
                };

                this.game.app.root.addChild(well);
                this.game.entities.interactables.push({
                    entity: well,
                    type: 'well',
                    name: 'Village Well'
                });
            }

            createShrine(x, z) {
                const shrine = new pc.Entity('Shrine');

                // Platform
                const platform = new pc.Entity('Platform');
                platform.addComponent('render', { type: 'box' });
                platform.setLocalScale(10, 0.5, 10);
                platform.setLocalPosition(0, 0.25, 0);

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.85, 0.85, 0.85);
                stoneMat.update();
                platform.render.meshInstances[0].material = stoneMat;
                shrine.addChild(platform);

                // Torii gate
                const toriiMat = new pc.StandardMaterial();
                toriiMat.diffuse = new pc.Color(0.8, 0.1, 0.1);
                toriiMat.update();

                // Pillars
                for (let i = -1; i <= 1; i += 2) {
                    const pillar = new pc.Entity(`ToriiPillar${i}`);
                    pillar.addComponent('render', { type: 'cylinder' });
                    pillar.setLocalScale(0.5, 6, 0.5);
                    pillar.setLocalPosition(i * 3, 3.5, 4);
                    pillar.render.meshInstances[0].material = toriiMat;
                    shrine.addChild(pillar);
                }

                // Top beam
                const beam = new pc.Entity('ToriiBeam');
                beam.addComponent('render', { type: 'box' });
                beam.setLocalScale(8, 0.5, 0.5);
                beam.setLocalPosition(0, 6, 4);
                beam.render.meshInstances[0].material = toriiMat;
                shrine.addChild(beam);

                // Shrine building
                const shrineBuilding = new pc.Entity('ShrineBuilding');
                shrineBuilding.addComponent('render', { type: 'box' });
                shrineBuilding.setLocalScale(5, 4, 4);
                shrineBuilding.setLocalPosition(0, 2.5, -2);

                const buildingMat = new pc.StandardMaterial();
                buildingMat.diffuse = new pc.Color(0.95, 0.92, 0.85);
                buildingMat.update();
                shrineBuilding.render.meshInstances[0].material = buildingMat;
                shrine.addChild(shrineBuilding);

                // Shrine roof
                const shrineRoof = new pc.Entity('ShrineRoof');
                shrineRoof.addComponent('render', { type: 'cone' });
                shrineRoof.setLocalScale(7, 2.5, 7);
                shrineRoof.setLocalPosition(0, 5.75, -2);

                const shrineRoofMat = new pc.StandardMaterial();
                shrineRoofMat.diffuse = new pc.Color(0.2, 0.15, 0.1);
                shrineRoofMat.update();
                shrineRoof.render.meshInstances[0].material = shrineRoofMat;
                shrine.addChild(shrineRoof);

                // Sacred glow
                const glow = new pc.Entity('ShrineGlow');
                glow.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(1, 0.85, 0.4),
                    intensity: 1,
                    range: 15
                });
                glow.setLocalPosition(0, 3, -2);
                shrine.addChild(glow);

                shrine.setPosition(x, 0, z);
                shrine.tags.add('interactable', 'shrine');
                shrine.userData = {
                    type: 'shrine',
                    name: 'Sacred Shrine'
                };

                this.game.app.root.addChild(shrine);
                this.game.entities.interactables.push({
                    entity: shrine,
                    type: 'shrine',
                    name: 'Sacred Shrine'
                });

                // Set as respawn point
                this.respawnPoint = new pc.Vec3(x, 0, z + 8);
            }

            createVillageDecorations() {
                // Stone lanterns along paths
                const lanternPositions = [
                    { x: 3, z: -15 }, { x: -3, z: -15 },
                    { x: 3, z: -25 }, { x: -3, z: -25 },
                    { x: 15, z: 3 }, { x: 25, z: 3 }
                ];

                lanternPositions.forEach((pos, i) => {
                    this.createStoneLantern(pos.x, pos.z);
                });

                // Benches
                const benchPositions = [
                    { x: 8, z: 12, rot: 0 },
                    { x: -15, z: -5, rot: 90 },
                    { x: 5, z: -18, rot: 180 }
                ];

                benchPositions.forEach((pos, i) => {
                    this.createBench(pos.x, pos.z, pos.rot);
                });

                // Flower patches
                for (let i = 0; i < 40; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 25;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    this.createFlower(x, z);
                }

                // Training dummies
                this.createTrainingDummy(-8, 35);
                this.createTrainingDummy(-2, 35);
                this.createTrainingDummy(4, 35);

                // Cat (Easter egg)
                this.createCat(8, 5);
            }

            createStoneLantern(x, z) {
                const lantern = new pc.Entity('StoneLantern');

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.6, 0.6, 0.6);
                stoneMat.update();

                // Base
                const base = new pc.Entity('Base');
                base.addComponent('render', { type: 'cylinder' });
                base.setLocalScale(0.8, 0.4, 0.8);
                base.setLocalPosition(0, 0.2, 0);
                base.render.meshInstances[0].material = stoneMat;
                lantern.addChild(base);

                // Pillar
                const pillar = new pc.Entity('Pillar');
                pillar.addComponent('render', { type: 'cylinder' });
                pillar.setLocalScale(0.3, 1.2, 0.3);
                pillar.setLocalPosition(0, 1, 0);
                pillar.render.meshInstances[0].material = stoneMat;
                lantern.addChild(pillar);

                // Light housing
                const housing = new pc.Entity('Housing');
                housing.addComponent('render', { type: 'box' });
                housing.setLocalScale(0.7, 0.7, 0.7);
                housing.setLocalPosition(0, 1.95, 0);
                housing.render.meshInstances[0].material = stoneMat;
                lantern.addChild(housing);

                // Roof
                const roof = new pc.Entity('Roof');
                roof.addComponent('render', { type: 'cone' });
                roof.setLocalScale(1, 0.5, 1);
                roof.setLocalPosition(0, 2.55, 0);
                roof.render.meshInstances[0].material = stoneMat;
                lantern.addChild(roof);

                // Light
                const light = new pc.Entity('Light');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(1, 0.7, 0.4),
                    intensity: 0.4,
                    range: 8
                });
                light.setLocalPosition(0, 1.95, 0);
                lantern.addChild(light);

                lantern.setPosition(x, 0, z);
                this.game.app.root.addChild(lantern);
            }

            createBench(x, z, rotation) {
                const bench = new pc.Entity('Bench');

                const woodMat = new pc.StandardMaterial();
                woodMat.diffuse = new pc.Color(0.45, 0.3, 0.2);
                woodMat.update();

                // Seat
                const seat = new pc.Entity('Seat');
                seat.addComponent('render', { type: 'box' });
                seat.setLocalScale(2.5, 0.15, 0.8);
                seat.setLocalPosition(0, 0.6, 0);
                seat.render.meshInstances[0].material = woodMat;
                bench.addChild(seat);

                // Legs
                for (let i = -1; i <= 1; i += 2) {
                    const leg = new pc.Entity(`Leg${i}`);
                    leg.addComponent('render', { type: 'box' });
                    leg.setLocalScale(0.15, 0.6, 0.6);
                    leg.setLocalPosition(i * 1, 0.3, 0);
                    leg.render.meshInstances[0].material = woodMat;
                    bench.addChild(leg);
                }

                bench.setPosition(x, 0, z);
                bench.setEulerAngles(0, rotation, 0);
                this.game.app.root.addChild(bench);
            }

            createFlower(x, z) {
                const flower = new pc.Entity('Flower');

                const colors = [
                    new pc.Color(1, 0.4, 0.6),
                    new pc.Color(1, 0.8, 0.2),
                    new pc.Color(0.8, 0.4, 1),
                    new pc.Color(1, 0.5, 0.3),
                    new pc.Color(0.4, 0.8, 1)
                ];

                // Stem
                const stem = new pc.Entity('Stem');
                stem.addComponent('render', { type: 'cylinder' });
                stem.setLocalScale(0.05, 0.3, 0.05);
                stem.setLocalPosition(0, 0.15, 0);

                const stemMat = new pc.StandardMaterial();
                stemMat.diffuse = new pc.Color(0.2, 0.5, 0.2);
                stemMat.update();
                stem.render.meshInstances[0].material = stemMat;
                flower.addChild(stem);

                // Petals
                const petal = new pc.Entity('Petal');
                petal.addComponent('render', { type: 'sphere' });
                petal.setLocalScale(0.2, 0.15, 0.2);
                petal.setLocalPosition(0, 0.35, 0);

                const petalMat = new pc.StandardMaterial();
                petalMat.diffuse = colors[Math.floor(Math.random() * colors.length)];
                petalMat.update();
                petal.render.meshInstances[0].material = petalMat;
                flower.addChild(petal);

                flower.setPosition(x, 0, z);
                this.game.app.root.addChild(flower);
            }

            createTrainingDummy(x, z) {
                const dummy = new pc.Entity('TrainingDummy');

                const woodMat = new pc.StandardMaterial();
                woodMat.diffuse = new pc.Color(0.7, 0.55, 0.35);
                woodMat.update();

                // Post
                const post = new pc.Entity('Post');
                post.addComponent('render', { type: 'cylinder' });
                post.setLocalScale(0.15, 1.5, 0.15);
                post.setLocalPosition(0, 0.75, 0);
                post.render.meshInstances[0].material = woodMat;
                dummy.addChild(post);

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'cylinder' });
                body.setLocalScale(0.4, 1.2, 0.4);
                body.setLocalPosition(0, 2.1, 0);
                body.render.meshInstances[0].material = woodMat;
                dummy.addChild(body);

                // Head
                const head = new pc.Entity('Head');
                head.addComponent('render', { type: 'sphere' });
                head.setLocalScale(0.4, 0.4, 0.4);
                head.setLocalPosition(0, 2.9, 0);
                head.render.meshInstances[0].material = woodMat;
                dummy.addChild(head);

                // Arms
                const arms = new pc.Entity('Arms');
                arms.addComponent('render', { type: 'box' });
                arms.setLocalScale(1.5, 0.15, 0.15);
                arms.setLocalPosition(0, 2.3, 0);
                arms.render.meshInstances[0].material = woodMat;
                dummy.addChild(arms);

                dummy.setPosition(x, 0, z);
                dummy.tags.add('attackable', 'training');
                dummy.userData = {
                    type: 'training_dummy',
                    name: 'Training Dummy',
                    health: 100,
                    maxHealth: 100
                };

                dummy.addComponent('collision', {
                    type: 'cylinder',
                    radius: 0.5,
                    height: 3
                });
                dummy.collision.linearOffset = new pc.Vec3(0, 1.5, 0);

                this.game.app.root.addChild(dummy);
            }

            createCat(x, z) {
                const cat = new pc.Entity('Cat');

                const catMat = new pc.StandardMaterial();
                catMat.diffuse = new pc.Color(1, 0.6, 0.2);
                catMat.update();

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'sphere' });
                body.setLocalScale(0.6, 0.4, 0.8);
                body.setLocalPosition(0, 0.25, 0);
                body.render.meshInstances[0].material = catMat;
                cat.addChild(body);

                // Head
                const head = new pc.Entity('Head');
                head.addComponent('render', { type: 'sphere' });
                head.setLocalScale(0.4, 0.35, 0.35);
                head.setLocalPosition(0, 0.4, 0.35);
                head.render.meshInstances[0].material = catMat;
                cat.addChild(head);

                // Ears
                for (let i = -1; i <= 1; i += 2) {
                    const ear = new pc.Entity(`Ear${i}`);
                    ear.addComponent('render', { type: 'cone' });
                    ear.setLocalScale(0.1, 0.15, 0.1);
                    ear.setLocalPosition(i * 0.12, 0.6, 0.35);
                    ear.render.meshInstances[0].material = catMat;
                    cat.addChild(ear);
                }

                // Eyes
                const eyeMat = new pc.StandardMaterial();
                eyeMat.diffuse = new pc.Color(0.2, 0.8, 0.2);
                eyeMat.emissive = new pc.Color(0.1, 0.3, 0.1);
                eyeMat.update();

                for (let i = -1; i <= 1; i += 2) {
                    const eye = new pc.Entity(`Eye${i}`);
                    eye.addComponent('render', { type: 'sphere' });
                    eye.setLocalScale(0.06, 0.06, 0.06);
                    eye.setLocalPosition(i * 0.1, 0.45, 0.5);
                    eye.render.meshInstances[0].material = eyeMat;
                    cat.addChild(eye);
                }

                // Tail
                const tail = new pc.Entity('Tail');
                tail.addComponent('render', { type: 'cylinder' });
                tail.setLocalScale(0.08, 0.4, 0.08);
                tail.setLocalPosition(0, 0.35, -0.4);
                tail.setEulerAngles(30, 0, 0);
                tail.render.meshInstances[0].material = catMat;
                cat.addChild(tail);

                cat.setPosition(x, 0, z);
                cat.tags.add('interactable', 'easter_egg');
                cat.userData = {
                    type: 'cat',
                    name: 'Mochi',
                    petCount: 0,
                    isEasterEgg: true
                };

                this.game.app.root.addChild(cat);
                this.game.entities.interactables.push({
                    entity: cat,
                    type: 'cat',
                    name: 'Mochi the Cat'
                });

                // Animate cat
                this.animateCat(cat);
            }

            animateCat(cat) {
                let time = Math.random() * 100;
                const basePos = cat.getPosition().clone();
                let targetPos = basePos.clone();
                let moveTimer = 0;

                this.game.app.on('update', (dt) => {
                    time += dt;
                    moveTimer -= dt;

                    // Idle animation
                    const pos = cat.getPosition();
                    pos.y = 0.05 + Math.sin(time * 3) * 0.02;
                    cat.setPosition(pos);

                    // Occasional wandering
                    if (moveTimer <= 0 && Math.random() < 0.01) {
                        targetPos = new pc.Vec3(
                            basePos.x + (Math.random() - 0.5) * 6,
                            0,
                            basePos.z + (Math.random() - 0.5) * 6
                        );
                        moveTimer = 3 + Math.random() * 2;
                    }

                    // Move towards target
                    const currentPos = cat.getPosition();
                    const diff = new pc.Vec3().sub2(targetPos, currentPos);
                    diff.y = 0;
                    
                    if (diff.length() > 0.1) {
                        diff.normalize().mulScalar(dt * 1.5);
                        currentPos.add(diff);
                        cat.setPosition(currentPos);
                        cat.lookAt(targetPos);
                    }
                });
            }

            createForest() {
                const forestCenter = new pc.Vec3(-80, 0, 100);

                // Dense trees
                for (let i = 0; i < 80; i++) {
                    const x = forestCenter.x + (Math.random() - 0.5) * 150;
                    const z = forestCenter.z + (Math.random() - 0.5) * 150;
                    
                    if (Math.random() > 0.4) {
                        this.createPineTree(x, z);
                    } else {
                        this.createOakTree(x, z);
                    }
                }

                // Mystical elements
                this.createWillOWisps(forestCenter);
                this.createAncientRuins(forestCenter.x + 40, forestCenter.z - 20);
                this.createMysteriousStone(forestCenter.x - 25, forestCenter.z + 15);
            }

            createPineTree(x, z) {
                const tree = new pc.Entity('PineTree');

                // Trunk
                const trunk = new pc.Entity('Trunk');
                trunk.addComponent('render', { type: 'cylinder' });
                const height = 6 + Math.random() * 4;
                trunk.setLocalScale(0.4, height, 0.4);
                trunk.setLocalPosition(0, height / 2, 0);

                const trunkMat = new pc.StandardMaterial();
                trunkMat.diffuse = new pc.Color(0.3, 0.2, 0.1);
                trunkMat.update();
                trunk.render.meshInstances[0].material = trunkMat;
                tree.addChild(trunk);

                // Foliage layers
                const foliageMat = new pc.StandardMaterial();
                foliageMat.diffuse = new pc.Color(0.1, 0.4, 0.15);
                foliageMat.update();

                for (let i = 0; i < 4; i++) {
                    const foliage = new pc.Entity(`Foliage${i}`);
                    foliage.addComponent('render', { type: 'cone' });
                    const size = 3 - i * 0.5;
                    foliage.setLocalScale(size, 2.5, size);
                    foliage.setLocalPosition(0, height * 0.5 + i * 1.8, 0);
                    foliage.render.meshInstances[0].material = foliageMat;
                    tree.addChild(foliage);
                }

                tree.setPosition(x, 0, z);
                tree.setLocalScale(0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4);

                tree.addComponent('collision', {
                    type: 'cylinder',
                    radius: 0.5,
                    height: height
                });
                tree.collision.linearOffset = new pc.Vec3(0, height / 2, 0);
                tree.addComponent('rigidbody', { type: 'static' });

                this.game.app.root.addChild(tree);
            }

            createOakTree(x, z) {
                const tree = new pc.Entity('OakTree');

                // Trunk
                const trunk = new pc.Entity('Trunk');
                trunk.addComponent('render', { type: 'cylinder' });
                trunk.setLocalScale(0.6, 5, 0.6);
                trunk.setLocalPosition(0, 2.5, 0);

                const trunkMat = new pc.StandardMaterial();
                trunkMat.diffuse = new pc.Color(0.35, 0.25, 0.15);
                trunkMat.update();
                trunk.render.meshInstances[0].material = trunkMat;
                tree.addChild(trunk);

                // Foliage (multiple spheres)
                const foliageMat = new pc.StandardMaterial();
                foliageMat.diffuse = new pc.Color(0.15, 0.45, 0.15);
                foliageMat.update();

                for (let i = 0; i < 4; i++) {
                    const foliage = new pc.Entity(`Foliage${i}`);
                    foliage.addComponent('render', { type: 'sphere' });
                    const size = 2 + Math.random();
                    foliage.setLocalScale(size, size * 0.8, size);
                    foliage.setLocalPosition(
                        (Math.random() - 0.5) * 2,
                        5 + Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    foliage.render.meshInstances[0].material = foliageMat;
                    tree.addChild(foliage);
                }

                tree.setPosition(x, 0, z);

                tree.addComponent('collision', {
                    type: 'cylinder',
                    radius: 0.7,
                    height: 5
                });
                tree.collision.linearOffset = new pc.Vec3(0, 2.5, 0);
                tree.addComponent('rigidbody', { type: 'static' });

                this.game.app.root.addChild(tree);
            }

            createWillOWisps(center) {
                for (let i = 0; i < 8; i++) {
                    const wisp = new pc.Entity(`WillOWisp${i}`);

                    const core = new pc.Entity('Core');
                    core.addComponent('render', { type: 'sphere' });
                    core.setLocalScale(0.3, 0.3, 0.3);

                    const wispMat = new pc.StandardMaterial();
                    wispMat.diffuse = new pc.Color(0.2, 1, 0.6);
                    wispMat.emissive = new pc.Color(0.1, 0.5, 0.3);
                    wispMat.opacity = 0.8;
                    wispMat.blendType = pc.BLEND_ADDITIVE;
                    wispMat.update();
                    core.render.meshInstances[0].material = wispMat;
                    wisp.addChild(core);

                    // Light
                    const light = new pc.Entity('Light');
                    light.addComponent('light', {
                        type: 'point',
                        color: new pc.Color(0.2, 1, 0.6),
                        intensity: 0.4,
                        range: 10
                    });
                    wisp.addChild(light);

                    const startPos = new pc.Vec3(
                        center.x + (Math.random() - 0.5) * 80,
                        2 + Math.random() * 4,
                        center.z + (Math.random() - 0.5) * 80
                    );
                    wisp.setPosition(startPos);

                    this.game.app.root.addChild(wisp);

                    // Animate
                    const offset = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 0.5;
                    const baseY = startPos.y;

                    this.game.app.on('update', (dt) => {
                        const pos = wisp.getPosition();
                        pos.y = baseY + Math.sin(this.game.gameTime * speed + offset) * 1.5;
                        pos.x += Math.sin(this.game.gameTime * 0.3 + offset) * dt * 0.5;
                        pos.z += Math.cos(this.game.gameTime * 0.3 + offset) * dt * 0.5;
                        wisp.setPosition(pos);
                    });
                }
            }

            createAncientRuins(x, z) {
                const ruins = new pc.Entity('AncientRuins');

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.5, 0.5, 0.5);
                stoneMat.update();

                // Broken pillars
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 8;
                    const height = 2 + Math.random() * 4;

                    const pillar = new pc.Entity(`Pillar${i}`);
                    pillar.addComponent('render', { type: 'cylinder' });
                    pillar.setLocalScale(1, height, 1);
                    pillar.setLocalPosition(
                        Math.cos(angle) * radius,
                        height / 2,
                        Math.sin(angle) * radius
                    );
                    pillar.setEulerAngles(
                        (Math.random() - 0.5) * 10,
                        0,
                        (Math.random() - 0.5) * 10
                    );
                    pillar.render.meshInstances[0].material = stoneMat;
                    
                    pillar.addComponent('collision', {
                        type: 'cylinder',
                        radius: 0.5,
                        height: height
                    });
                    pillar.addComponent('rigidbody', { type: 'static' });
                    
                    ruins.addChild(pillar);
                }

                // Center altar
                const altar = new pc.Entity('Altar');
                altar.addComponent('render', { type: 'box' });
                altar.setLocalScale(4, 1, 4);
                altar.setLocalPosition(0, 0.5, 0);
                altar.render.meshInstances[0].material = stoneMat;
                ruins.addChild(altar);

                // Artifact
                const artifact = new pc.Entity('Artifact');
                artifact.addComponent('render', { type: 'box' });
                artifact.setLocalScale(0.6, 0.6, 0.6);
                artifact.setLocalPosition(0, 1.5, 0);
                artifact.setEulerAngles(45, 45, 0);

                const artifactMat = new pc.StandardMaterial();
                artifactMat.diffuse = new pc.Color(0.8, 0.2, 1);
                artifactMat.emissive = new pc.Color(0.4, 0.1, 0.5);
                artifactMat.update();
                artifact.render.meshInstances[0].material = artifactMat;
                ruins.addChild(artifact);

                // Artifact light
                const light = new pc.Entity('ArtifactLight');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0.8, 0.2, 1),
                    intensity: 1,
                    range: 12
                });
                light.setLocalPosition(0, 1.5, 0);
                ruins.addChild(light);

                ruins.setPosition(x, 0, z);
                ruins.tags.add('interactable', 'boss_trigger');
                ruins.userData = {
                    type: 'boss_trigger',
                    name: 'Ancient Altar',
                    bossId: 'forest_guardian'
                };

                this.game.app.root.addChild(ruins);
                this.game.entities.interactables.push({
                    entity: ruins,
                    type: 'boss_trigger',
                    name: 'Ancient Altar'
                });

                // Animate artifact
                this.game.app.on('update', (dt) => {
                    artifact.rotate(0, 60 * dt, 0);
                    const pos = artifact.getLocalPosition();
                    pos.y = 1.5 + Math.sin(this.game.gameTime * 2) * 0.3;
                    artifact.setLocalPosition(pos);
                });
            }

            createMysteriousStone(x, z) {
                const stone = new pc.Entity('MysteriousStone');

                // Main stone
                const mainStone = new pc.Entity('MainStone');
                mainStone.addComponent('render', { type: 'box' });
                mainStone.setLocalScale(3, 4, 2);
                mainStone.setLocalPosition(0, 2, 0);
                mainStone.setEulerAngles(5, 15, -3);

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.3, 0.3, 0.4);
                stoneMat.update();
                mainStone.render.meshInstances[0].material = stoneMat;
                stone.addChild(mainStone);

                // Glowing runes
                const runeMat = new pc.StandardMaterial();
                runeMat.diffuse = new pc.Color(0, 1, 1);
                runeMat.emissive = new pc.Color(0, 0.5, 0.5);
                runeMat.update();

                for (let i = 0; i < 5; i++) {
                    const rune = new pc.Entity(`Rune${i}`);
                    rune.addComponent('render', { type: 'plane' });
                    rune.setLocalScale(0.4, 0.4, 0.4);
                    rune.setLocalPosition(
                        (Math.random() - 0.5) * 2,
                        1 + Math.random() * 2.5,
                        1.1
                    );
                    rune.render.meshInstances[0].material = runeMat;
                    stone.addChild(rune);
                }

                // Ambient light
                const light = new pc.Entity('StoneLight');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0, 1, 1),
                    intensity: 0.6,
                    range: 15
                });
                light.setLocalPosition(0, 2, 0);
                stone.addChild(light);

                stone.setPosition(x, 0, z);
                stone.tags.add('interactable', 'easter_egg');
                stone.userData = {
                    type: 'mysterious_stone',
                    name: 'Ancient Runestone',
                    isEasterEgg: true,
                    easterEggId: 'ancient_runes'
                };

                this.game.app.root.addChild(stone);
                this.game.entities.interactables.push({
                    entity: stone,
                    type: 'mysterious_stone',
                    name: 'Ancient Runestone'
                });
            }

            createMountains() {
                const mountainCenter = new pc.Vec3(-150, 0, -150);

                // Mountain peaks
                for (let i = 0; i < 5; i++) {
                    const x = mountainCenter.x + (Math.random() - 0.5) * 150;
                    const z = mountainCenter.z + (Math.random() - 0.5) * 150;
                    const height = 30 + Math.random() * 40;
                    this.createMountainPeak(x, z, height);
                }

                // Floating islands
                this.createFloatingIsland(-180, 35, -130);
                this.createFloatingIsland(-120, 45, -180);

                // Dragon's nest
                this.createDragonNest(-150, 50, -150);
            }

            createMountainPeak(x, z, height) {
                const mountain = new pc.Entity('Mountain');

                // Main peak
                const peak = new pc.Entity('Peak');
                peak.addComponent('render', { type: 'cone' });
                peak.setLocalScale(height * 0.8, height, height * 0.8);
                peak.setLocalPosition(0, height / 2, 0);

                const rockMat = new pc.StandardMaterial();
                rockMat.diffuse = new pc.Color(0.4, 0.38, 0.35);
                rockMat.update();
                peak.render.meshInstances[0].material = rockMat;
                mountain.addChild(peak);

                // Snow cap
                const snow = new pc.Entity('Snow');
                snow.addComponent('render', { type: 'cone' });
                snow.setLocalScale(height * 0.3, height * 0.25, height * 0.3);
                snow.setLocalPosition(0, height - height * 0.125, 0);

                const snowMat = new pc.StandardMaterial();
                snowMat.diffuse = new pc.Color(0.95, 0.97, 1);
                snowMat.update();
                snow.render.meshInstances[0].material = snowMat;
                mountain.addChild(snow);

                mountain.setPosition(x, 0, z);

                mountain.addComponent('collision', {
                    type: 'cone',
                    height: height,
                    radius: height * 0.4
                });
                mountain.collision.linearOffset = new pc.Vec3(0, height / 2, 0);
                mountain.addComponent('rigidbody', { type: 'static' });

                this.game.app.root.addChild(mountain);
            }

            createFloatingIsland(x, y, z) {
                const island = new pc.Entity('FloatingIsland');

                // Bottom rock
                const bottom = new pc.Entity('Bottom');
                bottom.addComponent('render', { type: 'cone' });
                bottom.setLocalScale(12, 10, 12);
                bottom.setLocalPosition(0, -3, 0);
                bottom.setEulerAngles(180, 0, 0);

                const rockMat = new pc.StandardMaterial();
                rockMat.diffuse = new pc.Color(0.4, 0.3, 0.25);
                rockMat.update();
                bottom.render.meshInstances[0].material = rockMat;
                island.addChild(bottom);

                // Top surface
                const top = new pc.Entity('Top');
                top.addComponent('render', { type: 'cylinder' });
                top.setLocalScale(12, 2, 12);
                top.setLocalPosition(0, 1, 0);

                const grassMat = new pc.StandardMaterial();
                grassMat.diffuse = new pc.Color(0.25, 0.5, 0.25);
                grassMat.update();
                top.render.meshInstances[0].material = grassMat;
                island.addChild(top);

                // Small trees
                for (let i = 0; i < 4; i++) {
                    const tree = new pc.Entity(`SmallTree${i}`);
                    
                    const trunk = new pc.Entity('Trunk');
                    trunk.addComponent('render', { type: 'cylinder' });
                    trunk.setLocalScale(0.2, 1.5, 0.2);
                    trunk.setLocalPosition(0, 0.75, 0);
                    const trunkMat = new pc.StandardMaterial();
                    trunkMat.diffuse = new pc.Color(0.4, 0.25, 0.15);
                    trunkMat.update();
                    trunk.render.meshInstances[0].material = trunkMat;
                    tree.addChild(trunk);

                    const foliage = new pc.Entity('Foliage');
                    foliage.addComponent('render', { type: 'cone' });
                    foliage.setLocalScale(1.2, 2, 1.2);
                    foliage.setLocalPosition(0, 2, 0);
                    const foliageMat = new pc.StandardMaterial();
                    foliageMat.diffuse = new pc.Color(0.15, 0.4, 0.15);
                    foliageMat.update();
                    foliage.render.meshInstances[0].material = foliageMat;
                    tree.addChild(foliage);

                    const angle = (i / 4) * Math.PI * 2;
                    tree.setLocalPosition(
                        Math.cos(angle) * 4,
                        2,
                        Math.sin(angle) * 4
                    );
                    island.addChild(tree);
                }

                // Treasure chest
                const chest = this.createChest();
                chest.setLocalPosition(0, 2.5, 0);
                island.addChild(chest);

                island.setPosition(x, y, z);

                // Floating animation
                const baseY = y;
                const offset = Math.random() * Math.PI * 2;
                
                this.game.app.on('update', (dt) => {
                    const pos = island.getPosition();
                    pos.y = baseY + Math.sin(this.game.gameTime * 0.5 + offset) * 2;
                    island.setPosition(pos);
                    island.rotate(0, dt * 2, 0);
                });

                this.game.app.root.addChild(island);
            }

            createChest() {
                const chest = new pc.Entity('Chest');

                const woodMat = new pc.StandardMaterial();
                woodMat.diffuse = new pc.Color(0.5, 0.3, 0.15);
                woodMat.update();

                const metalMat = new pc.StandardMaterial();
                metalMat.diffuse = new pc.Color(0.7, 0.65, 0.2);
                metalMat.update();

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'box' });
                body.setLocalScale(1.2, 0.8, 0.8);
                body.setLocalPosition(0, 0.4, 0);
                body.render.meshInstances[0].material = woodMat;
                chest.addChild(body);

                // Lid
                const lid = new pc.Entity('Lid');
                lid.addComponent('render', { type: 'box' });
                lid.setLocalScale(1.2, 0.25, 0.8);
                lid.setLocalPosition(0, 0.925, 0);
                lid.render.meshInstances[0].material = woodMat;
                chest.addChild(lid);

                // Metal bands
                for (let i = -1; i <= 1; i += 2) {
                    const band = new pc.Entity(`Band${i}`);
                    band.addComponent('render', { type: 'box' });
                    band.setLocalScale(0.08, 1.05, 0.85);
                    band.setLocalPosition(i * 0.4, 0.525, 0);
                    band.render.meshInstances[0].material = metalMat;
                    chest.addChild(band);
                }

                // Lock
                const lock = new pc.Entity('Lock');
                lock.addComponent('render', { type: 'box' });
                lock.setLocalScale(0.2, 0.25, 0.1);
                lock.setLocalPosition(0, 0.65, 0.45);
                lock.render.meshInstances[0].material = metalMat;
                chest.addChild(lock);

                chest.tags.add('interactable', 'chest');
                chest.userData = {
                    type: 'chest',
                    name: 'Treasure Chest',
                    opened: false,
                    rarity: 'rare'
                };

                this.game.entities.interactables.push({
                    entity: chest,
                    type: 'chest',
                    name: 'Treasure Chest'
                });

                return chest;
            }

            createDragonNest(x, y, z) {
                const nest = new pc.Entity('DragonNest');

                // Platform
                const platform = new pc.Entity('Platform');
                platform.addComponent('render', { type: 'cylinder' });
                platform.setLocalScale(25, 4, 25);
                platform.setLocalPosition(0, 2, 0);

                const rockMat = new pc.StandardMaterial();
                rockMat.diffuse = new pc.Color(0.35, 0.32, 0.3);
                rockMat.update();
                platform.render.meshInstances[0].material = rockMat;
                nest.addChild(platform);

                // Nest ring
                const ring = new pc.Entity('NestRing');
                ring.addComponent('render', { type: 'torus' });
                ring.setLocalScale(15, 3, 15);
                ring.setLocalPosition(0, 5, 0);

                const nestMat = new pc.StandardMaterial();
                nestMat.diffuse = new pc.Color(0.4, 0.28, 0.18);
                nestMat.update();
                ring.render.meshInstances[0].material = nestMat;
                nest.addChild(ring);

                // Dragon eggs
                const eggColors = [
                    new pc.Color(0.8, 0.2, 0.2),
                    new pc.Color(0.2, 0.8, 0.2),
                    new pc.Color(0.2, 0.2, 0.8)
                ];

                eggColors.forEach((color, i) => {
                    const egg = new pc.Entity(`Egg${i}`);
                    egg.addComponent('render', { type: 'sphere' });
                    egg.setLocalScale(1.5, 2, 1.5);
                    
                    const angle = (i / 3) * Math.PI * 2;
                    egg.setLocalPosition(
                        Math.cos(angle) * 4,
                        5.5,
                        Math.sin(angle) * 4
                    );

                    const eggMat = new pc.StandardMaterial();
                    eggMat.diffuse = color;
                    eggMat.update();
                    egg.render.meshInstances[0].material = eggMat;
                    nest.addChild(egg);
                });

                // Treasure pile
                for (let i = 0; i < 25; i++) {
                    const coin = new pc.Entity(`Coin${i}`);
                    coin.addComponent('render', { type: 'cylinder' });
                    coin.setLocalScale(0.4, 0.1, 0.4);
                    coin.setLocalPosition(
                        (Math.random() - 0.5) * 12,
                        4.2 + Math.random() * 0.3,
                        (Math.random() - 0.5) * 12
                    );
                    coin.setEulerAngles(
                        Math.random() * 30,
                        Math.random() * 360,
                        Math.random() * 30
                    );

                    const coinMat = new pc.StandardMaterial();
                    coinMat.diffuse = new pc.Color(1, 0.85, 0.3);
                    coinMat.update();
                    coin.render.meshInstances[0].material = coinMat;
                    nest.addChild(coin);
                }

                // Ominous light
                const light = new pc.Entity('NestLight');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(1, 0.3, 0.1),
                    intensity: 2,
                    range: 40
                });
                light.setLocalPosition(0, 8, 0);
                nest.addChild(light);

                nest.setPosition(x, y, z);
                nest.tags.add('interactable', 'boss_trigger');
                nest.userData = {
                    type: 'boss_trigger',
                    name: 'Dragon\'s Nest',
                    bossId: 'ancient_dragon'
                };

                this.game.app.root.addChild(nest);
                this.game.entities.interactables.push({
                    entity: nest,
                    type: 'boss_trigger',
                    name: 'Dragon\'s Nest'
                });
            }

            createCaverns() {
                const cavernEntrance = new pc.Vec3(120, 0, -60);

                // Cave entrance
                this.createCaveEntrance(cavernEntrance.x, cavernEntrance.z);
            }

            createCaveEntrance(x, z) {
                const entrance = new pc.Entity('CaveEntrance');

                const rockMat = new pc.StandardMaterial();
                rockMat.diffuse = new pc.Color(0.35, 0.32, 0.3);
                rockMat.update();

                // Arch rocks
                const leftRock = new pc.Entity('LeftRock');
                leftRock.addComponent('render', { type: 'sphere' });
                leftRock.setLocalScale(5, 8, 4);
                leftRock.setLocalPosition(-4, 4, 0);
                leftRock.render.meshInstances[0].material = rockMat;
                entrance.addChild(leftRock);

                const rightRock = new pc.Entity('RightRock');
                rightRock.addComponent('render', { type: 'sphere' });
                rightRock.setLocalScale(5, 8, 4);
                rightRock.setLocalPosition(4, 4, 0);
                rightRock.render.meshInstances[0].material = rockMat;
                entrance.addChild(rightRock);

                const topRock = new pc.Entity('TopRock');
                topRock.addComponent('render', { type: 'sphere' });
                topRock.setLocalScale(10, 4, 4);
                topRock.setLocalPosition(0, 7, 0);
                topRock.render.meshInstances[0].material = rockMat;
                entrance.addChild(topRock);

                // Dark interior
                const dark = new pc.Entity('Dark');
                dark.addComponent('render', { type: 'plane' });
                dark.setLocalScale(6, 6, 1);
                dark.setLocalPosition(0, 3.5, -0.5);
                dark.setEulerAngles(0, 0, 0);

                const darkMat = new pc.StandardMaterial();
                darkMat.diffuse = new pc.Color(0.02, 0.02, 0.03);
                darkMat.update();
                dark.render.meshInstances[0].material = darkMat;
                entrance.addChild(dark);

                // Crystal glow
                const light = new pc.Entity('CavernLight');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0, 0.8, 1),
                    intensity: 0.5,
                    range: 15
                });
                light.setLocalPosition(0, 3, -2);
                entrance.addChild(light);

                entrance.setPosition(x, 0, z);
                entrance.tags.add('interactable', 'door');
                entrance.userData = {
                    type: 'door',
                    name: 'Crystal Caverns',
                    destination: 'crystal_caverns'
                };

                this.game.app.root.addChild(entrance);
                this.game.entities.interactables.push({
                    entity: entrance,
                    type: 'door',
                    name: 'Crystal Caverns Entrance'
                });
            }

            spawnNPCs() {
                const npcData = [
                    {
                        id: 'elder_sakura',
                        name: 'Elder Sakura',
                        title: 'Village Elder',
                        icon: 'üë¥',
                        position: [12, 0, 22],
                        color: 0x8b0000
                    },
                    {
                        id: 'kaito_blacksmith',
                        name: 'Kaito',
                        title: 'Master Blacksmith',
                        icon: 'üî®',
                        position: [-20, 0, 17],
                        color: 0x696969
                    },
                    {
                        id: 'mei_innkeeper',
                        name: 'Mei',
                        title: 'Innkeeper',
                        icon: 'üè®',
                        position: [-12, 0, -3],
                        color: 0xff69b4
                    },
                    {
                        id: 'tanaka_merchant',
                        name: 'Tanaka',
                        title: 'Merchant',
                        icon: 'üõí',
                        position: [15, 0, 0],
                        color: 0x228b22
                    },
                    {
                        id: 'yuki_alchemist',
                        name: 'Yuki',
                        title: 'Potion Master',
                        icon: 'üßô‚Äç‚ôÄÔ∏è',
                        position: [28, 0, 13],
                        color: 0x9932cc
                    },
                    {
                        id: 'master_hiroshi',
                        name: 'Master Hiroshi',
                        title: 'Dojo Master',
                        icon: 'ü•ã',
                        position: [-5, 0, 32],
                        color: 0xffffff
                    },
                    {
                        id: 'mysterious_stranger',
                        name: '???',
                        title: 'Mysterious Stranger',
                        icon: 'üé≠',
                        position: [0, 0, -45],
                        color: 0x1a1a2e
                    }
                ];

                npcData.forEach(data => {
                    this.createNPC(data);
                });
            }

            createNPC(data) {
                const npc = new pc.Entity(data.name);

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'capsule' });
                body.setLocalScale(0.8, 1.6, 0.8);
                body.setLocalPosition(0, 1.2, 0);

                const bodyMat = new pc.StandardMaterial();
                bodyMat.diffuse = new pc.Color(
                    ((data.color >> 16) & 255) / 255,
                    ((data.color >> 8) & 255) / 255,
                    (data.color & 255) / 255
                );
                bodyMat.update();
                body.render.meshInstances[0].material = bodyMat;
                npc.addChild(body);

                // Head
                const head = new pc.Entity('Head');
                head.addComponent('render', { type: 'sphere' });
                head.setLocalScale(0.5, 0.5, 0.5);
                head.setLocalPosition(0, 2.3, 0);

                const skinMat = new pc.StandardMaterial();
                skinMat.diffuse = new pc.Color(1, 0.9, 0.8);
                skinMat.update();
                head.render.meshInstances[0].material = skinMat;
                npc.addChild(head);

                // Eyes
                const eyeMat = new pc.StandardMaterial();
                eyeMat.diffuse = new pc.Color(0.1, 0.1, 0.1);
                eyeMat.update();

                for (let i = -1; i <= 1; i += 2) {
                    const eye = new pc.Entity(`Eye${i}`);
                    eye.addComponent('render', { type: 'sphere' });
                    eye.setLocalScale(0.08, 0.08, 0.08);
                    eye.setLocalPosition(i * 0.12, 2.35, 0.2);
                    eye.render.meshInstances[0].material = eyeMat;
                    npc.addChild(eye);
                }

                // Quest indicator
                if (['elder_sakura', 'kaito_blacksmith', 'yuki_alchemist', 'master_hiroshi'].includes(data.id)) {
                    const indicator = new pc.Entity('QuestIndicator');
                    indicator.addComponent('render', { type: 'cone' });
                    indicator.setLocalScale(0.3, 0.4, 0.3);
                    indicator.setLocalPosition(0, 3.2, 0);
                    indicator.setEulerAngles(180, 0, 0);

                    const indicatorMat = new pc.StandardMaterial();
                    indicatorMat.diffuse = new pc.Color(1, 0.85, 0);
                    indicatorMat.emissive = new pc.Color(0.5, 0.4, 0);
                    indicatorMat.update();
                    indicator.render.meshInstances[0].material = indicatorMat;
                    npc.addChild(indicator);

                    // Animate
                    this.game.app.on('update', (dt) => {
                        indicator.rotate(0, 120 * dt, 0);
                        const pos = indicator.getLocalPosition();
                        pos.y = 3.2 + Math.sin(this.game.gameTime * 3) * 0.15;
                        indicator.setLocalPosition(pos);
                    });
                }

                npc.setPosition(data.position[0], data.position[1], data.position[2]);
                npc.tags.add('npc', 'interactable');
                npc.userData = {
                    type: 'npc',
                    id: data.id,
                    name: data.name,
                    title: data.title,
                    icon: data.icon
                };

                npc.addComponent('collision', {
                    type: 'capsule',
                    radius: 0.4,
                    height: 2
                });
                npc.collision.linearOffset = new pc.Vec3(0, 1, 0);

                this.game.app.root.addChild(npc);
                this.game.entities.npcs.push({
                    entity: npc,
                    data: data
                });
            }

            spawnEnemies() {
                const enemySpawns = [
                    // Forest area
                    { type: 'slime', x: -60, z: 80, level: 1 },
                    { type: 'slime', x: -80, z: 100, level: 1 },
                    { type: 'slime', x: -70, z: 120, level: 2 },
                    { type: 'wolf', x: -100, z: 90, level: 3 },
                    { type: 'wolf', x: -90, z: 110, level: 3 },
                    { type: 'spirit', x: -50, z: 130, level: 5 },
                    { type: 'spirit', x: -110, z: 85, level: 5 },
                    // Near caverns
                    { type: 'golem', x: 100, z: -50, level: 7 },
                    { type: 'golem', x: 130, z: -70, level: 8 },
                    // Mountain area  
                    { type: 'harpy', x: -130, z: -120, level: 10 },
                    { type: 'harpy', x: -170, z: -140, level: 10 },
                    { type: 'demon', x: -140, z: -180, level: 15 }
                ];

                enemySpawns.forEach(spawn => {
                    this.createEnemy(spawn);
                });
            }

            createEnemy(spawn) {
                const enemyTypes = {
                    slime: {
                        name: 'Forest Slime',
                        health: 30,
                        damage: 5,
                        exp: 15,
                        gold: 5,
                        color: 0x44ff44,
                        scale: 0.8
                    },
                    wolf: {
                        name: 'Shadow Wolf',
                        health: 60,
                        damage: 12,
                        exp: 35,
                        gold: 15,
                        color: 0x444444,
                        scale: 1
                    },
                    spirit: {
                        name: 'Lost Spirit',
                        health: 45,
                        damage: 18,
                        exp: 50,
                        gold: 25,
                        color: 0x8888ff,
                        scale: 1.2
                    },
                    golem: {
                        name: 'Crystal Golem',
                        health: 150,
                        damage: 25,
                        exp: 100,
                        gold: 50,
                        color: 0x00ffff,
                        scale: 1.8
                    },
                    harpy: {
                        name: 'Mountain Harpy',
                        health: 80,
                        damage: 30,
                        exp: 120,
                        gold: 60,
                        color: 0xff88ff,
                        scale: 1.3
                    },
                    demon: {
                        name: 'Lesser Demon',
                        health: 200,
                        damage: 45,
                        exp: 200,
                        gold: 100,
                        color: 0xff0000,
                        scale: 1.5
                    }
                };

                const typeData = enemyTypes[spawn.type];
                const enemy = new pc.Entity(typeData.name);

                // Different mesh based on type
                const body = new pc.Entity('Body');
                
                if (spawn.type === 'slime') {
                    body.addComponent('render', { type: 'sphere' });
                    body.setLocalScale(typeData.scale, typeData.scale * 0.7, typeData.scale);
                    body.setLocalPosition(0, typeData.scale * 0.35, 0);
                } else if (spawn.type === 'wolf') {
                    body.addComponent('render', { type: 'box' });
                    body.setLocalScale(1.2, 0.6, 0.5);
                    body.setLocalPosition(0, 0.6, 0);
                } else if (spawn.type === 'spirit') {
                    body.addComponent('render', { type: 'cone' });
                    body.setLocalScale(0.8, 2, 0.8);
                    body.setLocalPosition(0, 1.5, 0);
                    body.setEulerAngles(180, 0, 0);
                } else if (spawn.type === 'golem') {
                    body.addComponent('render', { type: 'box' });
                    body.setLocalScale(1.5, 2.5, 1);
                    body.setLocalPosition(0, 1.25, 0);
                } else if (spawn.type === 'harpy') {
                    body.addComponent('render', { type: 'capsule' });
                    body.setLocalScale(0.6, 1.5, 0.6);
                    body.setLocalPosition(0, 2.5, 0);
                } else {
                    body.addComponent('render', { type: 'capsule' });
                    body.setLocalScale(0.8, 2, 0.8);
                    body.setLocalPosition(0, 1.5, 0);
                }

                const bodyMat = new pc.StandardMaterial();
                bodyMat.diffuse = new pc.Color(
                    ((typeData.color >> 16) & 255) / 255,
                    ((typeData.color >> 8) & 255) / 255,
                    (typeData.color & 255) / 255
                );
                if (spawn.type === 'spirit' || spawn.type === 'demon') {
                    bodyMat.emissive = bodyMat.diffuse.clone().mulScalar(0.3);
                    bodyMat.opacity = spawn.type === 'spirit' ? 0.7 : 1;
                    bodyMat.blendType = spawn.type === 'spirit' ? pc.BLEND_NORMAL : pc.BLEND_NONE;
                }
                bodyMat.update();
                body.render.meshInstances[0].material = bodyMat;
                enemy.addChild(body);

                // Eyes
                const eyeMat = new pc.StandardMaterial();
                eyeMat.diffuse = new pc.Color(1, 0, 0);
                eyeMat.emissive = new pc.Color(0.5, 0, 0);
                eyeMat.update();

                if (spawn.type !== 'slime') {
                    for (let i = -1; i <= 1; i += 2) {
                        const eye = new pc.Entity(`Eye${i}`);
                        eye.addComponent('render', { type: 'sphere' });
                        eye.setLocalScale(0.12, 0.12, 0.12);
                        
                        let eyeY = spawn.type === 'harpy' ? 2.7 : (spawn.type === 'golem' ? 2.2 : 1.8);
                        eye.setLocalPosition(i * 0.2, eyeY, 0.3);
                        eye.render.meshInstances[0].material = eyeMat;
                        enemy.addChild(eye);
                    }
                }

                enemy.setPosition(spawn.x, 0, spawn.z);
                enemy.tags.add('enemy', 'attackable');
                
                const levelMultiplier = 1 + (spawn.level - 1) * 0.15;
                enemy.userData = {
                    type: 'enemy',
                    enemyType: spawn.type,
                    name: typeData.name,
                    level: spawn.level,
                    health: Math.floor(typeData.health * levelMultiplier),
                    maxHealth: Math.floor(typeData.health * levelMultiplier),
                    damage: Math.floor(typeData.damage * levelMultiplier),
                    exp: Math.floor(typeData.exp * levelMultiplier),
                    gold: Math.floor(typeData.gold * levelMultiplier),
                    isDead: false,
                    originalPosition: new pc.Vec3(spawn.x, 0, spawn.z),
                    state: 'idle',
                    aggroRange: CONFIG.AGGRO_RANGE,
                    attackCooldown: 0
                };

                enemy.addComponent('collision', {
                    type: 'sphere',
                    radius: typeData.scale * 0.5
                });

                this.game.app.root.addChild(enemy);
                this.game.entities.enemies.push({
                    entity: enemy,
                    data: enemy.userData
                });

                // Enemy AI
                this.startEnemyAI(enemy);
            }

            startEnemyAI(enemy) {
                const data = enemy.userData;
                let attackTimer = 0;

                this.game.app.on('update', (dt) => {
                    if (data.isDead || !this.game.player) return;

                    const enemyPos = enemy.getPosition();
                    const playerPos = this.game.player.getPosition();
                    const distance = new pc.Vec3().sub2(playerPos, enemyPos).length();

                    attackTimer -= dt;

                    switch (data.state) {
                        case 'idle':
                            if (distance < data.aggroRange) {
                                data.state = 'chase';
                            } else if (Math.random() < 0.005) {
                                // Wander
                                data.wanderTarget = new pc.Vec3(
                                    data.originalPosition.x + (Math.random() - 0.5) * 8,
                                    0,
                                    data.originalPosition.z + (Math.random() - 0.5) * 8
                                );
                                data.state = 'wander';
                            }
                            break;

                        case 'wander':
                            if (data.wanderTarget) {
                                const toTarget = new pc.Vec3().sub2(data.wanderTarget, enemyPos);
                                toTarget.y = 0;
                                
                                if (toTarget.length() > 0.5) {
                                    toTarget.normalize().mulScalar(dt * 2);
                                    enemyPos.add(toTarget);
                                    enemy.setPosition(enemyPos);
                                    enemy.lookAt(data.wanderTarget);
                                } else {
                                    data.state = 'idle';
                                }
                            }

                            if (distance < data.aggroRange) {
                                                                data.state = 'chase';
                            }
                            break;

                        case 'chase':
                            if (distance < 2.5) {
                                data.state = 'attack';
                            } else if (distance > data.aggroRange * 2) {
                                data.state = 'return';
                            } else {
                                const toPlayer = new pc.Vec3().sub2(playerPos, enemyPos);
                                toPlayer.y = 0;
                                toPlayer.normalize().mulScalar(dt * 4);
                                enemyPos.add(toPlayer);
                                enemy.setPosition(enemyPos);
                                enemy.lookAt(new pc.Vec3(playerPos.x, enemyPos.y, playerPos.z));
                            }
                            break;

                        case 'attack':
                            if (distance > 3.5) {
                                data.state = 'chase';
                            } else if (attackTimer <= 0) {
                                // Attack player
                                this.game.systems.player.takeDamage(data.damage);
                                attackTimer = 1.5; // Attack cooldown
                                
                                // Attack animation
                                const originalScale = enemy.getLocalScale().clone();
                                enemy.setLocalScale(
                                    originalScale.x * 1.2,
                                    originalScale.y * 0.8,
                                    originalScale.z * 1.2
                                );
                                setTimeout(() => {
                                    if (!data.isDead) {
                                        enemy.setLocalScale(originalScale);
                                    }
                                }, 200);
                            }
                            enemy.lookAt(new pc.Vec3(playerPos.x, enemyPos.y, playerPos.z));
                            break;

                        case 'return':
                            const toHome = new pc.Vec3().sub2(data.originalPosition, enemyPos);
                            toHome.y = 0;
                            
                            if (toHome.length() > 1) {
                                toHome.normalize().mulScalar(dt * 3);
                                enemyPos.add(toHome);
                                enemy.setPosition(enemyPos);
                                enemy.lookAt(data.originalPosition);
                            } else {
                                data.state = 'idle';
                                data.health = data.maxHealth; // Heal when returning
                            }
                            break;
                    }

                    // Idle animation based on type
                    if (data.enemyType === 'slime') {
                        const scale = enemy.getLocalScale();
                        scale.y = 0.8 + Math.sin(this.game.gameTime * 4) * 0.1;
                        enemy.setLocalScale(scale);
                    } else if (data.enemyType === 'spirit') {
                        const pos = enemy.getPosition();
                        pos.y = 0.5 + Math.sin(this.game.gameTime * 2) * 0.3;
                        enemy.setPosition(pos);
                    } else if (data.enemyType === 'harpy') {
                        const pos = enemy.getPosition();
                        pos.y = 1.5 + Math.sin(this.game.gameTime * 3) * 0.5;
                        enemy.setPosition(pos);
                    }
                });
            }

            createEasterEggs() {
                // Hidden treasure behind waterfall (represented by lake edge)
                this.createHiddenChest(85, -60, 'legendary', 'waterfall_treasure');
                
                // Secret underground entrance
                this.createSecretEntrance(-40, 60, 'hidden_passage');
                
                // Ancient sword in stone
                this.createSwordInStone(150, -100);
                
                // Mysterious portal
                this.createMysteryPortal(-180, 80);
            }

            createHiddenChest(x, z, rarity, eggId) {
                const chest = this.createChest();
                chest.setPosition(x, 0, z);
                chest.userData.rarity = rarity;
                chest.userData.isEasterEgg = true;
                chest.userData.easterEggId = eggId;
                
                // Add glow for legendary
                if (rarity === 'legendary') {
                    const light = new pc.Entity('ChestGlow');
                    light.addComponent('light', {
                        type: 'point',
                        color: new pc.Color(1, 0.85, 0.2),
                        intensity: 1,
                        range: 8
                    });
                    light.setLocalPosition(0, 1, 0);
                    chest.addChild(light);
                }

                this.game.app.root.addChild(chest);
            }

            createSecretEntrance(x, z, eggId) {
                const entrance = new pc.Entity('SecretEntrance');

                // Hidden trapdoor
                const door = new pc.Entity('Trapdoor');
                door.addComponent('render', { type: 'box' });
                door.setLocalScale(3, 0.2, 3);
                door.setLocalPosition(0, 0.1, 0);

                const doorMat = new pc.StandardMaterial();
                doorMat.diffuse = new pc.Color(0.3, 0.25, 0.15);
                doorMat.update();
                door.render.meshInstances[0].material = doorMat;
                entrance.addChild(door);

                // Subtle glow
                const glow = new pc.Entity('Glow');
                glow.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0.5, 0.3, 0.8),
                    intensity: 0.3,
                    range: 5
                });
                glow.setLocalPosition(0, -0.5, 0);
                entrance.addChild(glow);

                entrance.setPosition(x, 0, z);
                entrance.tags.add('interactable', 'easter_egg');
                entrance.userData = {
                    type: 'secret_entrance',
                    name: 'Strange Floor Panel',
                    isEasterEgg: true,
                    easterEggId: eggId
                };

                this.game.app.root.addChild(entrance);
                this.game.entities.interactables.push({
                    entity: entrance,
                    type: 'secret_entrance',
                    name: 'Strange Floor Panel'
                });
            }

            createSwordInStone(x, z) {
                const monument = new pc.Entity('SwordInStone');

                // Stone
                const stone = new pc.Entity('Stone');
                stone.addComponent('render', { type: 'box' });
                stone.setLocalScale(2, 1.5, 2);
                stone.setLocalPosition(0, 0.75, 0);

                const stoneMat = new pc.StandardMaterial();
                stoneMat.diffuse = new pc.Color(0.5, 0.5, 0.5);
                stoneMat.update();
                stone.render.meshInstances[0].material = stoneMat;
                monument.addChild(stone);

                // Sword blade
                const blade = new pc.Entity('Blade');
                blade.addComponent('render', { type: 'box' });
                blade.setLocalScale(0.1, 2, 0.02);
                blade.setLocalPosition(0, 2.5, 0);

                const bladeMat = new pc.StandardMaterial();
                bladeMat.diffuse = new pc.Color(0.8, 0.85, 0.9);
                bladeMat.emissive = new pc.Color(0.2, 0.25, 0.3);
                bladeMat.update();
                blade.render.meshInstances[0].material = bladeMat;
                monument.addChild(blade);

                // Sword handle
                const handle = new pc.Entity('Handle');
                handle.addComponent('render', { type: 'cylinder' });
                handle.setLocalScale(0.15, 0.4, 0.15);
                handle.setLocalPosition(0, 3.7, 0);

                const handleMat = new pc.StandardMaterial();
                handleMat.diffuse = new pc.Color(0.4, 0.25, 0.1);
                handleMat.update();
                handle.render.meshInstances[0].material = handleMat;
                monument.addChild(handle);

                // Crossguard
                const guard = new pc.Entity('Guard');
                guard.addComponent('render', { type: 'box' });
                guard.setLocalScale(0.5, 0.08, 0.15);
                guard.setLocalPosition(0, 3.5, 0);

                const guardMat = new pc.StandardMaterial();
                guardMat.diffuse = new pc.Color(1, 0.85, 0.3);
                guardMat.update();
                guard.render.meshInstances[0].material = guardMat;
                monument.addChild(guard);

                // Magical glow
                const glow = new pc.Entity('SwordGlow');
                glow.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0.8, 0.9, 1),
                    intensity: 0.8,
                    range: 12
                });
                glow.setLocalPosition(0, 2.5, 0);
                monument.addChild(glow);

                monument.setPosition(x, 0, z);
                monument.tags.add('interactable', 'easter_egg', 'legendary');
                monument.userData = {
                    type: 'legendary_item',
                    name: 'Excalibur',
                    isEasterEgg: true,
                    easterEggId: 'sword_in_stone',
                    requiredLevel: 20
                };

                this.game.app.root.addChild(monument);
                this.game.entities.interactables.push({
                    entity: monument,
                    type: 'legendary_item',
                    name: 'Ancient Sword in Stone'
                });
            }

            createMysteryPortal(x, z) {
                const portal = new pc.Entity('MysteryPortal');

                // Portal ring
                const ring = new pc.Entity('Ring');
                ring.addComponent('render', { type: 'torus' });
                ring.setLocalScale(4, 4, 0.5);
                ring.setLocalPosition(0, 3, 0);
                ring.setEulerAngles(0, 0, 0);

                const ringMat = new pc.StandardMaterial();
                ringMat.diffuse = new pc.Color(0.3, 0.1, 0.5);
                ringMat.emissive = new pc.Color(0.2, 0.05, 0.3);
                ringMat.update();
                ring.render.meshInstances[0].material = ringMat;
                portal.addChild(ring);

                // Portal center (glowing plane)
                const center = new pc.Entity('Center');
                center.addComponent('render', { type: 'cylinder' });
                center.setLocalScale(3, 0.1, 3);
                center.setLocalPosition(0, 3, 0);
                center.setEulerAngles(90, 0, 0);

                const centerMat = new pc.StandardMaterial();
                centerMat.diffuse = new pc.Color(0.5, 0.2, 0.8);
                centerMat.emissive = new pc.Color(0.3, 0.1, 0.5);
                centerMat.opacity = 0.6;
                centerMat.blendType = pc.BLEND_ADDITIVE;
                centerMat.update();
                center.render.meshInstances[0].material = centerMat;
                portal.addChild(center);

                // Portal light
                const light = new pc.Entity('PortalLight');
                light.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0.6, 0.3, 1),
                    intensity: 2,
                    range: 20
                });
                light.setLocalPosition(0, 3, 0);
                portal.addChild(light);

                // Pillar stands
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const pillar = new pc.Entity(`Pillar${i}`);
                    pillar.addComponent('render', { type: 'cylinder' });
                    pillar.setLocalScale(0.4, 5, 0.4);
                    pillar.setLocalPosition(
                        Math.cos(angle) * 3.5,
                        2.5,
                        Math.sin(angle) * 3.5
                    );

                    const pillarMat = new pc.StandardMaterial();
                    pillarMat.diffuse = new pc.Color(0.2, 0.15, 0.25);
                    pillarMat.update();
                    pillar.render.meshInstances[0].material = pillarMat;
                    portal.addChild(pillar);

                    // Pillar top crystal
                    const crystal = new pc.Entity('Crystal');
                    crystal.addComponent('render', { type: 'cone' });
                    crystal.setLocalScale(0.3, 0.6, 0.3);
                    crystal.setLocalPosition(0, 2.8, 0);

                    const crystalMat = new pc.StandardMaterial();
                    crystalMat.diffuse = new pc.Color(0.6, 0.3, 1);
                    crystalMat.emissive = new pc.Color(0.3, 0.15, 0.5);
                    crystalMat.update();
                    crystal.render.meshInstances[0].material = crystalMat;
                    pillar.addChild(crystal);
                }

                portal.setPosition(x, 0, z);
                portal.tags.add('interactable', 'easter_egg');
                portal.userData = {
                    type: 'portal',
                    name: 'Mysterious Portal',
                    isEasterEgg: true,
                    easterEggId: 'mystery_portal',
                    destination: 'secret_realm'
                };

                // Animate portal
                this.game.app.on('update', (dt) => {
                    ring.rotate(0, 30 * dt, 0);
                    center.rotate(0, -60 * dt, 0);
                    
                    // Pulsing light
                    light.light.intensity = 1.5 + Math.sin(this.game.gameTime * 3) * 0.5;
                });

                this.game.app.root.addChild(portal);
                this.game.entities.interactables.push({
                    entity: portal,
                    type: 'portal',
                    name: 'Mysterious Portal'
                });
            }

            update(dt) {
                // Update water animation
                if (this.water) {
                    // Simple wave effect would go here
                }

                // Respawn dead enemies after a delay
                this.game.entities.enemies.forEach(enemy => {
                    if (enemy.data.isDead && enemy.data.respawnTimer !== undefined) {
                        enemy.data.respawnTimer -= dt;
                        if (enemy.data.respawnTimer <= 0) {
                            this.respawnEnemy(enemy);
                        }
                    }
                });
            }

            respawnEnemy(enemyData) {
                const enemy = enemyData.entity;
                const data = enemyData.data;

                data.isDead = false;
                data.health = data.maxHealth;
                data.state = 'idle';
                data.respawnTimer = undefined;

                enemy.setPosition(data.originalPosition);
                enemy.enabled = true;

                // Reset visual
                enemy.setLocalScale(1, 1, 1);
            }

            getChestLoot(rarity) {
                const lootTables = {
                    common: [
                        { id: 'health_potion', name: 'Health Potion', quantity: [1, 3], icon: 'üß™' },
                        { id: 'gold', name: 'Gold', quantity: [10, 50], icon: 'üí∞' }
                    ],
                    uncommon: [
                        { id: 'health_potion', name: 'Health Potion', quantity: [2, 5], icon: 'üß™' },
                        { id: 'mana_potion', name: 'Mana Potion', quantity: [1, 3], icon: 'üíé' },
                        { id: 'gold', name: 'Gold', quantity: [50, 150], icon: 'üí∞' }
                    ],
                    rare: [
                        { id: 'greater_health_potion', name: 'Greater Health Potion', quantity: [2, 4], icon: '‚ù§Ô∏è' },
                        { id: 'skill_scroll', name: 'Skill Scroll', quantity: [1, 1], icon: 'üìú' },
                        { id: 'gold', name: 'Gold', quantity: [150, 400], icon: 'üí∞' },
                        { id: 'gem', name: 'Magic Gem', quantity: [1, 3], icon: 'üí†' }
                    ],
                    epic: [
                        { id: 'epic_weapon_shard', name: 'Epic Weapon Shard', quantity: [1, 2], icon: '‚öîÔ∏è' },
                        { id: 'gold', name: 'Gold', quantity: [400, 1000], icon: 'üí∞' },
                        { id: 'gem', name: 'Magic Gem', quantity: [3, 8], icon: 'üí†' }
                    ],
                    legendary: [
                        { id: 'legendary_core', name: 'Legendary Core', quantity: [1, 1], icon: '‚ú®' },
                        { id: 'dragons_tear', name: 'Dragon\'s Tear', quantity: [1, 1], icon: 'üêâ' },
                        { id: 'gold', name: 'Gold', quantity: [1000, 5000], icon: 'üí∞' },
                        { id: 'gem', name: 'Magic Gem', quantity: [10, 20], icon: 'üí†' }
                    ]
                };

                const table = lootTables[rarity] || lootTables.common;
                const loot = [];
                const numItems = 2 + Math.floor(Math.random() * 3);

                const shuffled = [...table].sort(() => Math.random() - 0.5);
                for (let i = 0; i < Math.min(numItems, shuffled.length); i++) {
                    const item = shuffled[i];
                    const quantity = item.quantity[0] + 
                        Math.floor(Math.random() * (item.quantity[1] - item.quantity[0] + 1));
                    loot.push({
                        id: item.id,
                        name: item.name,
                        quantity: quantity,
                        icon: item.icon
                    });
                }

                return loot;
            }
        }

        // ==================== PLAYER SYSTEM ====================
        class PlayerSystem {
            constructor(game) {
                this.game = game;
                this.entity = null;
                this.stats = {
                    name: 'Hero',
                    class: 'warrior',
                    level: 1,
                    exp: 0,
                    expToLevel: 100,
                    health: 100,
                    maxHealth: 100,
                    mana: 50,
                    maxMana: 50,
                    stamina: 100,
                    maxStamina: 100,
                    strength: 10,
                    intelligence: 10,
                    agility: 10,
                    defense: 5,
                    critChance: 5,
                    gold: 100,
                    gems: 0,
                    skillPoints: 0
                };
                
                this.velocity = new pc.Vec3();
                this.isGrounded = true;
                this.isSprinting = false;
                this.isAttacking = false;
                this.attackCooldown = 0;
                this.nearbyInteractable = null;
                this.unlockedSkills = ['basic_attack'];
                this.equipment = {
                    weapon: null,
                    armor: null,
                    accessory: null
                };
                this.statusEffects = [];
            }

            create(name, playerClass) {
                this.stats.name = name;
                this.stats.class = playerClass;

                // Apply class stats
                this.applyClassStats(playerClass);

                // Create entity
                this.entity = new pc.Entity('Player');

                // Body
                const body = new pc.Entity('Body');
                body.addComponent('render', { type: 'capsule' });
                body.setLocalScale(0.8, 1.8, 0.8);
                body.setLocalPosition(0, 1.4, 0);

                const bodyMat = new pc.StandardMaterial();
                bodyMat.diffuse = this.getClassColor(playerClass);
                bodyMat.update();
                body.render.meshInstances[0].material = bodyMat;
                this.entity.addChild(body);

                // Head
                const head = new pc.Entity('Head');
                head.addComponent('render', { type: 'sphere' });
                head.setLocalScale(0.5, 0.5, 0.5);
                head.setLocalPosition(0, 2.6, 0);

                const skinMat = new pc.StandardMaterial();
                skinMat.diffuse = new pc.Color(1, 0.9, 0.8);
                skinMat.update();
                head.render.meshInstances[0].material = skinMat;
                this.entity.addChild(head);

                // Hair
                const hair = new pc.Entity('Hair');
                hair.addComponent('render', { type: 'sphere' });
                hair.setLocalScale(0.55, 0.4, 0.55);
                hair.setLocalPosition(0, 2.75, -0.05);

                const hairMat = new pc.StandardMaterial();
                hairMat.diffuse = this.getRandomHairColor();
                hairMat.update();
                hair.render.meshInstances[0].material = hairMat;
                this.entity.addChild(hair);

                // Eyes
                const eyeMat = new pc.StandardMaterial();
                eyeMat.diffuse = new pc.Color(0.1, 0.1, 0.1);
                eyeMat.update();

                for (let i = -1; i <= 1; i += 2) {
                    const eye = new pc.Entity(`Eye${i}`);
                    eye.addComponent('render', { type: 'sphere' });
                    eye.setLocalScale(0.08, 0.08, 0.08);
                    eye.setLocalPosition(i * 0.12, 2.65, 0.22);
                    eye.render.meshInstances[0].material = eyeMat;
                    this.entity.addChild(eye);
                }

                // Weapon
                this.createWeapon(playerClass);

                // Player glow
                const glow = new pc.Entity('Glow');
                glow.addComponent('light', {
                    type: 'point',
                    color: this.getClassColor(playerClass),
                    intensity: 0.3,
                    range: 8
                });
                glow.setLocalPosition(0, 1.5, 0);
                this.entity.addChild(glow);
                this.playerGlow = glow;

                this.entity.setPosition(0, 0, 5);

                // Physics
                this.entity.addComponent('collision', {
                    type: 'capsule',
                    radius: 0.4,
                    height: 2
                });
                this.entity.collision.linearOffset = new pc.Vec3(0, 1, 0);

                this.entity.addComponent('rigidbody', {
                    type: 'dynamic',
                    mass: 70,
                    friction: 0.5,
                    restitution: 0,
                    angularFactor: pc.Vec3.ZERO,
                    linearDamping: 0.5
                });

                this.game.app.root.addChild(this.entity);
                this.game.player = this.entity;

                // Update UI
                this.updateUI();
            }

            applyClassStats(playerClass) {
                const classStats = {
                    warrior: {
                        maxHealth: 150,
                        maxMana: 30,
                        strength: 15,
                        defense: 10,
                        icon: '‚öîÔ∏è'
                    },
                    mage: {
                        maxHealth: 80,
                        maxMana: 120,
                        intelligence: 18,
                        strength: 6,
                        icon: 'üîÆ'
                    },
                    archer: {
                        maxHealth: 100,
                        maxMana: 50,
                        agility: 16,
                        critChance: 15,
                        icon: 'üèπ'
                    },
                    healer: {
                        maxHealth: 90,
                        maxMana: 100,
                        intelligence: 14,
                        icon: '‚ú®'
                    },
                    assassin: {
                        maxHealth: 85,
                        maxMana: 60,
                        agility: 18,
                        critChance: 25,
                        strength: 12,
                        icon: 'üó°Ô∏è'
                    },
                    summoner: {
                        maxHealth: 95,
                        maxMana: 90,
                        intelligence: 15,
                        icon: 'üêâ'
                    }
                };

                const stats = classStats[playerClass] || classStats.warrior;
                Object.assign(this.stats, stats);
                this.stats.health = this.stats.maxHealth;
                this.stats.mana = this.stats.maxMana;

                document.getElementById('playerAvatar').textContent = stats.icon;
            }

            getClassColor(playerClass) {
                const colors = {
                    warrior: new pc.Color(0.9, 0.2, 0.2),
                    mage: new pc.Color(0.2, 0.2, 0.9),
                    archer: new pc.Color(0.2, 0.8, 0.2),
                    healer: new pc.Color(1, 1, 0.3),
                    assassin: new pc.Color(0.5, 0.2, 0.8),
                    summoner: new pc.Color(1, 0.5, 0.2)
                };
                return colors[playerClass] || colors.warrior;
            }

            getRandomHairColor() {
                const colors = [
                    new pc.Color(0.1, 0.1, 0.1),
                    new pc.Color(0.4, 0.25, 0.15),
                    new pc.Color(1, 0.85, 0.3),
                    new pc.Color(1, 0.4, 0.6),
                    new pc.Color(0.3, 0.5, 1),
                    new pc.Color(1, 0.3, 0.2)
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createWeapon(playerClass) {
                const weapon = new pc.Entity('Weapon');

                const weaponMat = new pc.StandardMaterial();
                weaponMat.diffuse = new pc.Color(0.8, 0.8, 0.85);
                weaponMat.update();

                switch (playerClass) {
                    case 'warrior':
                        // Sword
                        const blade = new pc.Entity('Blade');
                        blade.addComponent('render', { type: 'box' });
                        blade.setLocalScale(0.08, 1, 0.02);
                        blade.setLocalPosition(0, 0.5, 0);
                        blade.render.meshInstances[0].material = weaponMat;
                        weapon.addChild(blade);

                        const hilt = new pc.Entity('Hilt');
                        hilt.addComponent('render', { type: 'cylinder' });
                        hilt.setLocalScale(0.08, 0.25, 0.08);
                        hilt.setLocalPosition(0, -0.1, 0);
                        const hiltMat = new pc.StandardMaterial();
                        hiltMat.diffuse = new pc.Color(0.4, 0.25, 0.1);
                        hiltMat.update();
                        hilt.render.meshInstances[0].material = hiltMat;
                        weapon.addChild(hilt);
                        break;

                    case 'mage':
                        // Staff
                        const staff = new pc.Entity('Staff');
                        staff.addComponent('render', { type: 'cylinder' });
                        staff.setLocalScale(0.05, 1.3, 0.05);
                        staff.setLocalPosition(0, 0.3, 0);
                        const staffMat = new pc.StandardMaterial();
                        staffMat.diffuse = new pc.Color(0.4, 0.25, 0.15);
                        staffMat.update();
                        staff.render.meshInstances[0].material = staffMat;
                        weapon.addChild(staff);

                        const orb = new pc.Entity('Orb');
                        orb.addComponent('render', { type: 'sphere' });
                        orb.setLocalScale(0.2, 0.2, 0.2);
                        orb.setLocalPosition(0, 1, 0);
                        const orbMat = new pc.StandardMaterial();
                        orbMat.diffuse = new pc.Color(0, 1, 1);
                        orbMat.emissive = new pc.Color(0, 0.5, 0.5);
                        orbMat.update();
                        orb.render.meshInstances[0].material = orbMat;
                        weapon.addChild(orb);
                        break;

                    case 'archer':
                        // Bow
                        const bow = new pc.Entity('Bow');
                        bow.addComponent('render', { type: 'torus' });
                        bow.setLocalScale(0.5, 0.5, 0.1);
                        bow.setLocalPosition(0, 0.3, 0);
                        bow.setEulerAngles(0, 0, 90);
                        const bowMat = new pc.StandardMaterial();
                        bowMat.diffuse = new pc.Color(0.4, 0.25, 0.15);
                        bowMat.update();
                        bow.render.meshInstances[0].material = bowMat;
                        weapon.addChild(bow);
                        break;

                    case 'healer':
                        // Healing staff
                        const healStaff = new pc.Entity('HealStaff');
                        healStaff.addComponent('render', { type: 'cylinder' });
                        healStaff.setLocalScale(0.04, 1.1, 0.04);
                        healStaff.setLocalPosition(0, 0.3, 0);
                        const healStaffMat = new pc.StandardMaterial();
                        healStaffMat.diffuse = new pc.Color(1, 0.85, 0.3);
                        healStaffMat.update();
                        healStaff.render.meshInstances[0].material = healStaffMat;
                        weapon.addChild(healStaff);

                        const crystal = new pc.Entity('Crystal');
                        crystal.addComponent('render', { type: 'cone' });
                        crystal.setLocalScale(0.15, 0.3, 0.15);
                        crystal.setLocalPosition(0, 0.95, 0);
                        crystal.setEulerAngles(180, 0, 0);
                        const crystalMat = new pc.StandardMaterial();
                        crystalMat.diffuse = new pc.Color(0.3, 1, 0.3);
                        crystalMat.emissive = new pc.Color(0.15, 0.5, 0.15);
                        crystalMat.update();
                        crystal.render.meshInstances[0].material = crystalMat;
                        weapon.addChild(crystal);
                        break;

                    case 'assassin':
                        // Twin daggers
                        for (let i = -1; i <= 1; i += 2) {
                            const dagger = new pc.Entity(`Dagger${i}`);
                            dagger.addComponent('render', { type: 'cone' });
                            dagger.setLocalScale(0.06, 0.4, 0.03);
                            dagger.setLocalPosition(i * 0.15, 0.2, 0);
                            dagger.setEulerAngles(0, 0, i * 15);
                            dagger.render.meshInstances[0].material = weaponMat;
                            weapon.addChild(dagger);
                        }
                        break;

                    case 'summoner':
                        // Summoning orb
                        const summonOrb = new pc.Entity('SummonOrb');
                        summonOrb.addComponent('render', { type: 'sphere' });
                        summonOrb.setLocalScale(0.3, 0.3, 0.3);
                        summonOrb.setLocalPosition(0, 0.3, 0);
                        const summonMat = new pc.StandardMaterial();
                        summonMat.diffuse = new pc.Color(1, 0.5, 0.2);
                        summonMat.emissive = new pc.Color(0.5, 0.25, 0.1);
                        summonMat.update();
                        summonOrb.render.meshInstances[0].material = summonMat;
                        weapon.addChild(summonOrb);

                        const ring = new pc.Entity('Ring');
                        ring.addComponent('render', { type: 'torus' });
                        ring.setLocalScale(0.4, 0.4, 0.1);
                        ring.setLocalPosition(0, 0.3, 0);
                        const ringMat = new pc.StandardMaterial();
                        ringMat.diffuse = new pc.Color(1, 0.7, 0.3);
                        ringMat.update();
                        ring.render.meshInstances[0].material = ringMat;
                        weapon.addChild(ring);
                        break;
                }

                weapon.setLocalPosition(0.6, 1.5, 0.2);
                weapon.setEulerAngles(-20, 0, -30);
                this.entity.addChild(weapon);
                this.weapon = weapon;
            }

            update(dt) {
                if (!this.entity || this.game.state !== GameState.PLAYING) return;

                this.handleMovement(dt);
                this.handleCombat(dt);
                this.checkInteractables();
                this.updateStatusEffects(dt);
                this.regenerate(dt);
                this.animate(dt);
                this.updateUI();
            }

            handleMovement(dt) {
                const input = this.game.systems.input;
                const moveDir = new pc.Vec3();

                if (input.isPressed('forward')) moveDir.z -= 1;
                if (input.isPressed('backward')) moveDir.z += 1;
                if (input.isPressed('left')) moveDir.x -= 1;
                if (input.isPressed('right')) moveDir.x += 1;

                const isMoving = moveDir.lengthSq() > 0;
                this.isSprinting = input.isPressed('sprint') && isMoving && this.stats.stamina > 0;

                if (isMoving) {
                    moveDir.normalize();

                    // Rotate movement based on camera
                    const cameraRotation = input.cameraRotation;
                    const sin = Math.sin(cameraRotation);
                    const cos = Math.cos(cameraRotation);
                    const rotatedX = moveDir.x * cos - moveDir.z * sin;
                    const rotatedZ = moveDir.x * sin + moveDir.z * cos;
                    moveDir.x = rotatedX;
                    moveDir.z = rotatedZ;

                    let speed = CONFIG.PLAYER_SPEED;
                    if (this.isSprinting) {
                        speed *= CONFIG.SPRINT_MULTIPLIER;
                        this.stats.stamina -= 25 * dt;
                        if (this.stats.stamina < 0) this.stats.stamina = 0;
                    }

                    // Apply movement using rigidbody
                    const velocity = this.entity.rigidbody.linearVelocity;
                    velocity.x = moveDir.x * speed;
                    velocity.z = moveDir.z * speed;
                    this.entity.rigidbody.linearVelocity = velocity;

                    // Rotate player to face movement direction
                    const targetAngle = Math.atan2(moveDir.x, moveDir.z) * (180 / Math.PI);
                    const currentRotation = this.entity.getEulerAngles();
                    let angleDiff = targetAngle - currentRotation.y;
                    
                    while (angleDiff > 180) angleDiff -= 360;
                    while (angleDiff < -180) angleDiff += 360;
                    
                    currentRotation.y += angleDiff * dt * 10;
                    this.entity.setEulerAngles(currentRotation);
                }

                // Jumping
                this.checkGrounded();
                if (input.isPressed('jump') && this.isGrounded && this.stats.stamina >= 10) {
                    const velocity = this.entity.rigidbody.linearVelocity;
                    velocity.y = CONFIG.JUMP_FORCE;
                    this.entity.rigidbody.linearVelocity = velocity;
                    this.isGrounded = false;
                    this.stats.stamina -= 10;
                }
            }

            checkGrounded() {
                const pos = this.entity.getPosition();
                this.isGrounded = pos.y <= 0.1;
                
                // Clamp to ground
                if (pos.y < 0) {
                    pos.y = 0;
                    this.entity.setPosition(pos);
                    const vel = this.entity.rigidbody.linearVelocity;
                    if (vel.y < 0) vel.y = 0;
                    this.entity.rigidbody.linearVelocity = vel;
                    this.isGrounded = true;
                }
            }

            handleCombat(dt) {
                this.attackCooldown -= dt;

                const input = this.game.systems.input;
                
                if ((input.isPressed('attack') || input.keys.attack) && this.attackCooldown <= 0) {
                    this.performAttack();
                }
            }

            performAttack() {
                if (this.isAttacking) return;

                this.isAttacking = true;
                this.attackCooldown = 0.5;

                // Attack animation
                const originalRot = this.weapon.getLocalEulerAngles().clone();
                this.weapon.setLocalEulerAngles(-60, 0, -30);
                
                setTimeout(() => {
                    if (this.weapon) {
                        this.weapon.setLocalEulerAngles(originalRot.x, originalRot.y, originalRot.z);
                    }
                    this.isAttacking = false;
                }, 200);

                // Check for enemies in range
                const playerPos = this.entity.getPosition();
                const playerForward = new pc.Vec3(0, 0, -1);
                const playerRotation = this.entity.getEulerAngles();
                const angle = playerRotation.y * (Math.PI / 180);
                playerForward.x = Math.sin(angle);
                playerForward.z = -Math.cos(angle);

                this.game.entities.enemies.forEach(enemyData => {
                    if (enemyData.data.isDead) return;

                    const enemy = enemyData.entity;
                    const enemyPos = enemy.getPosition();
                    const toEnemy = new pc.Vec3().sub2(enemyPos, playerPos);
                    const distance = toEnemy.length();

                    if (distance <= 3.5) {
                        // Check angle
                        toEnemy.normalize();
                        const dot = playerForward.dot(toEnemy);
                        
                        if (dot > 0.5) { // Within ~60 degree cone
                            const damage = this.calculateDamage();
                            this.dealDamageToEnemy(enemyData, damage);
                        }
                    }
                });

                // Also check training dummies and other attackables
                this.game.entities.interactables.forEach(interactable => {
                    if (interactable.type !== 'training_dummy') return;
                    
                    const obj = interactable.entity;
                    const objPos = obj.getPosition();
                    const toObj = new pc.Vec3().sub2(objPos, playerPos);
                    const distance = toObj.length();

                    if (distance <= 3.5) {
                        toObj.normalize();
                        const dot = playerForward.dot(toObj);
                        
                        if (dot > 0.5) {
                            const damage = this.calculateDamage();
                            this.game.systems.ui.showDamageNumber(
                                damage.amount,
                                objPos,
                                damage.isCrit ? 'crit' : 'enemy'
                            );
                            this.game.systems.particle.createHitEffect(objPos);
                        }
                    }
                });
            }

            calculateDamage() {
                let baseDamage = this.stats.strength * 2;
                
                // Weapon bonus
                if (this.equipment.weapon) {
                    baseDamage += this.equipment.weapon.damage || 0;
                }

                // Critical hit
                const isCrit = Math.random() * 100 < this.stats.critChance;
                if (isCrit) {
                    baseDamage *= 2;
                }

                // Variance
                baseDamage *= 0.9 + Math.random() * 0.2;

                return {
                    amount: Math.floor(baseDamage),
                    isCrit: isCrit
                };
            }

            dealDamageToEnemy(enemyData, damage) {
                const enemy = enemyData.entity;
                const data = enemyData.data;

                data.health -= damage.amount;

                // Show damage number
                this.game.systems.ui.showDamageNumber(
                    damage.amount,
                    enemy.getPosition(),
                    damage.isCrit ? 'crit' : 'enemy'
                );

                // Hit effect
                this.game.systems.particle.createHitEffect(enemy.getPosition());

                // Flash red
                enemy.children.forEach(child => {
                    if (child.render) {
                        const originalColor = child.render.meshInstances[0].material.diffuse.clone();
                        child.render.meshInstances[0].material.diffuse = new pc.Color(1, 0, 0);
                        child.render.meshInstances[0].material.update();
                        
                        setTimeout(() => {
                            if (child.render && child.render.meshInstances[0]) {
                                child.render.meshInstances[0].material.diffuse = originalColor;
                                child.render.meshInstances[0].material.update();
                            }
                        }, 100);
                    }
                });

                // Aggro
                if (data.state === 'idle' || data.state === 'wander') {
                    data.state = 'chase';
                }

                if (data.health <= 0) {
                    this.killEnemy(enemyData);
                }
            }

            killEnemy(enemyData) {
                const enemy = enemyData.entity;
                const data = enemyData.data;

                data.isDead = true;
                data.state = 'dead';

                // Gain rewards
                this.gainExp(data.exp);
                this.stats.gold += data.gold;
                
                this.game.systems.ui.notify(`Defeated ${data.name}! +${data.exp} EXP, +${data.gold} Gold`, 'combat');

                // Death effect
                this.game.systems.particle.createDeathEffect(enemy.getPosition());

                // Quest progress
                this.game.systems.quest.updateKillProgress(data.enemyType);

                // Hide enemy and set respawn timer
                enemy.enabled = false;
                data.respawnTimer = 30; // 30 seconds

                // Possible loot drop
                if (Math.random() > 0.5) {
                    this.dropLoot(enemy.getPosition(), data);
                }
            }

            dropLoot(position, enemyData) {
                const lootTable = {
                    slime: ['slime_gel', 'health_potion'],
                    wolf: ['wolf_fang', 'shadow_essence'],
                    spirit: ['spectral_essence', 'mana_potion'],
                    golem: ['crystal_shard', 'iron_ore'],
                    harpy: ['harpy_feather', 'wind_essence'],
                    demon: ['demon_horn', 'dark_crystal']
                };

                const possibleLoot = lootTable[enemyData.enemyType] || ['health_potion'];
                const lootId = possibleLoot[Math.floor(Math.random() * possibleLoot.length)];

                // Create loot pickup
                const loot = new pc.Entity('Loot');
                loot.addComponent('render', { type: 'sphere' });
                loot.setLocalScale(0.3, 0.3, 0.3);
                loot.setPosition(position.x, 0.5, position.z);

                const lootMat = new pc.StandardMaterial();
                lootMat.diffuse = new pc.Color(1, 0.85, 0.3);
                lootMat.emissive = new pc.Color(0.5, 0.4, 0.15);
                lootMat.update();
                loot.render.meshInstances[0].material = lootMat;

                loot.tags.add('loot', 'interactable');
                loot.userData = {
                    type: 'loot',
                    itemId: lootId,
                    name: this.getItemName(lootId)
                };

                this.game.app.root.addChild(loot);
                this.game.entities.items.push({
                    entity: loot,
                    data: loot.userData
                });

                // Animate loot
                this.game.app.on('update', (dt) => {
                    if (!loot.parent) return;
                    loot.rotate(0, 90 * dt, 0);
                    const pos = loot.getPosition();
                    pos.y = 0.5 + Math.sin(this.game.gameTime * 3) * 0.1;
                    loot.setPosition(pos);
                });

                // Auto-despawn after 60 seconds
                setTimeout(() => {
                    if (loot.parent) {
                        this.game.app.root.removeChild(loot);
                        loot.destroy();
                    }
                }, 60000);
            }

            getItemName(itemId) {
                const names = {
                    health_potion: 'Health Potion',
                    mana_potion: 'Mana Potion',
                    slime_gel: 'Slime Gel',
                    wolf_fang: 'Wolf Fang',
                    shadow_essence: 'Shadow Essence',
                    spectral_essence: 'Spectral Essence',
                    crystal_shard: 'Crystal Shard',
                    iron_ore: 'Iron Ore',
                    harpy_feather: 'Harpy Feather',
                    wind_essence: 'Wind Essence',
                    demon_horn: 'Demon Horn',
                    dark_crystal: 'Dark Crystal'
                };
                return names[itemId] || itemId;
            }

            checkInteractables() {
                const playerPos = this.entity.getPosition();
                let closest = null;
                let closestDist = CONFIG.INTERACTION_RANGE;

                // Check NPCs
                this.game.entities.npcs.forEach(npc => {
                    const dist = playerPos.distance(npc.entity.getPosition());
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = { type: 'npc', data: npc };
                    }
                });

                // Check interactables
                this.game.entities.interactables.forEach(obj => {
                    const dist = playerPos.distance(obj.entity.getPosition());
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = { type: obj.type, data: obj };
                    }
                });

                // Check loot
                this.game.entities.items.forEach(item => {
                    const dist = playerPos.distance(item.entity.getPosition());
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = { type: 'loot', data: item };
                    }
                });

                this.nearbyInteractable = closest;

                // Update prompt
                const prompt = document.getElementById('interactionPrompt');
                if (closest) {
                    prompt.style.display = 'block';
                    if (closest.type === 'npc') {
                        prompt.innerHTML = `Press <span>E</span> to talk to ${closest.data.data.name}`;
                    } else if (closest.type === 'loot') {
                        prompt.innerHTML = `Press <span>E</span> to pick up ${closest.data.data.name}`;
                    } else if (closest.type === 'chest') {
                        prompt.innerHTML = `Press <span>E</span> to open chest`;
                    } else if (closest.type === 'shrine') {
                        prompt.innerHTML = `Press <span>E</span> to pray at shrine`;
                    } else {
                        prompt.innerHTML = `Press <span>E</span> to interact`;
                    }
                } else {
                    prompt.style.display = 'none';
                }
            }

            interact() {
                if (!this.nearbyInteractable) return;

                const { type, data } = this.nearbyInteractable;

                switch (type) {
                    case 'npc':
                        this.game.systems.dialogue.start(data.data.id, 'default');
                        break;

                    case 'loot':
                        this.game.systems.inventory.addItem(data.data.itemId, 1);
                        this.game.systems.ui.notify(`Picked up ${data.data.name}!`, 'item');
                        
                        // Remove from world
                        const index = this.game.entities.items.indexOf(data);
                        if (index > -1) {
                            this.game.entities.items.splice(index, 1);
                        }
                        this.game.app.root.removeChild(data.entity);
                        data.entity.destroy();
                        break;

                    case 'chest':
                        if (!data.entity.userData.opened) {
                            data.entity.userData.opened = true;
                            
                            const loot = this.game.systems.world.getChestLoot(data.entity.userData.rarity);
                            loot.forEach(item => {
                                if (item.id === 'gold') {
                                    this.stats.gold += item.quantity;
                                } else if (item.id === 'gem') {
                                    this.stats.gems += item.quantity;
                                } else {
                                    this.game.systems.inventory.addItem(item.id, item.quantity);
                                }
                                this.game.systems.ui.notify(`Found ${item.quantity}x ${item.name}!`, 'item');
                            });

                            // Easter egg check
                            if (data.entity.userData.isEasterEgg) {
                                this.game.systems.achievement.unlockEasterEgg(data.entity.userData.easterEggId);
                            }

                            // Open animation (simple rotation)
                            const lid = data.entity.findByName('Lid');
                            if (lid) {
                                lid.setLocalEulerAngles(-60, 0, 0);
                            }
                        }
                        break;

                    case 'shrine':
                        this.stats.health = this.stats.maxHealth;
                        this.stats.mana = this.stats.maxMana;
                        this.stats.stamina = this.stats.maxStamina;
                        this.game.systems.world.respawnPoint = this.entity.getPosition().clone();
                        this.game.systems.ui.notify('You feel refreshed. Respawn point set.', 'item');
                        this.game.systems.particle.createHealingEffect(this.entity.getPosition());
                        break;

                    case 'well':
                        if (this.stats.gold >= 1) {
                            this.stats.gold -= 1;
                            data.entity.userData.coinsThrown = (data.entity.userData.coinsThrown || 0) + 1;
                            
                            if (data.entity.userData.coinsThrown >= 10) {
                                this.game.systems.achievement.unlockEasterEgg('wishing_well');
                                this.game.systems.ui.notify('The well spirit grants you a blessing!', 'secret');
                                this.addStatusEffect('luck_boost', 300);
                            } else {
                                this.game.systems.ui.notify(
                                    `Threw a coin... (${data.entity.userData.coinsThrown}/10)`, 
                                    'item'
                                );
                            }
                        } else {
                            this.game.systems.ui.notify('You need at least 1 gold.', 'combat');
                        }
                        break;

                    case 'cat':
                        data.entity.userData.petCount = (data.entity.userData.petCount || 0) + 1;
                        const count = data.entity.userData.petCount;
                        
                        if (count >= 10 && !data.entity.userData.easterEggTriggered) {
                            data.entity.userData.easterEggTriggered = true;
                            this.game.systems.achievement.unlockEasterEgg('cat_lover');
                            this.game.systems.ui.notify('Mochi loves you! You received a Lucky Charm!', 'secret');
                            this.game.systems.inventory.addItem('lucky_charm', 1);
                        } else if (count < 10) {
                            const messages = [
                                'Mochi purrs contentedly.',
                                'Mochi rubs against your leg.',
                                'Mochi meows happily!',
                                'Mochi seems to like you.',
                                'Mochi does a little dance!'
                            ];
                            this.game.systems.ui.notify(
                                messages[Math.floor(Math.random() * messages.length)] + ` (${count}/10)`,
                                'item'
                            );
                        }
                        break;

                    case 'mysterious_stone':
                        this.game.systems.dialogue.showMessage(
                            'Ancient runes glow with mysterious power. You sense this place holds secrets...'
                        );
                        if (!this.game.flags.runesDiscovered) {
                            this.game.flags.runesDiscovered = true;
                            this.game.systems.achievement.unlockEasterEgg('ancient_runes');
                        }
                        break;

                    case 'boss_trigger':
                        this.game.systems.dialogue.showMessage(
                            `You feel a powerful presence emanating from the ${data.name}. Are you ready for battle?`
                        );
                        // Would trigger boss fight in full implementation
                        break;

                    case 'legendary_item':
                        if (this.stats.level >= data.entity.userData.requiredLevel) {
                            this.game.systems.ui.notify('You draw the legendary sword!', 'secret');
                            this.game.systems.inventory.addItem('excalibur', 1);
                            this.game.systems.achievement.unlockEasterEgg('sword_in_stone');
                            data.entity.userData.claimed = true;
                            
                            // Remove sword visual
                            const blade = data.entity.findByName('Blade');
                            const handle = data.entity.findByName('Handle');
                            const guard = data.entity.findByName('Guard');
                            if (blade) blade.enabled = false;
                            if (handle) handle.enabled = false;
                            if (guard) guard.enabled = false;
                        } else {
                            this.game.systems.ui.notify(
                                `You must be level ${data.entity.userData.requiredLevel} to draw this sword.`,
                                'combat'
                            );
                        }
                        break;

                    case 'portal':
                        this.game.systems.ui.notify('The portal crackles with energy... (Coming soon!)', 'secret');
                        break;

                    case 'door':
                        this.game.systems.ui.notify(`Entering ${data.name}... (Coming soon!)`, 'quest');
                        break;
                }

                this.updateUI();
            }

            takeDamage(amount) {
                // Apply defense
                const reduced = Math.max(1, amount - this.stats.defense);
                this.stats.health -= reduced;

                this.game.systems.ui.showDamageNumber(reduced, this.entity.getPosition(), 'player');
                this.game.systems.ui.screenShake(0.2);

                if (this.stats.health <= 0) {
                    this.stats.health = 0;
                    this.die();
                }

                this.updateUI();
            }

            heal(amount) {
                this.stats.health = Math.min(this.stats.health + amount, this.stats.maxHealth);
                this.game.systems.ui.showDamageNumber(amount, this.entity.getPosition(), 'heal');
                this.game.systems.particle.createHealingEffect(this.entity.getPosition());
                this.updateUI();
            }

            die() {
                this.game.systems.ui.notify('You have fallen...', 'combat');
                
                // Respawn after delay
                setTimeout(() => {
                    this.respawn();
                }, 3000);
            }

            respawn() {
                const respawnPoint = this.game.systems.world.respawnPoint;
                this.entity.setPosition(respawnPoint.x, respawnPoint.y, respawnPoint.z);
                this.entity.rigidbody.linearVelocity = pc.Vec3.ZERO;
                
                this.stats.health = Math.floor(this.stats.maxHealth * 0.5);
                this.stats.mana = Math.floor(this.stats.maxMana * 0.5);
                
                this.updateUI();
                this.game.systems.ui.notify('You have been revived.', 'quest');
            }

            gainExp(amount) {
                this.stats.exp += amount;
                
                while (this.stats.exp >= this.stats.expToLevel) {
                    this.levelUp();
                }

                this.updateUI();
            }

            levelUp() {
                this.stats.exp -= this.stats.expToLevel;
                this.stats.level++;
                this.stats.expToLevel = Math.floor(this.stats.expToLevel * 1.5);
                this.stats.skillPoints += 2;

                // Stat increases
                this.stats.maxHealth += 10;
                this.stats.maxMana += 5;
                this.stats.strength += 2;
                this.stats.intelligence += 2;
                this.stats.agility += 1;
                this.stats.defense += 1;

                // Full heal
                this.stats.health = this.stats.maxHealth;
                this.stats.mana = this.stats.maxMana;
                this.stats.stamina = this.stats.maxStamina;

                this.game.systems.ui.notify(`Level Up! You are now level ${this.stats.level}!`, 'level');
                this.game.systems.particle.createLevelUpEffect(this.entity.getPosition());
                this.game.systems.achievement.checkLevelAchievements(this.stats.level);
            }

            addStatusEffect(effectId, duration) {
                const effects = {
                    luck_boost: { name: 'Lucky', icon: 'üçÄ', type: 'buff' },
                    strength_boost: { name: 'Strong', icon: 'üí™', type: 'buff' },
                    speed_boost: { name: 'Swift', icon: 'üí®', type: 'buff' },
                    poison: { name: 'Poisoned', icon: '‚ò†Ô∏è', type: 'debuff', tickDamage: 5 },
                    burn: { name: 'Burning', icon: 'üî•', type: 'debuff', tickDamage: 3 },
                    regen: { name: 'Regenerating', icon: 'üíö', type: 'buff', tickHeal: 5 }
                };

                const effect = effects[effectId];
                if (!effect) return;

                // Remove existing
                this.statusEffects = this.statusEffects.filter(e => e.id !== effectId);

                this.statusEffects.push({
                    id: effectId,
                    ...effect,
                    duration,
                    maxDuration: duration
                });
            }

            updateStatusEffects(dt) {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration -= dt;

                    if (effect.tickDamage) {
                        this.stats.health -= effect.tickDamage * dt;
                        if (this.stats.health < 1) this.stats.health = 1;
                    }

                    if (effect.tickHeal) {
                        this.stats.health = Math.min(
                            this.stats.health + effect.tickHeal * dt,
                            this.stats.maxHealth
                        );
                    }

                    return effect.duration > 0;
                });
            }

            regenerate(dt) {
                // Stamina regen
                if (!this.isSprinting && this.stats.stamina < this.stats.maxStamina) {
                    this.stats.stamina = Math.min(
                        this.stats.stamina + 20 * dt,
                        this.stats.maxStamina
                    );
                }

                // Mana regen
                if (this.stats.mana < this.stats.maxMana) {
                    this.stats.mana = Math.min(
                        this.stats.mana + 2 * dt,
                        this.stats.maxMana
                    );
                }
            }

            animate(dt) {
                if (!this.entity) return;

                // Breathing idle animation
                const body = this.entity.findByName('Body');
                if (body) {
                    const scale = body.getLocalScale();
                    scale.y = 1.8 + Math.sin(this.game.gameTime * 2) * 0.02;
                    body.setLocalScale(scale);
                }

                // Player glow pulse
                if (this.playerGlow) {
                    this.playerGlow.light.intensity = 0.3 + Math.sin(this.game.gameTime * 2) * 0.1;
                }

                // Weapon idle animation
                if (this.weapon && !this.isAttacking) {
                    const rot = this.weapon.getLocalEulerAngles();
                    rot.x = -20 + Math.sin(this.game.gameTime * 1.5) * 3;
                    this.weapon.setLocalEulerAngles(rot);
                }
            }

            updateUI() {
                document.getElementById('playerName').textContent = this.stats.name;
                document.getElementById('playerLevel').textContent = this.stats.level;
                document.getElementById('playerClass').textContent = this.getClassName();

                document.getElementById('curHP').textContent = Math.floor(this.stats.health);
                document.getElementById('maxHP').textContent = this.stats.maxHealth;
                document.getElementById('hpBar').style.width = 
                    (this.stats.health / this.stats.maxHealth * 100) + '%';

                document.getElementById('curMP').textContent = Math.floor(this.stats.mana);
                document.getElementById('maxMP').textContent = this.stats.maxMana;
                document.getElementById('mpBar').style.width = 
                    (this.stats.mana / this.stats.maxMana * 100) + '%';

                document.getElementById('curSP').textContent = Math.floor(this.stats.stamina);
                document.getElementById('maxSP').textContent = this.stats.maxStamina;
                document.getElementById('spBar').style.width = 
                    (this.stats.stamina / this.stats.maxStamina * 100) + '%';

                document.getElementById('curXP').textContent = this.stats.exp;
                document.getElementById('xpNeeded').textContent = this.stats.expToLevel;
                document.getElementById('xpBar').style.width = 
                    (this.stats.exp / this.stats.expToLevel * 100) + '%';

                document.getElementById('goldAmount').textContent = this.stats.gold;
                document.getElementById('gemAmount').textContent = this.stats.gems;
                document.getElementById('skillPts').textContent = this.stats.skillPoints;
            }

            getClassName() {
                const names = {
                    warrior: 'Blade Dancer',
                    mage: 'Spirit Weaver',
                    archer: 'Wind Walker',
                    healer: 'Light Bringer',
                    assassin: 'Shadow Blade',
                    summoner: 'Beast Caller'
                };
                return names[this.stats.class] || 'Adventurer';
            }
        }

        // ==================== COMBAT SYSTEM ====================
        class CombatSystem {
            constructor(game) {
                this.game = game;
                this.inCombat = false;
                this.currentEnemy = null;
                this.turnBased = false; // Real-time combat
            }

            update(dt) {
                // Combat is handled in real-time through player/enemy systems
            }

            startBossFight(bossId) {
                // Would initialize boss encounter
                this.game.systems.ui.notify(`Boss fight: ${bossId} coming soon!`, 'combat');
            }
        }

        // ==================== DIALOGUE SYSTEM ====================
        class DialogueSystem {
            constructor(game) {
                this.game = game;
                this.currentNPC = null;
                this.currentDialogue = null;
                this.dialogueData = this.initDialogueData();
            }

            initDialogueData() {
                return {
                    elder_sakura: {
                        intro: {
                            text: "Welcome, young traveler. I am Elder Sakura, guardian of this village. Dark times are upon us... The ancient seals protecting our land are weakening. Creatures of shadow now roam freely.",
                            choices: [
                                { text: "What can I do to help?", next: 'quest_offer' },
                                { text: "Tell me about the seals.", next: 'lore' },
                                { text: "I need to prepare first.", next: 'end' }
                            ]
                        },
                        quest_offer: {
                            text: "Brave soul! We need someone to venture into the Forest of Whispers and retrieve the First Seal Fragment. It lies within the Ancient Ruins, guarded by a Forest Guardian.",
                            choices: [
                                { text: "I accept this quest!", action: 'accept_quest', questId: 'main_seal_fragment' },
                                { text: "That sounds dangerous...", next: 'encouragement' }
                            ]
                        },
                        lore: {
                            text: "Long ago, our ancestors sealed away the Shadow Sovereign. Four fragments were scattered: Forest, Caverns, Mountains, and Temple. Dark forces seek to reunite them.",
                            choices: [
                                { text: "I will stop them!", next: 'quest_offer' },
                                { text: "I understand.", next: 'end' }
                            ]
                        },
                        encouragement: {
                            text: "I sense great potential in you. The spirits guided you here for a reason. When you're ready, return to me.",
                            choices: [
                                { text: "Very well.", next: 'end' }
                            ]
                        },
                        default: {
                            text: "How may I assist you, traveler?",
                            choices: [
                                { text: "Any quests available?", next: 'quest_offer' },
                                { text: "Tell me about the village.", next: 'village' },
                                { text: "Goodbye.", next: 'end' }
                            ]
                        },
                        village: {
                            text: "Sakura Village has stood for 500 years, known for our eternal cherry blossoms. We have skilled craftsmen, warriors, and scholars.",
                            choices: [
                                { text: "Fascinating!", next: 'default' },
                                { text: "Thank you.", next: 'end' }
                            ]
                        }
                    },
                    kaito_blacksmith: {
                        default: {
                            text: "*Hammering stops* Welcome to the Forge of Flames! I'm Kaito, master blacksmith. Need weapons or armor?",
                            choices: [
                                { text: "Show me weapons.", action: 'open_shop', category: 'weapons' },
                                { text: "Can you upgrade my gear?", next: 'upgrade' },
                                { text: "Just looking around.", next: 'end' }
                            ]
                        },
                        upgrade: {
                            text: "Upgrades require materials. Bring me Iron Ore for basic, Mithril for advanced. What would you like to upgrade?",
                            choices: [
                                { text: "I'll gather materials.", next: 'end' },
                                { text: "Maybe later.", next: 'end' }
                            ]
                        }
                    },
                    mei_innkeeper: {
                        default: {
                            text: "*Waves cheerfully* Welcome to Sakura Inn! You look like you could use rest.",
                            choices: [
                                { text: "I'd like to rest. (20 gold)", action: 'rest' },
                                { text: "What's the local gossip?", next: 'gossip' },
                                { text: "Just passing through.", next: 'end' }
                            ]
                        },
                        gossip: {
                            text: "*Whispers* People have been disappearing near the old well at night. And merchant Tanaka has been acting strange...",
                            choices: [
                                { text: "Interesting...", action: 'unlock_quest', questId: 'well_mystery' },
                                { text: "Thanks for the info.", next: 'end' }
                            ]
                        }
                    },
                    tanaka_merchant: {
                        default: {
                            text: "*Nervously* W-welcome! I have potions, materials, everything you need!",
                            choices: [
                                { text: "Show me potions.", action: 'open_shop', category: 'potions' },
                                { text: "You seem nervous...", next: 'nervous' },
                                { text: "Nevermind.", next: 'end' }
                            ]
                        },
                        nervous: {
                            text: "*Sweating* M-me? Nervous? Don't be ridiculous! Business is fine! Great even!",
                            choices: [
                                { text: "If you say so...", next: 'end' }
                            ]
                        }
                    },
                    yuki_alchemist: {
                        default: {
                            text: "*Mystical eyes sparkle* Welcome to Mystic Brews! My potions can enhance abilities beyond imagination!",
                            choices: [
                                { text: "Show me potions.", action: 'open_shop', category: 'special' },
                                { text: "Teach me alchemy.", next: 'teach' },
                                { text: "Goodbye.", next: 'end' }
                            ]
                        },
                        teach: {
                            text: "Bring me 10 Healing Herbs and 5 Mana Crystals. Then I'll teach you the basics.",
                            choices: [
                                { text: "I'll gather them!", action: 'accept_quest', questId: 'learn_alchemy' },
                                { text: "Maybe later.", next: 'end' }
                            ]
                        }
                    },
                    master_hiroshi: {
                        default: {
                            text: "*Bows* Welcome to the Training Dojo. I am Master Hiroshi. Ready to become stronger?",
                            choices: [
                                { text: "Teach me skills!", action: 'open_skills' },
                                { text: "I want to spar!", next: 'spar' },
                                { text: "I'll train later.", next: 'end' }
                            ]
                        },
                        spar: {
                            text: "A sparring match? I won't hold back! Prepare yourself!",
                            choices: [
                                { text: "Bring it on!", action: 'start_spar' },
                                { text: "Maybe when I'm stronger.", next: 'end' }
                            ]
                        }
                    },
                    mysterious_stranger: {
                        default: {
                            text: "*A cloaked figure speaks* ...You can see me? Interesting. Perhaps you are the one spoken of in prophecy...",
                            choices: [
                                { text: "Who are you?", next: 'identity' },
                                { text: "What prophecy?", next: 'prophecy' },
                                { text: "This is too strange.", next: 'end' }
                            ]
                        },
                        identity: {
                            text: "I am a watcher between worlds. I have witnessed empires rise and fall. And now, I witness you.",
                            choices: [
                                { text: "Tell me the prophecy.", next: 'prophecy' },
                                { text: "I should go.", next: 'end' }
                            ]
                        },
                        prophecy: {
                            text: "When shadows consume the sacred four, a hero born of mortal flesh shall bind the dark. The blood of Sakurablade flows in you. Your destiny awaits.",
                            choices: [
                                { text: "I won't fail.", action: 'give_item', itemId: 'twilight_fragment' },
                                { text: "I need time to think.", next: 'end' }
                            ]
                        }
                    }
                };
            }

            start(npcId, dialogueId) {
                const npcDialogues = this.dialogueData[npcId];
                if (!npcDialogues) {
                    console.warn(`No dialogue found for NPC: ${npcId}`);
                    return;
                }

                const dialogue = npcDialogues[dialogueId] || npcDialogues.default;
                if (!dialogue) return;

                this.currentNPC = npcId;
                this.currentDialogue = dialogue;
                this.game.state = GameState.DIALOGUE;

                this.showDialogue(npcId, dialogue);
            }

            showDialogue(npcId, dialogue) {
                const npc = this.game.entities.npcs.find(n => n.data.id === npcId);
                
                const box = document.getElementById('dialogueBox');
                const portrait = document.getElementById('dialoguePortrait');
                const name = document.getElementById('dialogueName');
                const title = document.getElementById('dialogueTitle');
                const text = document.getElementById('dialogueText');
                const choices = document.getElementById('dialogueChoices');

                if (npc) {
                    portrait.textContent = npc.data.icon;
                    name.textContent = npc.data.name;
                    title.textContent = npc.data.title;
                }

                // Typewriter effect
                text.textContent = '';
                let charIndex = 0;
                const typeSpeed = 30;
                
                const typeWriter = () => {
                    if (charIndex < dialogue.text.length) {
                        text.textContent += dialogue.text.charAt(charIndex);
                        charIndex++;
                        setTimeout(typeWriter, typeSpeed);
                    }
                };
                typeWriter();

                // Build choices
                choices.innerHTML = '';
                dialogue.choices.forEach((choice, index) => {
                    const btn = document.createElement('div');
                    btn.className = 'dialogue-choice';
                    btn.textContent = choice.text;
                    btn.addEventListener('click', () => this.selectChoice(choice));
                    choices.appendChild(btn);
                });

                box.style.display = 'block';
            }

            selectChoice(choice) {
                // Handle actions
                if (choice.action) {
                    this.handleAction(choice);
                }

                // Navigate to next dialogue or close
                if (choice.next === 'end') {
                    this.close();
                } else if (choice.next) {
                    const nextDialogue = this.dialogueData[this.currentNPC][choice.next];
                    if (nextDialogue) {
                        this.showDialogue(this.currentNPC, nextDialogue);
                    } else {
                        this.close();
                    }
                } else if (!choice.action) {
                    this.close();
                }
            }

            handleAction(choice) {
                switch (choice.action) {
                    case 'accept_quest':
                        this.game.systems.quest.acceptQuest(choice.questId);
                        this.game.systems.ui.notify('New quest accepted!', 'quest');
                        break;

                    case 'unlock_quest':
                        this.game.systems.quest.unlockQuest(choice.questId);
                        break;

                    case 'open_shop':
                        this.game.systems.ui.notify('Shop coming soon!', 'item');
                        break;

                    case 'open_skills':
                        this.close();
                        this.game.systems.ui.toggleSkillMenu();
                        break;

                    case 'rest':
                        if (this.game.systems.player.stats.gold >= 20) {
                            this.game.systems.player.stats.gold -= 20;
                            this.game.systems.player.stats.health = this.game.systems.player.stats.maxHealth;
                            this.game.systems.player.stats.mana = this.game.systems.player.stats.maxMana;
                            this.game.systems.player.stats.stamina = this.game.systems.player.stats.maxStamina;
                            this.game.systems.ui.notify('You feel well rested!', 'item');
                            this.game.systems.player.updateUI();
                        } else {
                            this.game.systems.ui.notify('Not enough gold!', 'combat');
                        }
                        break;

                    case 'give_item':
                        this.game.systems.inventory.addItem(choice.itemId, 1);
                        this.game.systems.ui.notify(`Received ${choice.itemId}!`, 'item');
                        break;

                    case 'start_spar':
                        this.game.systems.ui.notify('Sparring coming soon!', 'combat');
                        break;
                }
            }

            showMessage(message) {
                const box = document.getElementById('dialogueBox');
                const portrait = document.getElementById('dialoguePortrait');
                const name = document.getElementById('dialogueName');
                const title = document.getElementById('dialogueTitle');
                const text = document.getElementById('dialogueText');
                const choices = document.getElementById('dialogueChoices');

                portrait.textContent = 'üí≠';
                name.textContent = 'Observation';
                title.textContent = '';
                text.textContent = message;

                choices.innerHTML = '';
                const btn = document.createElement('div');
                btn.className = 'dialogue-choice';
                btn.textContent = 'Continue';
                btn.addEventListener('click', () => this.close());
                choices.appendChild(btn);

                box.style.display = 'block';
                this.game.state = GameState.DIALOGUE;
            }

            close() {
                document.getElementById('dialogueBox').style.display = 'none';
                this.currentNPC = null;
                this.currentDialogue = null;
                this.game.state = GameState.PLAYING;
            }
        }

        // ==================== QUEST SYSTEM ====================
        class QuestSystem {
            constructor(game) {
                this.game = game;
                this.quests = [];
                this.activeQuests = [];
                this.completedQuests = [];
            }

            initialize() {
                this.quests = [
                    {
                        id: 'main_seal_fragment',
                        title: 'The First Seal',
                        description: 'Retrieve the Seal Fragment from the Ancient Ruins in the Forest of Whispers.',
                        type: 'main',
                        objectives: [
                            { type: 'kill', target: 'forest_guardian', count: 1, current: 0, desc: 'Defeat the Forest Guardian' },
                            { type: 'collect', target: 'seal_fragment', count: 1, current: 0, desc: 'Collect the Seal Fragment' }
                        ],
                        rewards: { exp: 500, gold: 200, items: ['rare_sword'] },
                        unlocked: false
                    },
                    {
                        id: 'learn_alchemy',
                        title: 'Alchemist Apprentice',
                        description: 'Gather materials for Yuki to learn alchemy basics.',
                        type: 'side',
                        objectives: [
                            { type: 'collect', target: 'healing_herb', count: 10, current: 0, desc: 'Collect Healing Herbs (0/10)' },
                            { type: 'collect', target: 'mana_crystal', count: 5, current: 0, desc: 'Collect Mana Crystals (0/5)' }
                        ],
                        rewards: { exp: 150, gold: 50, skills: ['basic_alchemy'] },
                        unlocked: false
                    },
                    {
                        id: 'well_mystery',
                        title: 'Whispers in the Well',
                        description: 'Investigate the mysterious disappearances near the village well.',
                        type: 'hidden',
                        objectives: [
                            { type: 'interact', target: 'well_night', count: 1, current: 0, desc: 'Visit the well at night' },
                            { type: 'kill', target: 'well_spirit', count: 1, current: 0, desc: 'Defeat the Well Spirit' }
                        ],
                        rewards: { exp: 300, gold: 150, items: ['spirit_lantern'] },
                        unlocked: false
                    },
                    {
                        id: 'slime_slayer',
                        title: 'Slime Slayer',
                        description: 'Clear out the slimes infesting the forest edge.',
                        type: 'side',
                        objectives: [
                            { type: 'kill', target: 'slime', count: 10, current: 0, desc: 'Defeat Slimes (0/10)' }
                        ],
                        rewards: { exp: 100, gold: 30 },
                        unlocked: true
                    },
                    {
                        id: 'wolf_hunter',
                        title: 'Wolf Hunter',
                        description: 'Thin the shadow wolf population threatening travelers.',
                        type: 'side',
                        objectives: [
                            { type: 'kill', target: 'wolf', count: 5, current: 0, desc: 'Defeat Shadow Wolves (0/5)' }
                        ],
                        rewards: { exp: 200, gold: 75 },
                        unlocked: true
                    }
                ];

                // Auto-accept starting quest
                this.acceptQuest('slime_slayer');
                this.updateQuestUI();
            }

            acceptQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (!quest || this.activeQuests.includes(quest) || this.completedQuests.includes(quest)) {
                    return false;
                }

                quest.unlocked = true;
                this.activeQuests.push(quest);
                this.updateQuestUI();
                return true;
            }

            unlockQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (quest) {
                    quest.unlocked = true;
                }
            }

            updateKillProgress(enemyType) {
                this.activeQuests.forEach(quest => {
                    quest.objectives.forEach(obj => {
                        if (obj.type === 'kill' && obj.target === enemyType && obj.current < obj.count) {
                            obj.current++;
                            obj.desc = obj.desc.replace(/\(\d+\/\d+\)/, `(${obj.current}/${obj.count})`);
                            
                            if (obj.current >= obj.count) {
                                this.game.systems.ui.notify(`Objective complete: ${obj.desc}`, 'quest');
                            }

                            this.checkQuestCompletion(quest);
                        }
                    });
                });
                this.updateQuestUI();
            }

            updateCollectProgress(itemId) {
                this.activeQuests.forEach(quest => {
                    quest.objectives.forEach(obj => {
                        if (obj.type === 'collect' && obj.target === itemId && obj.current < obj.count) {
                            obj.current++;
                            obj.desc = obj.desc.replace(/\(\d+\/\d+\)/, `(${obj.current}/${obj.count})`);
                            
                            if (obj.current >= obj.count) {
                                this.game.systems.ui.notify(`Objective complete: ${obj.desc}`, 'quest');
                            }

                            this.checkQuestCompletion(quest);
                        }
                    });
                });
                this.updateQuestUI();
            }

            checkQuestCompletion(quest) {
                const allComplete = quest.objectives.every(obj => obj.current >= obj.count);
                
                if (allComplete) {
                    this.completeQuest(quest);
                }
            }

            completeQuest(quest) {
                // Remove from active
                const index = this.activeQuests.indexOf(quest);
                if (index > -1) {
                    this.activeQuests.splice(index, 1);
                }

                // Add to completed
                this.completedQuests.push(quest);

                // Grant rewards
                if (quest.rewards.exp) {
                    this.game.systems.player.gainExp(quest.rewards.exp);
                }
                if (quest.rewards.gold) {
                    this.game.systems.player.stats.gold += quest.rewards.gold;
                }
                if (quest.rewards.items) {
                    quest.rewards.items.forEach(item => {
                        this.game.systems.inventory.addItem(item, 1);
                    });
                }

                this.game.systems.ui.notify(`Quest Complete: ${quest.title}!`, 'quest');
                this.game.systems.player.updateUI();
                this.updateQuestUI();
            }

            updateQuestUI() {
                const container = document.getElementById('questList');
                container.innerHTML = '';

                this.activeQuests.forEach(quest => {
                    const questDiv = document.createElement('div');
                    questDiv.className = `quest-item ${quest.type}`;
                    
                    const totalObjectives = quest.objectives.length;
                    const completedObjectives = quest.objectives.filter(o => o.current >= o.count).length;
                    const progress = (completedObjectives / totalObjectives) * 100;

                    questDiv.innerHTML = `
                        <div class="quest-title">${quest.title}</div>
                        <div class="quest-desc">${quest.description}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${progress}%"></div>
                        </div>
                    `;

                    questDiv.addEventListener('click', () => {
                        // Could show detailed quest info
                        let details = quest.objectives.map(o => o.desc).join('\n');
                        console.log(`Quest: ${quest.title}\n${details}`);
                    });

                    container.appendChild(questDiv);
                });
            }
        }

        // ==================== INVENTORY SYSTEM ====================
        class InventorySystem {
            constructor(game) {
                this.game = game;
                this.items = {};
                this.maxSlots = 40;
                this.hotbar = new Array(8).fill(null);
            }

            addItem(itemId, quantity = 1) {
                if (!this.items[itemId]) {
                    this.items[itemId] = 0;
                }
                this.items[itemId] += quantity;

                // Update quest progress
                this.game.systems.quest.updateCollectProgress(itemId);

                return true;
            }

            removeItem(itemId, quantity = 1) {
                if (!this.items[itemId] || this.items[itemId] < quantity) {
                    return false;
                }
                this.items[itemId] -= quantity;
                if (this.items[itemId] <= 0) {
                    delete this.items[itemId];
                }
                return true;
            }

            hasItem(itemId, quantity = 1) {
                return this.items[itemId] && this.items[itemId] >= quantity;
            }

            getItemCount(itemId) {
                return this.items[itemId] || 0;
            }

            useItem(itemId) {
                const itemEffects = {
                    health_potion: () => {
                        this.game.systems.player.heal(50);
                        return true;
                    },
                    greater_health_potion: () => {
                        this.game.systems.player.heal(150);
                        return true;
                    },
                    mana_potion: () => {
                        const player = this.game.systems.player;
                        player.stats.mana = Math.min(player.stats.mana + 30, player.stats.maxMana);
                        player.updateUI();
                        return true;
                    },
                    stamina_elixir: () => {
                        const player = this.game.systems.player;
                        player.stats.stamina = player.stats.maxStamina;
                        player.updateUI();
                        return true;
                    }
                };

                if (itemEffects[itemId] && this.hasItem(itemId)) {
                    if (itemEffects[itemId]()) {
                        this.removeItem(itemId);
                        return true;
                    }
                }
                return false;
            }
        }

        // ==================== UI SYSTEM ====================
        class UISystem {
            constructor(game) {
                this.game = game;
                this.minimapCtx = null;
                this.skillMenuOpen = false;
                this.shakeIntensity = 0;
                this.shakeDecay = 5;
            }

            update(dt) {
                this.updateMinimap();
                
                // Screen shake decay
                if (this.shakeIntensity > 0) {
                    this.shakeIntensity -= this.shakeDecay * dt;
                    if (this.shakeIntensity < 0) this.shakeIntensity = 0;
                    this.applyScreenShake();
                }
            }

            updateMinimap() {
                if (!this.minimapCtx) {
                    const canvas = document.getElementById('minimapCanvas');
                    if (canvas) {
                        this.minimapCtx = canvas.getContext('2d');
                    }
                }

                if (!this.minimapCtx || !this.game.player) return;

                const ctx = this.minimapCtx;
                const size = 180;
                const scale = 0.5;

                // Clear
                ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                ctx.fill();

                const playerPos = this.game.player.getPosition();
                const centerX = size / 2;
                const centerY = size / 2;

                // Draw NPCs
                ctx.fillStyle = '#00ffff';
                this.game.entities.npcs.forEach(npc => {
                    const pos = npc.entity.getPosition();
                    const dx = (pos.x - playerPos.x) * scale;
                    const dz = (pos.z - playerPos.z) * scale;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < size / 2 - 5) {
                        ctx.beginPath();
                        ctx.arc(centerX + dx, centerY + dz, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw enemies
                ctx.fillStyle = '#ff4444';
                this.game.entities.enemies.forEach(enemy => {
                    if (enemy.data.isDead) return;
                    
                    const pos = enemy.entity.getPosition();
                    const dx = (pos.x - playerPos.x) * scale;
                    const dz = (pos.z - playerPos.z) * scale;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < size / 2 - 5) {
                        ctx.beginPath();
                        ctx.arc(centerX + dx, centerY + dz, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw interactables
                ctx.fillStyle = '#ffd700';
                this.game.entities.interactables.forEach(obj => {
                    if (obj.type === 'chest' || obj.type === 'shrine') {
                        const pos = obj.entity.getPosition();
                        const dx = (pos.x - playerPos.x) * scale;
                        const dz = (pos.z - playerPos.z) * scale;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < size / 2 - 5) {
                            ctx.fillRect(centerX + dx - 2, centerY + dz - 2, 4, 4);
                        }
                    }
                });

                // Draw border
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2 - 1, 0, Math.PI * 2);
                ctx.stroke();
            }

            notify(message, type = 'item') {
                const container = document.getElementById('notifications');
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                container.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3500);
            }

            showDamageNumber(amount, position, type = 'enemy') {
                const div = document.createElement('div');
                div.className = `damage-number ${type}`;
                div.textContent = type === 'heal' ? `+${amount}` : `-${amount}`;

                // Convert 3D position to screen position
                const camera = this.game.camera;
                if (!camera) return;

                const pos3D = position.clone ? position.clone() : new pc.Vec3(position.x, position.y, position.z);
                pos3D.y += 2;

                // Simple projection (approximate)
                const camPos = camera.getPosition();
                const dx = pos3D.x - camPos.x;
                const dy = pos3D.y - camPos.y;
                const dz = pos3D.z - camPos.z;
                
                // Very basic screen projection
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 1) return;

                const screenX = window.innerWidth / 2 + (dx / dist) * 200;
                const screenY = window.innerHeight / 2 - dy * 30 + Math.random() * 40 - 20;

                div.style.left = screenX + 'px';
                div.style.top = screenY + 'px';

                document.body.appendChild(div);

                setTimeout(() => {
                    div.remove();
                }, 1000);
            }

            screenShake(intensity) {
                this.shakeIntensity = intensity;
            }

            applyScreenShake() {
                const canvas = document.getElementById('application-canvas');
                if (canvas && this.shakeIntensity > 0) {
                    const offsetX = (Math.random() - 0.5) * this.shakeIntensity * 20;
                    const offsetY = (Math.random() - 0.5) * this.shakeIntensity * 20;
                    canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                } else if (canvas) {
                    canvas.style.transform = '';
                }
            }

            toggleSkillMenu() {
                const menu = document.getElementById('skillMenu');
                this.skillMenuOpen = !this.skillMenuOpen;
                menu.style.display = this.skillMenuOpen ? 'block' : 'none';

                if (this.skillMenuOpen) {
                    this.populateSkillMenu();
                    this.game.state = GameState.PAUSED;
                } else {
                    this.game.state = GameState.PLAYING;
                }
            }

            populateSkillMenu() {
                const grid = document.getElementById('skillGrid');
                grid.innerHTML = '';

                const skills = [
                    { id: 'power_strike', name: 'Power Strike', icon: '‚öîÔ∏è', cost: 2, unlocked: true },
                    { id: 'whirlwind', name: 'Whirlwind', icon: 'üå™Ô∏è', cost: 3, unlocked: false },
                    { id: 'heal', name: 'Heal', icon: 'üíö', cost: 2, unlocked: false },
                    { id: 'fireball', name: 'Fireball', icon: 'üî•', cost: 3, unlocked: false },
                    { id: 'ice_spike', name: 'Ice Spike', icon: '‚ùÑÔ∏è', cost: 3, unlocked: false },
                    { id: 'lightning', name: 'Lightning', icon: '‚ö°', cost: 4, unlocked: false },
                    { id: 'shadow_step', name: 'Shadow Step', icon: 'üë§', cost: 4, unlocked: false },
                    { id: 'summon', name: 'Summon Beast', icon: 'üê∫', cost: 5, unlocked: false }
                ];

                const playerSP = this.game.systems.player.stats.skillPoints;

                skills.forEach(skill => {
                    const node = document.createElement('div');
                    node.className = `skill-node ${skill.unlocked ? 'unlocked' : (playerSP >= skill.cost ? '' : 'locked')}`;
                    node.innerHTML = `
                        <div class="skill-icon">${skill.icon}</div>
                        <div class="skill-name">${skill.name}</div>
                        <div class="skill-cost">${skill.unlocked ? 'Learned' : skill.cost + ' SP'}</div>
                    `;

                    if (!skill.unlocked && playerSP >= skill.cost) {
                        node.addEventListener('click', () => {
                            this.game.systems.player.stats.skillPoints -= skill.cost;
                            skill.unlocked = true;
                            this.game.systems.player.unlockedSkills.push(skill.id);
                            this.notify(`Learned ${skill.name}!`, 'level');
                            this.populateSkillMenu();
                            this.game.systems.player.updateUI();
                        });
                    }

                    grid.appendChild(node);
                });

                // Close button handler
                document.getElementById('closeSkillMenu').onclick = () => this.toggleSkillMenu();
            }
        }

        // ==================== AUDIO SYSTEM ====================
        class AudioSystem {
            constructor(game) {
                this.game = game;
                this.sounds = {};
                this.musicVolume = 0.5;
                this.sfxVolume = 0.7;
                this.currentMusic = null;
            }

            playSound(soundId) {
                // Would play sound effects
                console.log(`Playing sound: ${soundId}`);
            }

            playMusic(musicId) {
                // Would play background music
                console.log(`Playing music: ${musicId}`);
            }

            stopMusic() {
                if (this.currentMusic) {
                    this.currentMusic = null;
                }
            }
        }

        // ==================== PARTICLE SYSTEM ====================
        class ParticleSystem {
            constructor(game) {
                this.game = game;
                this.particles = [];
            }

            update(dt) {
                // Update and remove dead particles
                this.particles = this.particles.filter(particle => {
                    particle.life -= dt;
                    if (particle.life <= 0) {
                        if (particle.entity && particle.entity.parent) {
                            this.game.app.root.removeChild(particle.entity);
                            particle.entity.destroy();
                        }
                        return false;
                    }

                    // Update particle position
                    if (particle.entity && particle.velocity) {
                        const pos = particle.entity.getPosition();
                        pos.add(particle.velocity.clone().mulScalar(dt));
                        particle.entity.setPosition(pos);
                        
                        // Fade out
                        const alpha = particle.life / particle.maxLife;
                        particle.entity.setLocalScale(alpha, alpha, alpha);
                    }

                    return true;
                });
            }

            createHitEffect(position) {
                for (let i = 0; i < 8; i++) {
                    const particle = new pc.Entity('HitParticle');
                    particle.addComponent('render', { type: 'sphere' });
                    particle.setLocalScale(0.15, 0.15, 0.15);
                    particle.setPosition(position.x, position.y + 1, position.z);

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = new pc.Color(1, 0.8, 0.2);
                    mat.emissive = new pc.Color(0.5, 0.4, 0.1);
                    mat.update();
                    particle.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(particle);

                    const angle = (i / 8) * Math.PI * 2;
                    const speed = 3 + Math.random() * 2;

                    this.particles.push({
                        entity: particle,
                        velocity: new pc.Vec3(
                            Math.cos(angle) * speed,
                            2 + Math.random() * 2,
                            Math.sin(angle) * speed
                        ),
                        life: 0.5,
                        maxLife: 0.5
                    });
                }
            }

            createDeathEffect(position) {
                for (let i = 0; i < 15; i++) {
                    const particle = new pc.Entity('DeathParticle');
                    particle.addComponent('render', { type: 'sphere' });
                    particle.setLocalScale(0.2, 0.2, 0.2);
                    particle.setPosition(
                        position.x + (Math.random() - 0.5) * 2,
                        position.y + 1 + Math.random(),
                        position.z + (Math.random() - 0.5) * 2
                    );

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = new pc.Color(0.5, 0.1, 0.5);
                    mat.emissive = new pc.Color(0.3, 0.05, 0.3);
                    mat.opacity = 0.8;
                    mat.blendType = pc.BLEND_NORMAL;
                    mat.update();
                    particle.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(particle);

                    this.particles.push({
                        entity: particle,
                        velocity: new pc.Vec3(
                            (Math.random() - 0.5) * 3,
                            2 + Math.random() * 3,
                            (Math.random() - 0.5) * 3
                        ),
                        life: 1,
                        maxLife: 1
                    });
                }
            }

            createHealingEffect(position) {
                for (let i = 0; i < 12; i++) {
                    const particle = new pc.Entity('HealParticle');
                    particle.addComponent('render', { type: 'sphere' });
                    particle.setLocalScale(0.1, 0.1, 0.1);
                    
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 1;
                    particle.setPosition(
                        position.x + Math.cos(angle) * radius,
                        position.y + 0.5,
                        position.z + Math.sin(angle) * radius
                    );

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = new pc.Color(0.3, 1, 0.5);
                    mat.emissive = new pc.Color(0.15, 0.5, 0.25);
                    mat.update();
                    particle.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(particle);

                    this.particles.push({
                        entity: particle,
                        velocity: new pc.Vec3(0, 3, 0),
                        life: 1,
                        maxLife: 1
                    });
                }
            }

            createLevelUpEffect(position) {
                // Ring of particles
                for (let i = 0; i < 20; i++) {
                    const particle = new pc.Entity('LevelUpParticle');
                    particle.addComponent('render', { type: 'box' });
                    particle.setLocalScale(0.15, 0.3, 0.15);
                    
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 2;
                    particle.setPosition(
                        position.x + Math.cos(angle) * radius,
                        position.y + 0.5,
                        position.z + Math.sin(angle) * radius
                    );

                    const mat = new pc.StandardMaterial();
                    const hue = i / 20;
                    mat.diffuse = new pc.Color(
                        Math.sin(hue * Math.PI * 2) * 0.5 + 0.5,
                        Math.sin(hue * Math.PI * 2 + 2) * 0.5 + 0.5,
                        Math.sin(hue * Math.PI * 2 + 4) * 0.5 + 0.5
                    );
                    mat.emissive = mat.diffuse.clone().mulScalar(0.5);
                    mat.update();
                    particle.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(particle);

                    this.particles.push({
                        entity: particle,
                        velocity: new pc.Vec3(
                            Math.cos(angle) * 2,
                            5 + Math.random() * 3,
                            Math.sin(angle) * 2
                        ),
                        life: 1.5,
                        maxLife: 1.5
                    });
                }

                // Central burst
                for (let i = 0; i < 10; i++) {
                    const particle = new pc.Entity('LevelUpCore');
                    particle.addComponent('render', { type: 'sphere' });
                    particle.setLocalScale(0.2, 0.2, 0.2);
                    particle.setPosition(position.x, position.y + 1, position.z);

                    const mat = new pc.StandardMaterial();
                    mat.diffuse = new pc.Color(1, 0.85, 0.3);
                    mat.emissive = new pc.Color(0.5, 0.4, 0.15);
                    mat.update();
                    particle.render.meshInstances[0].material = mat;

                    this.game.app.root.addChild(particle);

                    const angle = Math.random() * Math.PI * 2;
                    const upAngle = Math.random() * Math.PI / 2;

                    this.particles.push({
                        entity: particle,
                        velocity: new pc.Vec3(
                            Math.cos(angle) * Math.cos(upAngle) * 4,
                            Math.sin(upAngle) * 6,
                            Math.sin(angle) * Math.cos(upAngle) * 4
                        ),
                        life: 1.2,
                        maxLife: 1.2
                    });
                }
            }
        }

        // ==================== ACHIEVEMENT SYSTEM ====================
        class AchievementSystem {
            constructor(game) {
                this.game = game;
                this.achievements = [];
                this.easterEggs = [];
                this.initAchievements();
            }

            initAchievements() {
                this.achievements = [
                    { id: 'first_blood', name: 'First Blood', desc: 'Defeat your first enemy', icon: '‚öîÔ∏è', unlocked: false },
                    { id: 'level_5', name: 'Rising Hero', desc: 'Reach level 5', icon: '‚≠ê', unlocked: false },
                    { id: 'level_10', name: 'Seasoned Warrior', desc: 'Reach level 10', icon: 'üåü', unlocked: false },
                    { id: 'level_20', name: 'Legendary Hero', desc: 'Reach level 20', icon: '‚ú®', unlocked: false },
                    { id: 'rich', name: 'Wealthy', desc: 'Accumulate 1000 gold', icon: 'üí∞', unlocked: false },
                    { id: 'explorer', name: 'Explorer', desc: 'Discover all areas', icon: 'üó∫Ô∏è', unlocked: false },
                    { id: 'quest_master', name: 'Quest Master', desc: 'Complete 10 quests', icon: 'üìú', unlocked: false }
                ];

                this.easterEggsData = {
                    'wishing_well': { name: 'Wish Maker', desc: 'Threw 10 coins in the well', icon: 'üåü' },
                    'cat_lover': { name: 'Cat Whisperer', desc: 'Befriended Mochi the cat', icon: 'üê±' },
                    'ancient_runes': { name: 'Rune Reader', desc: 'Discovered the Ancient Runestone', icon: 'üìñ' },
                    'sword_in_stone': { name: 'Chosen One', desc: 'Drew the legendary sword', icon: 'üó°Ô∏è' },
                    'waterfall_treasure': { name: 'Treasure Hunter', desc: 'Found the hidden waterfall treasure', icon: 'üíé' },
                    'hidden_passage': { name: 'Secret Finder', desc: 'Discovered a hidden passage', icon: 'üö™' },
                    'mystery_portal': { name: 'Dimension Walker', desc: 'Found the mysterious portal', icon: 'üåÄ' },
                    'sky_treasure': { name: 'Sky Pirate', desc: 'Reached a floating island treasure', icon: '‚òÅÔ∏è' }
                };
            }

            checkLevelAchievements(level) {
                if (level >= 5 && !this.isUnlocked('level_5')) {
                    this.unlock('level_5');
                }
                if (level >= 10 && !this.isUnlocked('level_10')) {
                    this.unlock('level_10');
                }
                if (level >= 20 && !this.isUnlocked('level_20')) {
                    this.unlock('level_20');
                }
            }

            isUnlocked(achievementId) {
                const achievement = this.achievements.find(a => a.id === achievementId);
                return achievement ? achievement.unlocked : false;
            }

            unlock(achievementId) {
                const achievement = this.achievements.find(a => a.id === achievementId);
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.showAchievementPopup(achievement);
                }
            }

            unlockEasterEgg(eggId) {
                if (this.easterEggs.includes(eggId)) return;

                this.easterEggs.push(eggId);
                this.game.easterEggs.push(eggId);

                const eggData = this.easterEggsData[eggId];
                if (eggData) {
                    this.showAchievementPopup({
                        name: `Easter Egg: ${eggData.name}`,
                        desc: eggData.desc,
                        icon: eggData.icon
                    });
                }
            }

            showAchievementPopup(achievement) {
                const popup = document.getElementById('achievementPopup');
                document.getElementById('achievementIcon').textContent = achievement.icon;
                document.getElementById('achievementTitle').textContent = achievement.name;
                document.getElementById('achievementDesc').textContent = achievement.desc;

                popup.classList.add('show');

                setTimeout(() => {
                    popup.classList.remove('show');
                }, 4000);
            }
        }

        // ==================== INITIALIZE GAME ====================
        const game = new SakuraChronicles();

        // Loading tips rotation
        const tips = [
            "Tip: Talk to every NPC - some hold secrets to hidden quests!",
            "Tip: The old well hides a mysterious secret...",
            "Tip: Pet the village cat multiple times for a surprise!",
            "Tip: Some areas are only accessible at certain times.",
            "Tip: Explore off the beaten path to find legendary items!",
            "Tip: The Ancient Runestone holds forgotten knowledge.",
            "Tip: Look for floating islands in the mountains.",
            "Tip: Some NPCs have different dialogue based on your choices."
        ];

        let tipIndex = 0;
        setInterval(() => {
            tipIndex = (tipIndex + 1) % tips.length;
            const tipElement = document.getElementById('loadingTip');
            if (tipElement) {
                tipElement.textContent = tips[tipIndex];
            }
        }, 4000);

        // Start game when DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            game.initialize();
        });

    })();
    </script>
</body>
</html>
