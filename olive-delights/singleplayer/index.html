<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Olive Delights</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #fff; }
        
        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #0f0f23);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 300;
            text-align: center;
        }
        .menu-overlay.hidden { display: none; }
        
        #start-screen h1 { color: #ffd700; font-size: 48px; text-shadow: 0 0 30px #ff8c00; margin-bottom: 10px; }
        #start-screen h2 { color: #ccc; font-size: 20px; margin-bottom: 20px; }
        
        .menu-section { background: rgba(0,0,0,0.5); padding: 15px 25px; border-radius: 8px; margin: 10px auto; text-align: center; max-width: 400px; }
        .menu-section h3 { color: #ffd700; margin-bottom: 10px; }
        .menu-section p, .menu-section label { color: #ddd; font-size: 13px; line-height: 1.6; }
        
        .menu-btn {
            padding: 15px 40px; font-size: 18px; margin: 5px;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white; border: none; cursor: pointer;
            font-family: inherit; border-radius: 4px;
        }
        .menu-btn:hover { transform: scale(1.05); }
        .menu-btn.secondary { background: linear-gradient(135deg, #555, #444); }
        .menu-btn.small { padding: 8px 20px; font-size: 14px; }
        
        .coins-display { color: #ffd700; font-size: 18px; margin: 10px 0; }
        
        .highscores { color: #4ade80; font-size: 14px; }
        .highscores span { display: block; margin: 3px 0; }
        
        .settings-row { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; color: #ddd; gap: 15px; }
        .settings-row select, .settings-row input { background: #333; color: #fff; border: 1px solid #555; padding: 5px 10px; border-radius: 4px; }
        
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px; }
        .shop-item { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center; color: #fff; }
        .shop-item img { width: 48px; height: 48px; image-rendering: pixelated; }
        .shop-item.owned { border: 2px solid #4ade80; }
        .shop-item.selected { border: 2px solid #ffd700; box-shadow: 0 0 10px #ffd700; }
        .shop-item small { color: #ccc; }
        
        .upgrade-item { background: rgba(255,255,255,0.05); padding: 8px; margin: 5px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: #ddd; }
        .upgrade-item.owned { background: rgba(74,222,128,0.2); }
        .upgrade-item span { color: #fff; }
        
        .tab-buttons { display: flex; gap: 5px; margin-bottom: 15px; justify-content: center; }
        .tab-btn { padding: 8px 15px; background: #333; color: #ccc; border: none; cursor: pointer; border-radius: 4px; }
        .tab-btn.active { background: #ff8c00; color: #fff; }
        .tab-content { display: none; max-width: 450px; margin: 0 auto; }
        .tab-content.active { display: block; }
        
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 4px; height: 4px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 4px #fff; }
        
        #stamina-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 200px; height: 8px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; }
        #stamina-bar { height: 100%; width: 100%; background: linear-gradient(90deg, #4ade80, #22c55e); border-radius: 3px; transition: width 0.1s; }
        #stamina-bar.infinite { background: linear-gradient(90deg, #fbbf24, #f59e0b); animation: pulse 0.3s infinite alternate; }
        #stamina-bar.boosted { background: linear-gradient(90deg, #f472b6, #ec4899); }
        @keyframes pulse { from { opacity: 0.7; } to { opacity: 1; } }
        
        #hud-coins { position: absolute; top: 20px; left: 120px; color: #ffd700; font-size: 18px; }
        #timer { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 20px; }
        #floor-indicator { position: absolute; top: 50px; left: 20px; color: #88ccff; font-size: 16px; }
        #-floor { position: absolute; top: 75px; left: 20px; color: #ff8888; font-size: 14px; opacity: 0; }
        #warning { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: #ff4444; font-size: 24px; opacity: 0; text-shadow: 0 0 20px #ff0000; }
        #shield-indicator { position: absolute; top: 140px; left: 50%; transform: translateX(-50%); color: #4ade80; font-size: 18px; opacity: 0; }
        #pickup-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, 50px); color: #4ade80; font-size: 20px; opacity: 0; text-shadow: 0 0 10px #000; transition: opacity 0.3s; }
        
        #escape-hud { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; display: none; }
        #escape-round { color: #4ade80; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #000; }
        #escape-door-indicator { color: #22ff22; font-size: 18px; margin-top: 5px; text-shadow: 0 0 15px #00ff00; animation: doorPulse 1s infinite alternate; }
        #escape-door-indicator.nearby { color: #ffff00; text-shadow: 0 0 20px #ffff00; font-size: 22px; }
        @keyframes doorPulse { from { opacity: 0.7; } to { opacity: 1; } }
        
        #powerups-display { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        .powerup-slot { width: 50px; height: 50px; background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; display: flex; align-items: center; justify-content: center; position: relative; }
        .powerup-slot.active { border-color: #4ade80; box-shadow: 0 0 10px #4ade80; }
        
        #minimap { position: absolute; top: 20px; right: 20px; width: 160px; height: 160px; background: rgba(0,0,0,0.9); border: 2px solid rgba(255,255,255,0.4); border-radius: 4px; }
        #minimap-canvas { width: 100%; height: 100%; }
        #minimap-floor { position: absolute; top: 185px; right: 20px; width: 160px; text-align: center; color: #88ccff; font-size: 12px; background: rgba(0,0,0,0.7); padding: 4px; border-radius: 4px; }
        
        .vignette { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 45; background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%); }
        #fear-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: rgba(100,0,0,0.4); opacity: 0; z-index: 50; }
        #freeze-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: rgba(100,200,255,0.2); opacity: 0; z-index: 48; }
        
        #death-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(80, 0, 0, 0.95); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 200; }
        #death-screen h1 { color: #fff; font-size: 64px; text-shadow: 0 0 30px #ff0000; margin-bottom: 20px; }
        #death-screen p { color: #fcc; font-size: 20px; margin-bottom: 10px; }
        #death-screen .coins-earned { color: #ffd700; font-size: 24px; margin: 15px 0; }
        
        #pause-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 250; }
        #pause-screen h1 { color: #fff; font-size: 48px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="start-screen" class="menu-overlay">
        <h1>ü´í OLIVE DELIGHTS ü´í</h1>
        <h2>Escape the Nextbot</h2>
        
        <div class="coins-display">üí∞ Coins: <span id="total-coins">0</span></div>
        
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="showTab('play')">PLAY</button>
            <button class="tab-btn" onclick="showTab('escape')">ESCAPE</button>
            <button class="tab-btn" onclick="showTab('shop')">SHOP</button>
            <button class="tab-btn" onclick="showTab('upgrades')">UPGRADES</button>
            <button class="tab-btn" onclick="showTab('settings')">SETTINGS</button>
        </div>
        
        <!-- PLAY TAB -->
        <div id="tab-play" class="tab-content active">
            <div class="menu-section">
                <h3>üèÜ TOP 3 RUNS</h3>
                <div class="highscores" id="highscores">
                    <span>1. --:--</span>
                    <span>2. --:--</span>
                    <span>3. --:--</span>
                </div>
            </div>
            
            <div class="menu-section">
                <p><strong>CONTROLS:</strong><br>
                WASD - Move | <span id="sprint-key-display">SHIFT</span> - Sprint | SPACE - Jump<br>
                ESC - Pause Menu</p>
            </div>
            
            <div class="menu-section">
                <label><input type="checkbox" id="start-shield-toggle"> Start with Shield (5 coins)</label>
            </div>
            
            <button class="menu-btn" onclick="startGame()">START GAME</button>
        </div>
        
        <!-- ESCAPE MODE TAB -->
        <div id="tab-escape" class="tab-content">
            <div class="menu-section">
                <h3>üö™ ESCAPE MODE</h3>
                <p>Find the exit door to escape each round!<br>
                How many times can you escape?<br>
                <strong>Map is 2x larger, no minimap!</strong></p>
            </div>
            <div class="menu-section">
                <h3>üèÜ BEST STREAK</h3>
                <div class="highscores">
                    <span id="escape-record">Best: 0 escapes</span>
                </div>
            </div>
            <div class="menu-section">
                <label><input type="checkbox" id="escape-shield-toggle"> Start with Shield (5 coins)</label>
            </div>
            <button class="menu-btn" onclick="startEscapeMode()">START ESCAPE MODE</button>
        </div>
        
        <!-- SHOP TAB -->
        <div id="tab-shop" class="tab-content">
            <div class="menu-section">
                <h3>üé≠ KANYE SKINS</h3>
                <div class="shop-grid" id="skin-shop"></div>
            </div>
        </div>
        
        <!-- UPGRADES TAB -->
        <div id="tab-upgrades" class="tab-content">
            <div class="menu-section">
                <h3>‚ùÑÔ∏è ICE UPGRADES</h3>
                <div id="ice-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>‚ö° SPEED UPGRADES</h3>
                <div id="speed-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>üõ°Ô∏è SHIELD UPGRADES</h3>
                <div id="shield-upgrades"></div>
            </div>
        </div>
        
        <!-- SETTINGS TAB -->
        <div id="tab-settings" class="tab-content">
            <div class="menu-section">
                <h3>‚öôÔ∏è SETTINGS</h3>
                <div class="settings-row">
                    <label>Sprint Key:</label>
                    <select id="sprint-key-select" onchange="updateSprintKey()">
                        <option value="ShiftLeft">Left Shift</option>
                        <option value="ShiftRight">Right Shift</option>
                        <option value="ControlLeft">Left Ctrl</option>
                        <option value="KeyC">C</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label>Mouse Sensitivity:</label>
                    <input type="range" id="sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
                </div>
                <div class="settings-row">
                    <label>Music Volume:</label>
                    <input type="range" id="music-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
                </div>
                <div class="settings-row">
                    <label>Show Minimap:</label>
                    <input type="checkbox" id="minimap-toggle" checked onchange="updateMinimapToggle()">
                </div>
            </div>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="ui">
        <div id="crosshair"></div>
        <div id="stamina-container"><div id="stamina-bar"></div></div>
        <div id="powerups-display">
            <div class="powerup-slot" id="slot-ice"><span style="color:#666;font-size:24px;">‚ùÑÔ∏è</span></div>
            <div class="powerup-slot" id="slot-speed"><span style="color:#666;font-size:24px;">‚ö°</span></div>
            <div class="powerup-slot" id="slot-shield"><span style="color:#666;font-size:24px;">üõ°Ô∏è</span></div>
        </div>
        <div id="warning">‚ö†Ô∏è HE'S CLOSE ‚ö†Ô∏è</div>
        <div id="shield-indicator">üõ°Ô∏è SHIELD ACTIVE</div>
        <div id="timer">0:00</div>

        <div id="hud-coins">üí∞ 0</div>
        <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
        <div id="minimap-floor">Map: Backrooms</div>
        <div id="pickup-msg"></div>
        <div id="escape-hud">
            <div id="escape-round">Round: 1</div>
            <div id="escape-door-indicator">üö™ FIND THE EXIT!</div>
        </div>
    </div>
    
    <div class="vignette"></div>
    <div id="fear-overlay"></div>
    <div id="freeze-overlay"></div>

    <!-- PAUSE SCREEN -->
    <div id="pause-screen">
        <h1>‚è∏Ô∏è PAUSED</h1>
        <div class="menu-section">
            <div class="settings-row">
                <label>Music Volume:</label>
                <input type="range" id="pause-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
            </div>
            <div class="settings-row">
                <label>Sensitivity:</label>
                <input type="range" id="pause-sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
            </div>
        </div>
        <button class="menu-btn" onclick="resumeGame()">RESUME</button>
        <button class="menu-btn secondary" onclick="quitGame()">QUIT (Lose Coins)</button>
    </div>

    <!-- DEATH SCREEN -->
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Kanye caught you...</p>
        <p id="survival-time">Survived: 0:00</p>
        <p class="coins-earned" id="coins-earned">+0 coins</p>
        <button class="menu-btn" onclick="restartGame()">TRY AGAIN</button>
        <button class="menu-btn secondary" onclick="returnToMenu()">MAIN MENU</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============ SAVE DATA ============
        let saveData = {
            coins: 0,
            highscores: [],
            escapeRecord: 0,
            ownedSkins: ['default'],
            selectedSkin: 'default',
            upgrades: { ice: 0, speed: 0, shield: 0 },
            settings: { sprintKey: 'ShiftLeft', sensitivity: 5, musicVolume: 100, minimapEnabled: true }
        };

        function loadSaveData() {
            try {
                const saved = localStorage.getItem('oliveDelights');
                if (saved) saveData = { ...saveData, ...JSON.parse(saved) };
            } catch(e) {}
            updateUI();
        }

        function saveSaveData() {
            try { localStorage.setItem('oliveDelights', JSON.stringify(saveData)); } catch(e) {}
        }

        // ============ SHOP DATA ============
        const SKINS = [
            { id: 'default', name: 'Classic Kanye', url: 'https://joercat.github.io/kanye.png', cost: 0 },
            { id: 'kanye2', name: 'Weird Kanye', url: 'https://joercat.github.io/kanye2.png', cost: 50 },
            { id: 'kanye3', name: 'Anime Kanye', url: 'https://joercat.github.io/kanye3.png', cost: 45 },
            { id: 'kanye4', name: 'Christmas Kanye', url: 'https://joercat.github.io/kanye4.png', cost: 55 },
            { id: 'kanye5', name: 'Fih', url: 'https://joercat.github.io/kanye5.png', cost: 50 },
            { id: 'kanye6', name: 'Obunga', url: 'https://joercat.github.io/kanye4.png', cost: 50 }
        ];

        const UPGRADES = {
            ice: [
                { level: 1, cost: 10, desc: '+1 sec freeze' },
                { level: 2, cost: 15, desc: '+3 sec freeze' },
                { level: 3, cost: 25, desc: '+3 sec freeze + 3 sec half speed' }
            ],
            speed: [
                { level: 1, cost: 10, desc: '+3 sec duration' },
                { level: 2, cost: 15, desc: '+5 sec duration' },
                { level: 3, cost: 25, desc: '+5 sec + speed boost' }
            ],
            shield: [
                { level: 1, cost: 10, desc: '+1 sec freeze on block' },
                { level: 2, cost: 15, desc: '+2 sec freeze on block' },
                { level: 3, cost: 25, desc: '2 hits + 2 sec freeze' }
            ]
        };

        // ============ GAME STATE ============
        let gameStarted = false;
        let isPaused = false;
        let isDead = false;
        let startTime = 0;
        let sessionCoins = 0;
        let sprintKeyCode = 'ShiftLeft';
        let mouseSensitivity = 0.002;
        let musicVolumeMultiplier = 1;
        
        // Escape mode variables
        let isEscapeMode = false;
        let escapeRound = 0;
        let escapeDoor = null;
        let decorations = [];
        let baseGridSize = 25;

        // ============ THREE.JS ============
        let scene, camera, renderer;
        let wallTexture, floorTexture;

        // ============ PLAYER ============
        const player = {
            x: 0, y: 1.6, z: 0,
            yaw: 0, pitch: 0,
            onGround: true, vy: 0,
            shieldHits: 0,
            infiniteStamina: false,
            infiniteStaminaTimer: 0,
            speedBoost: false,
            speedBoostTimer: 0
        };

        // ============ KANYE ============
        const kanye = {
            x: 0, z: 0, y: 1.25, vx: 0, vz: 0,
            sprite: null, pathTimer: 0,
            path: [], pathIndex: 0,
            frozen: false, frozenTimer: 0,
            halfSpeed: false, halfSpeedTimer: 0,
            turnSpeed: 3.5, maxSpeed: 7.5,
            currentSkinUrl: '',
            floor: 1,
            targetFloor: 1
        };

        // ============ ENTITIES ============
        const powerups = [];
        const coins = [];
        const POWERUP_TYPES = ['ice', 'speed', 'shield'];

        // ============ INPUT ============
        const keys = {};
        let isLocked = false;
        let stamina = 100;
        let isSprinting = false;

        // ============ AUDIO ============
        let audioCtx, audioBuffer, audioSource, gainNode;
        let audioReady = false;
        let audioPlaying = false;

        // ============ MAP CONFIG ============
        const CELL = 4;
        let GRID_SIZE = 25;
        const WALL_H = 3.5;
        const FLOOR_HEIGHT = WALL_H + 0.5;

        let maze = [];
        let walkableCells = [];
        let currentMap = 'backrooms'; // 'backrooms', 'warehouse', 'hospital'

        const textureLoader = new THREE.TextureLoader();

        // ============ UI FUNCTIONS ============
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tab-' + tabId).classList.add('active');
            event.target.classList.add('active');
        }

        function updateUI() {
            document.getElementById('total-coins').textContent = saveData.coins;
            document.getElementById('sprint-key-display').textContent = 
                saveData.settings.sprintKey.replace('ShiftLeft', 'SHIFT').replace('ShiftRight', 'R-SHIFT')
                .replace('ControlLeft', 'CTRL').replace('KeyC', 'C');
            
            // Highscores
            const hsDiv = document.getElementById('highscores');
            hsDiv.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const time = saveData.highscores[i];
                const span = document.createElement('span');
                if (time) {
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    span.textContent = `${i + 1}. ${mins}:${secs.toString().padStart(2, '0')}`;
                } else {
                    span.textContent = `${i + 1}. --:--`;
                }
                hsDiv.appendChild(span);
            }
            
            // Skins shop
            const skinShop = document.getElementById('skin-shop');
            skinShop.innerHTML = '';
            SKINS.forEach(skin => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (saveData.ownedSkins.includes(skin.id)) div.classList.add('owned');
                if (saveData.selectedSkin === skin.id) div.classList.add('selected');
                div.innerHTML = `<img src="${skin.url}"><br><small>${skin.name}</small><br>`;
                if (!saveData.ownedSkins.includes(skin.id)) {
                    div.innerHTML += `<button class="menu-btn small" onclick="buySkin('${skin.id}')">${skin.cost} üí∞</button>`;
                } else if (saveData.selectedSkin !== skin.id) {
                    div.innerHTML += `<button class="menu-btn small" onclick="selectSkin('${skin.id}')">SELECT</button>`;
                } else {
                    div.innerHTML += `<small style="color:#4ade80;">EQUIPPED</small>`;
                }
                skinShop.appendChild(div);
            });
            
            // Upgrades
            ['ice', 'speed', 'shield'].forEach(type => {
                const container = document.getElementById(type + '-upgrades');
                container.innerHTML = '';
                UPGRADES[type].forEach((upg, idx) => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    if (saveData.upgrades[type] >= upg.level) div.classList.add('owned');
                    div.innerHTML = `<span>Lv${upg.level}: ${upg.desc}</span>`;
                    if (saveData.upgrades[type] >= upg.level) {
                        div.innerHTML += `<span style="color:#4ade80;">‚úì</span>`;
                    } else if (saveData.upgrades[type] === upg.level - 1) {
                        div.innerHTML += `<button class="menu-btn small" onclick="buyUpgrade('${type}', ${upg.level})">${upg.cost} üí∞</button>`;
                    } else {
                        div.innerHTML += `<span style="color:#666;">üîí</span>`;
                    }
                    container.appendChild(div);
                });
            });
            
            // Settings
            document.getElementById('sprint-key-select').value = saveData.settings.sprintKey;
            document.getElementById('sensitivity').value = saveData.settings.sensitivity;
            document.getElementById('music-volume').value = saveData.settings.musicVolume;
            document.getElementById('minimap-toggle').checked = saveData.settings.minimapEnabled !== false;
            
            sprintKeyCode = saveData.settings.sprintKey;
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            
            // Apply minimap visibility
            const minimapVisible = saveData.settings.minimapEnabled !== false;
            document.getElementById('minimap').style.display = minimapVisible ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = minimapVisible ? 'block' : 'none';
            
            // Update escape record
            document.getElementById('escape-record').textContent = 'Best: ' + saveData.escapeRecord + ' escapes';
        }

        function buySkin(skinId) {
            const skin = SKINS.find(s => s.id === skinId);
            if (skin && saveData.coins >= skin.cost && !saveData.ownedSkins.includes(skinId)) {
                saveData.coins -= skin.cost;
                saveData.ownedSkins.push(skinId);
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function selectSkin(skinId) {
            if (saveData.ownedSkins.includes(skinId)) {
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function buyUpgrade(type, level) {
            const upg = UPGRADES[type].find(u => u.level === level);
            if (upg && saveData.coins >= upg.cost && saveData.upgrades[type] === level - 1) {
                saveData.coins -= upg.cost;
                saveData.upgrades[type] = level;
                saveSaveData();
                updateUI();
            }
        }

        function updateSprintKey() {
            saveData.settings.sprintKey = document.getElementById('sprint-key-select').value;
            sprintKeyCode = saveData.settings.sprintKey;
            saveSaveData();
            updateUI();
        }

        function updateSensitivity() {
            const val = document.getElementById('sensitivity').value || document.getElementById('pause-sensitivity').value;
            saveData.settings.sensitivity = parseInt(val);
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            saveSaveData();
        }

        function updateMusicVolume() {
            const val = document.getElementById('music-volume').value || document.getElementById('pause-volume').value;
            saveData.settings.musicVolume = parseInt(val);
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            saveSaveData();
        }

        function updateMinimapToggle() {
            saveData.settings.minimapEnabled = document.getElementById('minimap-toggle').checked;
            saveSaveData();
            document.getElementById('minimap').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
        }

        // ============ TEXTURES ============
        function loadTextures(callback) {
            let loaded = 0;
            const checkDone = () => { loaded++; if (loaded === 2) callback(); };

            wallTexture = textureLoader.load('https://joercat.github.io/wall.png', checkDone, undefined, checkDone);
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;

            floorTexture = textureLoader.load('https://joercat.github.io/floor.jpg', checkDone, undefined, checkDone);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(GRID_SIZE * 2, GRID_SIZE * 2);
        }

        // ============ AUDIO ============
        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioCtx.createGain();
                gainNode.gain.value = 0;
                gainNode.connect(audioCtx.destination);
                
                const resp = await fetch('https://joercat.github.io/olive.wav');
                const buf = await resp.arrayBuffer();
                audioBuffer = await audioCtx.decodeAudioData(buf);
                audioReady = true;
            } catch(e) { console.log('Audio failed:', e); }
        }

        function setAudioVolume(vol) {
            if (!audioReady) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            // Don't play audio if paused
            if (isPaused) {
                if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                return;
            }
            
            if (!audioPlaying && vol > 0) {
                audioSource = audioCtx.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.loop = true;
                audioSource.connect(gainNode);
                audioSource.start();
                audioPlaying = true;
            }
            
            const finalVol = Math.min(1, vol * musicVolumeMultiplier);
            if (gainNode) gainNode.gain.setTargetAtTime(finalVol, audioCtx.currentTime, 0.1);
        }

        function stopAudio() {
            if (audioSource) { try { audioSource.stop(); } catch(e) {} audioSource = null; audioPlaying = false; }
            if (gainNode) gainNode.gain.value = 0;
        }
        
        function pauseAudio() {
            if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        }

        // ============ MAZE GENERATION ============
        function generateMaze() {
            maze = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                maze[x] = [];
                for (let z = 0; z < GRID_SIZE; z++) {
                    maze[x][z] = 1;
                }
            }

            // Warehouse is open arena with minimal walls
            if (currentMap === 'warehouse') {
                // Clear interior - only outer walls remain
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    for (let z = 1; z < GRID_SIZE - 1; z++) {
                        maze[x][z] = 0;
                    }
                }
                // Add sparse random pillars/walls (8% coverage)
                for (let x = 3; x < GRID_SIZE - 3; x += 4) {
                    for (let z = 3; z < GRID_SIZE - 3; z += 4) {
                        if (Math.random() < 0.35) {
                            maze[x][z] = 1;
                            // Sometimes extend into small wall segment
                            if (Math.random() < 0.3 && x + 1 < GRID_SIZE - 2) maze[x+1][z] = 1;
                            if (Math.random() < 0.3 && z + 1 < GRID_SIZE - 2) maze[x][z+1] = 1;
                        }
                    }
                }
            } else {
                // Normal maze generation for backrooms and hospital
                const stack = [];
                maze[1][1] = 0;
                stack.push({x: 1, z: 1});

                while (stack.length > 0) {
                    const cur = stack[stack.length - 1];
                    const dirs = [{dx: 0, dz: -2}, {dx: 0, dz: 2}, {dx: -2, dz: 0}, {dx: 2, dz: 0}];
                    
                    for (let i = dirs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                    }

                    let found = false;
                    for (const d of dirs) {
                        const nx = cur.x + d.dx;
                        const nz = cur.z + d.dz;
                        
                        if (nx > 0 && nx < GRID_SIZE - 1 && nz > 0 && nz < GRID_SIZE - 1 && maze[nx][nz] === 1) {
                            maze[cur.x + d.dx / 2][cur.z + d.dz / 2] = 0;
                            maze[nx][nz] = 0;
                            stack.push({x: nx, z: nz});
                            found = true;
                            break;
                        }
                    }
                    if (!found) stack.pop();
                }

                // Add extra openings for variety
                for (let x = 2; x < GRID_SIZE - 2; x++) {
                    for (let z = 2; z < GRID_SIZE - 2; z++) {
                        if (maze[x][z] === 1 && Math.random() < 0.2) {
                            let floors = 0;
                            if (maze[x-1][z] === 0) floors++;
                            if (maze[x+1][z] === 0) floors++;
                            if (maze[x][z-1] === 0) floors++;
                            if (maze[x][z+1] === 0) floors++;
                            if (floors >= 2) maze[x][z] = 0;
                        }
                    }
                }
            }

            walkableCells = [];
            for (let x = 1; x < GRID_SIZE - 1; x++) {
                for (let z = 1; z < GRID_SIZE - 1; z++) {
                    if (maze[x][z] === 0) walkableCells.push({x, z});
                }
            }
        }

        // ============ COORDINATE HELPERS ============
        function gridToWorld(gx, gz) {
            return { x: (gx - GRID_SIZE / 2 + 0.5) * CELL, z: (gz - GRID_SIZE / 2 + 0.5) * CELL };
        }

        function worldToGrid(wx, wz) {
            return { x: Math.floor(wx / CELL + GRID_SIZE / 2), z: Math.floor(wz / CELL + GRID_SIZE / 2) };
        }

        function isWalkableWorld(wx, wz, radius = 0.35) {
            const checks = [
                {x: wx, z: wz},
                {x: wx - radius, z: wz - radius},
                {x: wx + radius, z: wz - radius},
                {x: wx - radius, z: wz + radius},
                {x: wx + radius, z: wz + radius}
            ];
            
            for (const c of checks) {
                const g = worldToGrid(c.x, c.z);
                if (g.x < 0 || g.x >= GRID_SIZE || g.z < 0 || g.z >= GRID_SIZE) return false;
                if (!maze[g.x] || maze[g.x][g.z] !== 0) return false;
            }
            
            // Check decoration collisions (skip if player is jumping high enough)
            for (const d of decorations) {
                const dist = Math.hypot(wx - d.x, wz - d.z);
                // Allow jumping over low decorations (height < 1.0)
                const canJumpOver = d.height && d.height < 1.0 && player.y > 2.0;
                if (dist < d.radius + radius && !canJumpOver) return false;
            }
            
            return true;
        }

        function isWalkableGrid(gx, gz) {
            if (gx < 0 || gx >= GRID_SIZE || gz < 0 || gz >= GRID_SIZE) return false;
            if (!maze[gx] || maze[gx][gz] !== 0) return false;
            // Also check if any decoration blocks this grid cell - use larger radius for Kanye
            const worldPos = gridToWorld(gx, gz);
            for (const d of decorations) {
                // Use larger check radius so Kanye paths around decorations with margin
                if (Math.hypot(worldPos.x - d.x, worldPos.z - d.z) < d.radius + 1.0) {
                    return false;
                }
            }
            return true;
        }

        // ============ BUILD WORLD ============
        function buildWorld() {
            // Get map-specific materials and colors
            let wallMat, floorMat, ceilMat, fogColor, ambientColor;
            
            if (currentMap === 'backrooms') {
                // Classic backrooms - yellow walls, carpet floor
                wallMat = new THREE.MeshBasicMaterial({ map: wallTexture });
                floorMat = new THREE.MeshBasicMaterial({ map: floorTexture });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
                fogColor = 0x1a1a1a;
                ambientColor = 0xfff5e0;
            } else if (currentMap === 'warehouse') {
                // Industrial warehouse - gray concrete, metal shelves
                wallMat = new THREE.MeshBasicMaterial({ color: 0x4a4a4a });
                floorMat = new THREE.MeshBasicMaterial({ color: 0x3a3a3a });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                fogColor = 0x0a0a0a;
                ambientColor = 0xcccccc;
            } else if (currentMap === 'hospital') {
                // Abandoned hospital - white/green walls, tile floor
                wallMat = new THREE.MeshBasicMaterial({ color: 0xd4e6d4 });
                floorMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
                ceilMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                fogColor = 0x1a2a1a;
                ambientColor = 0xe0ffe0;
            }
            
            // Update scene fog and background
            scene.background = new THREE.Color(fogColor);
            scene.fog = new THREE.Fog(fogColor, 2, 35);

            // Build walls
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x][z] === 1) {
                        const pos = gridToWorld(x, z);
                        const geo = new THREE.BoxGeometry(CELL, WALL_H, CELL);
                        const wall = new THREE.Mesh(geo, wallMat);
                        wall.position.set(pos.x, WALL_H / 2, pos.z);
                        scene.add(wall);
                    }
                }
            }

            // Ground
            const floorGeo = new THREE.PlaneGeometry(GRID_SIZE * CELL, GRID_SIZE * CELL);
            const floor1 = new THREE.Mesh(floorGeo, floorMat);
            floor1.rotation.x = -Math.PI / 2;
            floor1.position.y = 0.01;
            scene.add(floor1);

            // Ceiling
            const ceiling1 = new THREE.Mesh(floorGeo.clone(), ceilMat);
            ceiling1.rotation.x = Math.PI / 2;
            ceiling1.position.y = WALL_H;
            scene.add(ceiling1);
            
            // Add map-specific decorations
            if (currentMap === 'warehouse') {
                addWarehouseDecorations();
            } else if (currentMap === 'hospital') {
                addHospitalDecorations();
            }
            
            // Add lighting
            scene.add(new THREE.AmbientLight(ambientColor, 0.9));
        }
        
        // Warehouse decorations - crates, barrels, shelving units (ALL SOLID)
        function addWarehouseDecorations() {
            decorations = []; // Clear decorations array
            
            const crateMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const barrelMat = new THREE.MeshBasicMaterial({ color: 0x2255aa });
            const shelfMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            
            // Add random crates and barrels in walkable areas - LESS DENSE
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(25, shuffled.length); // Reduced from 50 to 25
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                // Random offset within cell
                const offsetX = (Math.random() - 0.5) * CELL * 0.3;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.3;
                const finalX = pos.x + offsetX;
                const finalZ = pos.z + offsetZ;
                
                // Skip if too close to existing decoration - INCREASED SPACING
                let tooClose = false;
                for (const d of decorations) {
                    if (Math.hypot(finalX - d.x, finalZ - d.z) < 4.0) { // Increased from 2.0 to 4.0
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;
                
                if (Math.random() < 0.6) {
                    // Crate stack (1-3 crates) - SOLID
                    const stackHeight = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < stackHeight; j++) {
                        const crate = new THREE.Mesh(
                            new THREE.BoxGeometry(1.2, 1.0, 1.2),
                            crateMat
                        );
                        crate.position.set(finalX, 0.5 + j * 1.0, finalZ);
                        scene.add(crate);
                    }
                    // Add to collision array with height (single crate can be jumped over)
                    decorations.push({ x: finalX, z: finalZ, radius: 0.7, height: stackHeight * 1.0 });
                } else {
                    // Barrel - SOLID (can be jumped over)
                    const barrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 1.4, 12),
                        barrelMat
                    );
                    barrel.position.set(finalX, 0.7, finalZ);
                    scene.add(barrel);
                    // Add to collision array - barrels are short enough to jump
                    decorations.push({ x: finalX, z: finalZ, radius: 0.55, height: 1.4 });
                }
            }
            
            // Add tall shelving units along outer walls - SOLID (too tall to jump)
            for (let x = 2; x < GRID_SIZE - 2; x += 3) {
                for (let edge of [1, GRID_SIZE - 2]) {
                    if (maze[x] && maze[x][edge] === 0) {
                        const pos = gridToWorld(x, edge);
                        const shelf = new THREE.Mesh(
                            new THREE.BoxGeometry(2.0, WALL_H * 0.8, 1.0),
                            shelfMat
                        );
                        shelf.position.set(pos.x, WALL_H * 0.4, pos.z);
                        scene.add(shelf);
                        decorations.push({ x: pos.x, z: pos.z, radius: 1.1, height: WALL_H * 0.8 });
                    }
                }
            }
        }
        
        // Hospital decorations - gurneys, medical equipment, debris (ALL SOLID except blood)
        function addHospitalDecorations() {
            decorations = []; // Clear decorations array
            
            const gurneyMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const sheetMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const equipMat = new THREE.MeshBasicMaterial({ color: 0x446688 });
            const bloodMat = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
            
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(20, shuffled.length); // Reduced from 35 to 20
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const offsetX = (Math.random() - 0.5) * CELL * 0.25;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.25;
                const finalX = pos.x + offsetX;
                const finalZ = pos.z + offsetZ;
                
                // Skip if too close to existing decoration - INCREASED SPACING
                let tooClose = false;
                for (const d of decorations) {
                    if (Math.hypot(finalX - d.x, finalZ - d.z) < 4.5) { // Increased from 2.5 to 4.5
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;
                
                const type = Math.random();
                
                if (type < 0.35) {
                    // Gurney with sheet - SOLID
                    const gurneyGroup = new THREE.Group();
                    
                    // Frame
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 0.1, 2.2),
                        gurneyMat
                    );
                    frame.position.y = 0.7;
                    gurneyGroup.add(frame);
                    
                    // Legs
                    for (let lx = -0.4; lx <= 0.4; lx += 0.8) {
                        for (let lz = -0.9; lz <= 0.9; lz += 1.8) {
                            const leg = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.7, 0.1),
                                gurneyMat
                            );
                            leg.position.set(lx, 0.35, lz);
                            gurneyGroup.add(leg);
                        }
                    }
                    
                    // Sheet/mattress
                    const sheet = new THREE.Mesh(
                        new THREE.BoxGeometry(0.9, 0.2, 2.0),
                        sheetMat
                    );
                    sheet.position.y = 0.85;
                    gurneyGroup.add(sheet);
                    
                    const rotation = Math.random() * Math.PI;
                    gurneyGroup.position.set(finalX, 0, finalZ);
                    gurneyGroup.rotation.y = rotation;
                    scene.add(gurneyGroup);
                    
                    // Add collision - gurney is roughly 1x2.2, height ~0.85 (can jump on)
                    decorations.push({ x: finalX, z: finalZ, radius: 1.2, height: 0.85 });
                    
                } else if (type < 0.55) {
                    // Medical equipment (IV stand, monitor) - SOLID
                    const stand = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.2, 1.8, 8),
                        gurneyMat
                    );
                    stand.position.set(finalX, 0.9, finalZ);
                    scene.add(stand);
                    
                    const monitor = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.3, 0.15),
                        equipMat
                    );
                    monitor.position.set(finalX, 1.7, finalZ);
                    scene.add(monitor);
                    
                    decorations.push({ x: finalX, z: finalZ, radius: 0.3, height: 1.8 });
                    
                } else if (type < 0.75) {
                    // Wheelchair - SOLID
                    const wheelchairMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.12, 0.6),
                        wheelchairMat
                    );
                    seat.position.set(finalX, 0.5, finalZ);
                    scene.add(seat);
                    
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.7, 0.12),
                        wheelchairMat
                    );
                    back.position.set(finalX, 0.85, finalZ - 0.25);
                    scene.add(back);
                    
                    // Wheels
                    const wheelMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    for (let wx = -0.35; wx <= 0.35; wx += 0.7) {
                        const wheel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.25, 0.25, 0.05, 12),
                            wheelMat
                        );
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(finalX + wx, 0.25, finalZ);
                        scene.add(wheel);
                    }
                    
                    decorations.push({ x: finalX, z: finalZ, radius: 0.45, height: 0.85 });
                    
                } else {
                    // Blood stain on floor (flat plane) - NOT SOLID (can walk over)
                    const stain = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.6 + Math.random() * 0.6, 0.6 + Math.random() * 0.6),
                        bloodMat
                    );
                    stain.rotation.x = -Math.PI / 2;
                    stain.position.set(finalX, 0.02, finalZ);
                    scene.add(stain);
                    // No collision for blood stains
                }
            }
        }

        // ============ A* PATHFINDING ============
        function findPath(startGx, startGz, endGx, endGz) {
            if (!isWalkableGrid(startGx, startGz) || !isWalkableGrid(endGx, endGz)) return [];

            const key = (x, z) => x * 1000 + z;
            const open = [{x: startGx, z: startGz, g: 0, f: 0}];
            const closed = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            gScore.set(key(startGx, startGz), 0);

            const h = (x, z) => Math.abs(x - endGx) + Math.abs(z - endGz);

            // More iterations for larger maps (escape mode is 2x size)
            const maxIterations = GRID_SIZE > 30 ? 8000 : 3000;
            let iterations = 0;
            while (open.length > 0 && iterations < maxIterations) {
                iterations++;
                
                let bestIdx = 0;
                for (let i = 1; i < open.length; i++) {
                    if (open[i].f < open[bestIdx].f) bestIdx = i;
                }
                const cur = open.splice(bestIdx, 1)[0];
                const curKey = key(cur.x, cur.z);

                if (cur.x === endGx && cur.z === endGz) {
                    const path = [];
                    let k = curKey;
                    while (cameFrom.has(k)) {
                        path.unshift({x: Math.floor(k / 1000), z: k % 1000});
                        k = cameFrom.get(k);
                    }
                    return path;
                }

                closed.add(curKey);

                const neighbors = [
                    {x: cur.x + 1, z: cur.z},
                    {x: cur.x - 1, z: cur.z},
                    {x: cur.x, z: cur.z + 1},
                    {x: cur.x, z: cur.z - 1}
                ];

                for (const n of neighbors) {
                    if (!isWalkableGrid(n.x, n.z)) continue;
                    const nKey = key(n.x, n.z);
                    if (closed.has(nKey)) continue;

                    const tentG = (gScore.get(curKey) || 0) + 1;
                    
                    if (tentG < (gScore.get(nKey) || Infinity)) {
                        cameFrom.set(nKey, curKey);
                        gScore.set(nKey, tentG);
                        const f = tentG + h(n.x, n.z);
                        
                        const existing = open.find(o => o.x === n.x && o.z === n.z);
                        if (!existing) open.push({x: n.x, z: n.z, g: tentG, f: f});
                        else existing.f = f;
                    }
                }
            }
            return [];
        }

        // ============ CREATE KANYE ============
        function createKanye() {
            const skinUrl = SKINS.find(s => s.id === saveData.selectedSkin)?.url || SKINS[0].url;
            kanye.currentSkinUrl = skinUrl;
            
            textureLoader.load(skinUrl, (tex) => {
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                const mat = new THREE.SpriteMaterial({ map: tex });
                kanye.sprite = new THREE.Sprite(mat);
                kanye.sprite.scale.set(2.5, 2.5, 1);
                scene.add(kanye.sprite);
                kanye.sprite.position.set(kanye.x, 1.25, kanye.z);
            });
        }

        // ============ CREATE POWERUPS ============
        function createPowerups() {
            powerups.forEach(p => { if (p.sprite) scene.remove(p.sprite); });
            powerups.length = 0;

            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const urls = {
                ice: 'https://joercat.github.io/ice.png',
                speed: 'https://joercat.github.io/speed.png',
                shield: 'https://joercat.github.io/shield.png'
            };

            for (let i = 0; i < 12 && i < shuffled.length; i++) {
                const type = POWERUP_TYPES[i % 3];
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);

                textureLoader.load(urls[type], (tex) => {
                    tex.magFilter = THREE.NearestFilter;
                    const mat = new THREE.SpriteMaterial({ map: tex });
                    const sprite = new THREE.Sprite(mat);
                    sprite.scale.set(1.2, 1.2, 1);
                    sprite.position.set(pos.x, 0.8, pos.z);
                    scene.add(sprite);
                    
                    powerups.push({ type, x: pos.x, z: pos.z, sprite, collected: false });
                });
            }
        }

        // ============ CREATE COINS ============
        function createCoins() {
            coins.forEach(c => { if (c.sprite) scene.remove(c.sprite); });
            coins.length = 0;
            spawnCoins();
        }

        function spawnCoins() {
            const available = walkableCells.filter(cell => {
                const pos = gridToWorld(cell.x, cell.z);
                return !coins.some(c => !c.collected && Math.hypot(c.x - pos.x, c.z - pos.z) < 2);
            });
            
            const shuffled = available.sort(() => Math.random() - 0.5);
            const toSpawn = 5 - coins.filter(c => !c.collected).length;
            
            for (let i = 0; i < toSpawn && i < shuffled.length; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                textureLoader.load('https://joercat.github.io/coin.png', (tex) => {
                    tex.magFilter = THREE.NearestFilter;
                    const mat = new THREE.SpriteMaterial({ map: tex });
                    const sprite = new THREE.Sprite(mat);
                    sprite.scale.set(0.8, 0.8, 1);
                    sprite.position.set(pos.x, 0.6, pos.z);
                    scene.add(sprite);
                    
                    coins.push({ x: pos.x, z: pos.z, sprite, collected: false });
                });
            }
        }

        // ============ SPAWN ENTITIES ============
        function spawnEntities() {
            if (walkableCells.length < 10) return;

            const pIdx = Math.floor(Math.random() * walkableCells.length);
            const pCell = walkableCells[pIdx];
            const pPos = gridToWorld(pCell.x, pCell.z);
            player.x = pPos.x;
            player.z = pPos.z;
            player.y = 1.6;
            player.yaw = 0;
            player.pitch = 0;
            player.vy = 0;
            player.onGround = true;
            player.shieldHits = 0;
            player.infiniteStamina = false;
            player.speedBoost = false;
            player.floor = 1;

            // Start with shield if purchased
            if (document.getElementById('start-shield-toggle').checked && saveData.coins >= 5) {
                saveData.coins -= 5;
                player.shieldHits = saveData.upgrades.shield >= 3 ? 2 : 1;
                document.getElementById('shield-indicator').style.opacity = '1';
                document.getElementById('slot-shield').classList.add('active');
                saveSaveData();
                updateUI();
            }

            // Find valid spawn for Kanye - at least 5 squares (20 units) from player
            // and must be in a walkable area with no decorations blocking
            const minSpawnDist = 20; // 5 squares * 4 units per cell
            const validKanyeSpawns = walkableCells.filter(c => {
                const pos = gridToWorld(c.x, c.z);
                const distFromPlayer = Math.hypot(pos.x - player.x, pos.z - player.z);
                if (distFromPlayer < minSpawnDist) return false;
                // Check not inside a decoration
                for (const d of decorations) {
                    if (Math.hypot(pos.x - d.x, pos.z - d.z) < d.radius + 0.5) return false;
                }
                return true;
            });
            
            // Shuffle and pick random valid spawn (not just furthest)
            const shuffledSpawns = validKanyeSpawns.sort(() => Math.random() - 0.5);
            let kCell = shuffledSpawns.length > 0 ? shuffledSpawns[0] : walkableCells[Math.floor(Math.random() * walkableCells.length)];
            const kPos = gridToWorld(kCell.x, kCell.z);
            kanye.x = kPos.x;
            kanye.z = kPos.z;
            kanye.vx = 0;
            kanye.vz = 0;
            kanye.pathTimer = 0;
            kanye.path = [];
            kanye.frozen = false;
            kanye.halfSpeed = false;
            kanye.floor = 1;

            if (kanye.sprite) kanye.sprite.position.set(kanye.x, 1.25, kanye.z);
            camera.position.set(player.x, player.y, player.z);

            createPowerups();
            createCoins();
        }

        // ============ UPDATE PLAYER ============
        function updatePlayer(dt) {
            if (!isLocked || isPaused) return;

            const walkSpeed = 6.0;
            let sprintSpeed = 8.5;
            
            // Speed boost upgrade
            if (player.speedBoost) {
                player.speedBoostTimer -= dt;
                sprintSpeed = 9.5;
                if (player.speedBoostTimer <= 0) player.speedBoost = false;
            }
            
            const jumpPower = 6.0;
            const gravity = 18;

            if (player.infiniteStamina) {
                player.infiniteStaminaTimer -= dt;
                if (player.infiniteStaminaTimer <= 0) {
                    player.infiniteStamina = false;
                    document.getElementById('stamina-bar').classList.remove('infinite');
                    document.getElementById('stamina-bar').classList.remove('boosted');
                }
            }

            const wantSprint = isSprinting && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']);
            if (wantSprint && !player.infiniteStamina) {
                if (stamina > 0) stamina = Math.max(0, stamina - dt * 20);
            } else if (!wantSprint) {
                stamina = Math.min(100, stamina + dt * 15);
            }
            
            const canSprint = wantSprint && (stamina > 0 || player.infiniteStamina);
            const moveSpeed = canSprint ? sprintSpeed : walkSpeed;
            
            document.getElementById('stamina-bar').style.width = (player.infiniteStamina ? 100 : stamina) + '%';

            const forwardX = -Math.sin(player.yaw);
            const forwardZ = -Math.cos(player.yaw);
            const rightX = Math.cos(player.yaw);
            const rightZ = -Math.sin(player.yaw);

            let moveX = 0, moveZ = 0;
            if (keys['KeyW']) { moveX += forwardX; moveZ += forwardZ; }
            if (keys['KeyS']) { moveX -= forwardX; moveZ -= forwardZ; }
            if (keys['KeyD']) { moveX += rightX; moveZ += rightZ; }
            if (keys['KeyA']) { moveX -= rightX; moveZ -= rightZ; }

            const len = Math.hypot(moveX, moveZ);
            if (len > 0) {
                moveX = (moveX / len) * moveSpeed;
                moveZ = (moveZ / len) * moveSpeed;
            }

            if (keys['Space'] && player.onGround) {
                player.vy = jumpPower;
                player.onGround = false;
            }

            player.vy -= gravity * dt;

            let newX = player.x + moveX * dt;
            let newZ = player.z + moveZ * dt;
            let newY = player.y + player.vy * dt;

            if (!isWalkableWorld(newX, player.z, 0.35)) newX = player.x;
            if (!isWalkableWorld(newX, newZ, 0.35)) newZ = player.z;

            player.x = newX;
            player.z = newZ;

            // Check if landing on top of a decoration
            let standingOnDecor = false;
            let decorTopY = 0;
            for (const d of decorations) {
                const distToDecor = Math.hypot(player.x - d.x, player.z - d.z);
                if (distToDecor < d.radius + 0.3 && d.height) {
                    const decorTop = d.height + 0.1; // Slight offset to stand on top
                    // If we're falling down and above the decoration
                    if (player.vy <= 0 && newY <= decorTop + 1.6 && newY > decorTop + 0.5) {
                        decorTopY = decorTop;
                        standingOnDecor = true;
                        break;
                    }
                }
            }
            
            // Ground and ceiling collision
            if (standingOnDecor && player.vy <= 0) {
                newY = decorTopY + 1.6;
                player.vy = 0;
                player.onGround = true;
            } else if (newY < 1.6) {
                newY = 1.6;
                player.vy = 0;
                player.onGround = true;
            }
            if (newY > WALL_H - 0.3) { newY = WALL_H - 0.3; player.vy = 0; }
            player.y = newY;

            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;
            
            checkPowerupCollection();
            checkCoinCollection();
            checkEscapeDoor();
        }

        // ============ POWERUP COLLECTION ============
        function checkPowerupCollection() {
            for (const p of powerups) {
                if (p.collected) continue;
                const dist = Math.hypot(p.x - player.x, p.z - player.z);
                if (dist < 1.5) {
                    p.collected = true;
                    if (p.sprite) scene.remove(p.sprite);
                    activatePowerup(p.type);
                }
            }
        }

        function activatePowerup(type) {
            const msg = document.getElementById('pickup-msg');
            const upg = saveData.upgrades;
            
            if (type === 'ice') {
                let freezeTime = 3;
                if (upg.ice >= 1) freezeTime += 1;
                if (upg.ice >= 2) freezeTime += 2;
                if (upg.ice >= 3) { freezeTime += 0; kanye.halfSpeed = true; kanye.halfSpeedTimer = 3; }
                
                kanye.frozen = true;
                kanye.frozenTimer = freezeTime;
                document.getElementById('freeze-overlay').style.opacity = '1';
                msg.textContent = `‚ùÑÔ∏è KANYE FROZEN FOR ${freezeTime} SECONDS!`;
                document.getElementById('slot-ice').classList.add('active');
                setTimeout(() => document.getElementById('slot-ice').classList.remove('active'), freezeTime * 1000);
                
            } else if (type === 'speed') {
                let duration = 10;
                if (upg.speed >= 1) duration += 3;
                if (upg.speed >= 2) duration += 2;
                if (upg.speed >= 3) { player.speedBoost = true; player.speedBoostTimer = 5; }
                
                player.infiniteStamina = true;
                player.infiniteStaminaTimer = duration;
                document.getElementById('stamina-bar').classList.add('infinite');
                if (upg.speed >= 3) document.getElementById('stamina-bar').classList.add('boosted');
                msg.textContent = `‚ö° INFINITE STAMINA FOR ${duration} SECONDS!`;
                document.getElementById('slot-speed').classList.add('active');
                setTimeout(() => document.getElementById('slot-speed').classList.remove('active'), duration * 1000);
                
            } else if (type === 'shield') {
                if (player.shieldHits > 0) {
                    msg.textContent = 'üõ°Ô∏è SHIELD ALREADY ACTIVE!';
                } else {
                    player.shieldHits = upg.shield >= 3 ? 2 : 1;
                    document.getElementById('shield-indicator').style.opacity = '1';
                    msg.textContent = upg.shield >= 3 ? 'üõ°Ô∏è DOUBLE SHIELD ACQUIRED!' : 'üõ°Ô∏è SHIELD ACQUIRED!';
                    document.getElementById('slot-shield').classList.add('active');
                }
            }
            
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 2000);
        }

        // ============ COIN COLLECTION ============
        function checkCoinCollection() {
            let needRespawn = false;
            for (const c of coins) {
                if (c.collected) continue;
                const dist = Math.hypot(c.x - player.x, c.z - player.z);
                if (dist < 1.5) {
                    c.collected = true;
                    if (c.sprite) scene.remove(c.sprite);
                    sessionCoins++;
                    document.getElementById('hud-coins').textContent = 'üí∞ ' + sessionCoins;
                    needRespawn = true;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = 'üí∞ +1 COIN';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 1000);
                }
            }
            if (needRespawn) setTimeout(spawnCoins, 2000);
        }

        // ============ UPDATE KANYE ============
        function updateKanye(dt) {
            if (!kanye.sprite || isPaused) return;

            if (kanye.frozen) {
                kanye.frozenTimer -= dt;
                if (kanye.frozenTimer <= 0) {
                    kanye.frozen = false;
                    document.getElementById('freeze-overlay').style.opacity = '0';
                }
                kanye.sprite.material.color.setHex(kanye.frozen ? 0x88ccff : 0xffffff);
                return;
            }
            
            if (kanye.halfSpeed) {
                kanye.halfSpeedTimer -= dt;
                if (kanye.halfSpeedTimer <= 0) kanye.halfSpeed = false;
            }

            // Kanye is 1 speed point faster on warehouse map
            let kanyeBaseSpeed = currentMap === 'warehouse' ? 8.5 : 7.5;
            const kanyeMaxSpeed = kanye.halfSpeed ? kanyeBaseSpeed * 0.6 : kanyeBaseSpeed;
            const kanyeTurnSpeed = 3.5;
            
            kanye.pathTimer -= dt;
            if (kanye.pathTimer <= 0) {
                kanye.pathTimer = 0.25; // More frequent path updates for better navigation
                
                const kGrid = worldToGrid(kanye.x, kanye.z);
                const pGrid = worldToGrid(player.x, player.z);
                
                // Chase player with prediction
                const predX = player.x + (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ? 
                    -Math.sin(player.yaw) * 3 : 0);
                const predZ = player.z + (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ? 
                    -Math.cos(player.yaw) * 3 : 0);
                const predGrid = worldToGrid(predX, predZ);
                
                let path = findPath(kGrid.x, kGrid.z, predGrid.x, predGrid.z);
                if (path.length === 0) path = findPath(kGrid.x, kGrid.z, pGrid.x, pGrid.z);
                
                kanye.path = path;
                kanye.pathIndex = 0;
            }

            let targetX = player.x;
            let targetZ = player.z;

            if (kanye.path.length > 0) {
                while (kanye.pathIndex < kanye.path.length) {
                    const node = kanye.path[kanye.pathIndex];
                    const nodePos = gridToWorld(node.x, node.z);
                    const distToNode = Math.hypot(nodePos.x - kanye.x, nodePos.z - kanye.z);
                    if (distToNode < 1.5 && kanye.pathIndex < kanye.path.length - 1) {
                        kanye.pathIndex++;
                    } else {
                        targetX = nodePos.x;
                        targetZ = nodePos.z;
                        break;
                    }
                }
            }

            const dx = targetX - kanye.x;
            const dz = targetZ - kanye.z;
            const dist = Math.hypot(dx, dz);

            if (dist > 0.1) {
                const desiredVx = (dx / dist) * kanyeMaxSpeed;
                const desiredVz = (dz / dist) * kanyeMaxSpeed;

                kanye.vx += (desiredVx - kanye.vx) * kanyeTurnSpeed * dt;
                kanye.vz += (desiredVz - kanye.vz) * kanyeTurnSpeed * dt;

                const speed = Math.hypot(kanye.vx, kanye.vz);
                if (speed > kanyeMaxSpeed) {
                    kanye.vx = (kanye.vx / speed) * kanyeMaxSpeed;
                    kanye.vz = (kanye.vz / speed) * kanyeMaxSpeed;
                }
            }

            let newX = kanye.x + kanye.vx * dt;
            let newZ = kanye.z + kanye.vz * dt;

            // Check collision with walls and decorations
            if (!isWalkableWorld(newX, kanye.z, 0.4)) { 
                newX = kanye.x; 
                kanye.vx *= -0.5;
                // Try to slide along obstacle
                if (Math.abs(kanye.vz) > 0.5) {
                    kanye.vx = 0;
                }
            }
            if (!isWalkableWorld(kanye.x, newZ, 0.4)) { 
                newZ = kanye.z; 
                kanye.vz *= -0.5;
                // Try to slide along obstacle
                if (Math.abs(kanye.vx) > 0.5) {
                    kanye.vz = 0;
                }
            }
            
            // Stuck detection - if barely moving, force recalculate path
            const movement = Math.hypot(newX - kanye.x, newZ - kanye.z);
            if (movement < 0.01 * dt && Math.hypot(kanye.vx, kanye.vz) > 0.1) {
                kanye.pathTimer = 0; // Force path recalculation
                // Try random direction to escape
                const randomAngle = Math.random() * Math.PI * 2;
                kanye.vx = Math.cos(randomAngle) * 2;
                kanye.vz = Math.sin(randomAngle) * 2;
            }
            
            kanye.x = newX;
            kanye.z = newZ;
            
            // Position Kanye sprite at correct height
            kanye.sprite.position.set(kanye.x, 1.25, kanye.z);

            const distToPlayer = Math.hypot(kanye.x - player.x, kanye.z - player.z);

            const audioRange = 70;
            let vol = distToPlayer < audioRange ? Math.pow(1 - (distToPlayer / audioRange), 0.5) : 0;
            setAudioVolume(vol);

            const fear = document.getElementById('fear-overlay');
            const warn = document.getElementById('warning');
            if (distToPlayer < 20) {
                fear.style.opacity = (1 - distToPlayer / 20) * 0.6;
                warn.style.opacity = distToPlayer < 10 ? 1 : 0;
            } else {
                fear.style.opacity = 0;
                warn.style.opacity = 0;
            }

            if (distToPlayer < 1.2) {
                if (player.shieldHits > 0) {
                    player.shieldHits--;
                    
                    let freezeOnBlock = 0;
                    if (saveData.upgrades.shield >= 1) freezeOnBlock = 1;
                    if (saveData.upgrades.shield >= 2) freezeOnBlock = 2;
                    if (saveData.upgrades.shield >= 3) freezeOnBlock = 2;
                    
                    if (freezeOnBlock > 0) {
                        kanye.frozen = true;
                        kanye.frozenTimer = freezeOnBlock;
                    }
                    
                    if (player.shieldHits <= 0) {
                        document.getElementById('shield-indicator').style.opacity = '0';
                        document.getElementById('slot-shield').classList.remove('active');
                    }
                    
                    const bounceDir = Math.atan2(kanye.z - player.z, kanye.x - player.x);
                    kanye.x += Math.cos(bounceDir) * 8;
                    kanye.z += Math.sin(bounceDir) * 8;
                    kanye.vx = Math.cos(bounceDir) * 10;
                    kanye.vz = Math.sin(bounceDir) * 10;
                    
                    if (!isWalkableWorld(kanye.x, kanye.z, 0.4)) {
                        const kGrid = worldToGrid(kanye.x, kanye.z);
                        for (let r = 1; r < 10; r++) {
                            let found = false;
                            for (let ddx = -r; ddx <= r && !found; ddx++) {
                                for (let ddz = -r; ddz <= r && !found; ddz++) {
                                    if (isWalkableGrid(kGrid.x + ddx, kGrid.z + ddz)) {
                                        const pos = gridToWorld(kGrid.x + ddx, kGrid.z + ddz);
                                        kanye.x = pos.x;
                                        kanye.z = pos.z;
                                        found = true;
                                    }
                                }
                            }
                            if (found) break;
                        }
                    }
                    
                    kanye.pathTimer = 0;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = player.shieldHits > 0 ? 'üõ°Ô∏è SHIELD BLOCKED! 1 HIT LEFT!' : 'üõ°Ô∏è SHIELD BLOCKED KANYE!';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 2000);
                } else {
                    killPlayer();
                }
            }
        }

        // ============ MINIMAP ============
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const scale = w / GRID_SIZE;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);

            ctx.fillStyle = '#444';
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x] && maze[x][z] === 1) {
                        ctx.fillRect(x * scale, z * scale, scale, scale);
                    }
                }
            }
            
            // Powerups
            for (const p of powerups) {
                if (p.collected) continue;
                const px = (p.x / CELL + GRID_SIZE / 2) * scale;
                const pz = (p.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = p.type === 'ice' ? '#88ccff' : p.type === 'speed' ? '#ffcc00' : '#44ff44';
                ctx.beginPath();
                ctx.arc(px, pz, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Coins
            for (const c of coins) {
                if (c.collected) continue;
                const cx = (c.x / CELL + GRID_SIZE / 2) * scale;
                const cz = (c.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(cx, cz, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            const playerMapX = (player.x / CELL + GRID_SIZE / 2) * scale;
            const playerMapZ = (player.z / CELL + GRID_SIZE / 2) * scale;
            
            ctx.fillStyle = '#4f4';
            ctx.beginPath();
            ctx.arc(playerMapX, playerMapZ, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#4f4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerMapX, playerMapZ);
            const dirLen = 14;
            const dirX = playerMapX - Math.sin(player.yaw) * dirLen;
            const dirZ = playerMapZ - Math.cos(player.yaw) * dirLen;
            ctx.lineTo(dirX, dirZ);
            ctx.stroke();

            const kanyeMapX = (kanye.x / CELL + GRID_SIZE / 2) * scale;
            const kanyeMapZ = (kanye.z / CELL + GRID_SIZE / 2) * scale;
            ctx.fillStyle = kanye.frozen ? '#88ccff' : '#f44';
            ctx.beginPath();
            ctx.arc(kanyeMapX, kanyeMapZ, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Update map label
            const mapNames = { backrooms: 'üè¢ Backrooms', warehouse: 'üè≠ Warehouse', hospital: 'üè• Hospital' };
            document.getElementById('minimap-floor').textContent = mapNames[currentMap] || 'Unknown';
        }

        // ============ TIMER ============
        function updateTimer() {
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ============ DEATH ============
        function killPlayer() {
            if (isDead) return;
            isDead = true;
            
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            
            // Add highscore
            saveData.highscores.push(elapsed);
            saveData.highscores.sort((a, b) => b - a);
            saveData.highscores = saveData.highscores.slice(0, 3);
            
            // Add coins
            saveData.coins += sessionCoins;
            saveSaveData();
            
            document.getElementById('survival-time').textContent = `Survived: ${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('coins-earned').textContent = `+${sessionCoins} coins`;
            document.getElementById('death-screen').style.display = 'flex';
            
            stopAudio();
            document.exitPointerLock();
        }

        // ============ PAUSE ============
        function togglePause() {
            if (!gameStarted || isDead) return;
            
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            
            if (isPaused) {
                pauseAudio();
                document.exitPointerLock();
            } else {
                renderer.domElement.requestPointerLock();
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pause-screen').style.display = 'none';
            renderer.domElement.requestPointerLock();
        }

        function quitGame() {
            // Don't add coins when quitting
            sessionCoins = 0;
            returnToMenu();
        }

        function returnToMenu() {
            gameStarted = false;
            isPaused = false;
            isDead = false;
            
            stopAudio();
            document.exitPointerLock();
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('start-screen').classList.remove('hidden');
            
            updateUI();
        }

        // ============ INIT ============
        function init() {
            loadSaveData();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 2, 30);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'low-power' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);
            document.body.appendChild(renderer.domElement);

            const mmCanvas = document.getElementById('minimap-canvas');
            mmCanvas.width = 160;
            mmCanvas.height = 160;

            loadTextures(() => {
                generateMaze();
                buildWorld();
                createKanye();
            });

            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === sprintKeyCode) isSprinting = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape' && gameStarted && !isDead) {
                    e.preventDefault();
                    togglePause();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === sprintKeyCode) isSprinting = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isLocked || !gameStarted || isDead || isPaused) return;
                player.yaw -= e.movementX * mouseSensitivity;
                player.pitch -= e.movementY * mouseSensitivity;
                player.pitch = Math.max(-1.4, Math.min(1.4, player.pitch));
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === renderer.domElement;
            });

            renderer.domElement.addEventListener('click', () => {
                if (gameStarted && !isDead && !isPaused) renderer.domElement.requestPointerLock();
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ============ GAME LOOP ============
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            if (gameStarted && !isDead && !isPaused) {
                updatePlayer(dt);
                updateKanye(dt);
                updateMinimap();
                updateTimer();
            }

            renderer.render(scene, camera);
        }

        // ============ START / RESTART ============
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            gameStarted = true;
            startTime = Date.now();
            stamina = 100;
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            
            // Randomly select a map
            const maps = ['backrooms', 'warehouse', 'hospital'];
            currentMap = maps[Math.floor(Math.random() * maps.length)];
            
            // Rebuild the world with the new map
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            generateMaze();
            buildWorld();
            createKanye();
            
            spawnEntities();
            initAudio();
            renderer.domElement.requestPointerLock();
        }

        // ============ ESCAPE MODE ============
        function startEscapeMode() {
            document.getElementById('start-screen').classList.add('hidden');
            gameStarted = true;
            isEscapeMode = true;
            escapeRound = 1;
            startTime = Date.now();
            stamina = 100;
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            
            // Only backrooms or hospital for escape mode (not warehouse - too easy)
            const escapeMaps = ['backrooms', 'hospital'];
            currentMap = escapeMaps[Math.floor(Math.random() * escapeMaps.length)];
            
            // Double the grid size for escape mode
            GRID_SIZE = baseGridSize * 2;
            
            // Hide minimap in escape mode
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('minimap-floor').style.display = 'none';
            
            // Show escape HUD
            document.getElementById('escape-hud').style.display = 'block';
            document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
            document.getElementById('escape-door-indicator').textContent = 'üö™ FIND THE EXIT!';
            document.getElementById('escape-door-indicator').classList.remove('nearby');
            
            // Check for shield purchase
            if (document.getElementById('escape-shield-toggle').checked && saveData.coins >= 5) {
                saveData.coins -= 5;
                player.shieldHits = saveData.upgrades.shield >= 3 ? 2 : 1;
                document.getElementById('shield-indicator').style.opacity = '1';
                document.getElementById('slot-shield').classList.add('active');
                saveSaveData();
                updateUI();
            }
            
            // Rebuild world
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            createEscapeDoor();
            
            initAudio();
            renderer.domElement.requestPointerLock();
        }
        
        function createEscapeDoor() {
            // Remove old door if exists
            if (escapeDoor && escapeDoor.mesh) {
                scene.remove(escapeDoor.mesh);
            }
            
            // Find a wall cell that has an adjacent walkable cell (for door placement)
            // Door must be at least 5 squares (20 units) from player and accessible
            const minDoorDist = 20;
            const doorCandidates = [];
            for (let x = 2; x < GRID_SIZE - 2; x++) {
                for (let z = 2; z < GRID_SIZE - 2; z++) {
                    if (maze[x][z] === 1) {
                        // Check if there's an adjacent walkable cell
                        const adjacent = [
                            {wx: x-1, wz: z, dir: 'east'},
                            {wx: x+1, wz: z, dir: 'west'},
                            {wx: x, wz: z-1, dir: 'south'},
                            {wx: x, wz: z+1, dir: 'north'}
                        ];
                        for (const adj of adjacent) {
                            if (isWalkableGrid(adj.wx, adj.wz)) {
                                const doorPos = gridToWorld(x, z);
                                const adjPos = gridToWorld(adj.wx, adj.wz);
                                const dist = Math.hypot(doorPos.x - player.x, doorPos.z - player.z);
                                // Must be far from player
                                if (dist < minDoorDist) continue;
                                // Check adjacent cell is actually accessible (not blocked by decoration)
                                let blocked = false;
                                for (const d of decorations) {
                                    if (Math.hypot(adjPos.x - d.x, adjPos.z - d.z) < d.radius + 0.5) {
                                        blocked = true;
                                        break;
                                    }
                                }
                                if (!blocked) {
                                    doorCandidates.push({x, z, adjX: adj.wx, adjZ: adj.wz, dir: adj.dir});
                                }
                            }
                        }
                    }
                }
            }
            
            if (doorCandidates.length === 0) return;
            
            // Shuffle candidates for randomness and pick one
            const shuffledDoors = doorCandidates.sort(() => Math.random() - 0.5);
            const doorData = shuffledDoors[0];
            const doorWorldPos = gridToWorld(doorData.x, doorData.z);
            const adjWorldPos = gridToWorld(doorData.adjX, doorData.adjZ);
            
            // Create door group
            const doorGroup = new THREE.Group();
            
            // Door frame (dark brown wood)
            const frameMat = new THREE.MeshBasicMaterial({ color: 0x3d2817 });
            
            // Door panel (dark brown wood)
            const doorMat = new THREE.MeshBasicMaterial({ color: 0x5c3a21 });
            
            // Doorknob (darker yellow/gold)
            const knobMat = new THREE.MeshBasicMaterial({ color: 0xb8860b });
            
            // Calculate door position and rotation
            let doorX = doorWorldPos.x;
            let doorZ = doorWorldPos.z;
            let rotY = 0;
            
            // Position door on the wall face toward the walkable area
            if (doorData.dir === 'east') {
                doorX = doorWorldPos.x - CELL/2 + 0.3;
                rotY = Math.PI / 2;
            } else if (doorData.dir === 'west') {
                doorX = doorWorldPos.x + CELL/2 - 0.3;
                rotY = Math.PI / 2;
            } else if (doorData.dir === 'south') {
                doorZ = doorWorldPos.z - CELL/2 + 0.3;
                rotY = 0;
            } else if (doorData.dir === 'north') {
                doorZ = doorWorldPos.z + CELL/2 - 0.3;
                rotY = 0;
            }
            
            // Door frame
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.3), frameMat);
            frameLeft.position.set(-0.55, 1.4, 0);
            doorGroup.add(frameLeft);
            
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.3), frameMat);
            frameRight.position.set(0.55, 1.4, 0);
            doorGroup.add(frameRight);
            
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.15, 0.3), frameMat);
            frameTop.position.set(0, 2.75, 0);
            doorGroup.add(frameTop);
            
            // Door panel (bulges out 0.3 units)
            const doorPanel = new THREE.Mesh(new THREE.BoxGeometry(1.0, 2.5, 0.15), doorMat);
            doorPanel.position.set(0, 1.3, 0.25);
            doorGroup.add(doorPanel);
            
            // Doorknob (darker yellow/gold sphere)
            const doorknob = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), knobMat);
            doorknob.position.set(0.35, 1.1, 0.38);
            doorGroup.add(doorknob);
            
            // Doorknob plate
            const knobPlate = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.25, 0.02), knobMat);
            knobPlate.position.set(0.35, 1.1, 0.34);
            doorGroup.add(knobPlate);
            
            // Glow effect (point light) - green glow to make door visible
            const glow = new THREE.PointLight(0x44ff44, 1.5, 10);
            glow.position.set(0, 1.5, 0.6);
            doorGroup.add(glow);
            
            doorGroup.position.set(doorX, 0, doorZ);
            doorGroup.rotation.y = rotY;
            scene.add(doorGroup);
            
            // Store door data for collision detection
            escapeDoor = {
                mesh: doorGroup,
                x: adjWorldPos.x,  // Use adjacent cell for easier collision
                z: adjWorldPos.z,
                gridX: doorData.x,
                gridZ: doorData.z
            };
        }
        
        function checkEscapeDoor() {
            if (!isEscapeMode || !escapeDoor) return;
            
            // Calculate distance to actual door position (not adjacent cell)
            const doorWorldPos = gridToWorld(escapeDoor.gridX, escapeDoor.gridZ);
            const dist = Math.hypot(doorWorldPos.x - player.x, doorWorldPos.z - player.z);
            
            // Update door indicator
            const indicator = document.getElementById('escape-door-indicator');
            if (dist < 15) {
                indicator.textContent = 'üö™ EXIT NEARBY!';
                indicator.classList.add('nearby');
            } else {
                indicator.textContent = 'üö™ FIND THE EXIT!';
                indicator.classList.remove('nearby');
            }
            
            // Check if player touched the door itself (must be very close - within 2.5 units)
            if (dist < 2.5) {
                winEscapeRound();
            }
        }
        
        function winEscapeRound() {
            escapeRound++;
            
            // Update escape record
            if (escapeRound - 1 > saveData.escapeRecord) {
                saveData.escapeRecord = escapeRound - 1;
                saveSaveData();
            }
            
            // Show message
            const msg = document.getElementById('pickup-msg');
            msg.textContent = 'üö™ ESCAPED! Round ' + escapeRound + ' starting...';
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 2000);
            
            // Update round display
            document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
            
            // Regenerate maze and respawn
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            createEscapeDoor();
        }

        function restartGame() {
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            
            // Check if we were in escape mode - if so, restart escape mode
            if (isEscapeMode) {
                // Stay in escape mode
                escapeRound = 1;
                GRID_SIZE = baseGridSize * 2;
                
                // Keep escape HUD visible
                document.getElementById('escape-hud').style.display = 'block';
                document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
                
                // Keep minimap hidden
                document.getElementById('minimap').style.display = 'none';
                document.getElementById('minimap-floor').style.display = 'none';
                
                // Only backrooms or hospital for escape mode
                const escapeMaps = ['backrooms', 'hospital'];
                currentMap = escapeMaps[Math.floor(Math.random() * escapeMaps.length)];
                
                generateMaze();
                buildWorld();
                createKanye();
                spawnEntities();
                createEscapeDoor();
            } else {
                // Normal mode restart
                GRID_SIZE = baseGridSize;
                document.getElementById('escape-hud').style.display = 'none';
                
                // Show minimap if enabled
                if (saveData.settings.minimapEnabled !== false) {
                    document.getElementById('minimap').style.display = 'block';
                    document.getElementById('minimap-floor').style.display = 'block';
                }
                
                // Randomly select a new map
                const maps = ['backrooms', 'warehouse', 'hospital'];
                currentMap = maps[Math.floor(Math.random() * maps.length)];
                
                generateMaze();
                buildWorld();
                createKanye();
                spawnEntities();
            }
            
            isDead = false;
            stamina = 100;
            startTime = Date.now();
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            kanye.pathTimer = 0;
            kanye.frozen = false;
            kanye.halfSpeed = false;
            kanye.vx = 0;
            kanye.vz = 0;
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('fear-overlay').style.opacity = 0;
            document.getElementById('warning').style.opacity = 0;
            document.getElementById('freeze-overlay').style.opacity = 0;
            document.getElementById('shield-indicator').style.opacity = 0;
            document.getElementById('stamina-bar').classList.remove('infinite');
            document.getElementById('stamina-bar').classList.remove('boosted');
            document.querySelectorAll('.powerup-slot').forEach(s => s.classList.remove('active'));
            
            renderer.domElement.requestPointerLock();
        }

        init();
        requestAnimationFrame(animate);
    </script>
</body>
  </html>
