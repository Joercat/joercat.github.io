<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Olive Delights - PlayCanvas Edition</title>
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #fff; }
        
        #application-canvas { 
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top: 0; 
            left: 0; 
        }
        
        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 300;
            text-align: center;
        }
        .menu-overlay.hidden { display: none; }
        
        #start-screen h1 { 
            color: #ffd700; 
            font-size: 56px; 
            text-shadow: 0 0 40px #ff8c00, 0 0 80px #ff4500; 
            margin-bottom: 10px;
            letter-spacing: 4px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        @keyframes titleGlow {
            from { text-shadow: 0 0 40px #ff8c00, 0 0 80px #ff4500; }
            to { text-shadow: 0 0 60px #ffd700, 0 0 100px #ff8c00; }
        }
        
        #start-screen h2 { 
            color: #aaa; 
            font-size: 22px; 
            margin-bottom: 25px;
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        .menu-section { 
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(10px);
            padding: 20px 30px; 
            border-radius: 12px; 
            margin: 12px auto; 
            text-align: center; 
            max-width: 420px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .menu-section h3 { color: #ffd700; margin-bottom: 12px; font-size: 18px; }
        .menu-section p, .menu-section label { color: #ddd; font-size: 14px; line-height: 1.7; }
        
        .menu-btn {
            padding: 16px 45px; 
            font-size: 18px; 
            margin: 8px;
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white; 
            border: none; 
            cursor: pointer;
            font-family: inherit; 
            border-radius: 8px;
            font-weight: 600;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255,140,0,0.4);
        }
        .menu-btn:hover { 
            transform: scale(1.05) translateY(-2px); 
            box-shadow: 0 6px 25px rgba(255,140,0,0.6);
        }
        .menu-btn.secondary { 
            background: linear-gradient(135deg, #444, #333);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .menu-btn.small { padding: 10px 22px; font-size: 14px; }
        
        .coins-display { 
            color: #ffd700; 
            font-size: 22px; 
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .highscores { color: #4ade80; font-size: 15px; }
        .highscores span { display: block; margin: 5px 0; }
        
        .settings-row { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            margin: 12px 0; 
            color: #ddd; 
            gap: 15px; 
        }
        .settings-row select, .settings-row input[type="range"] { 
            background: #2a2a3a; 
            color: #fff; 
            border: 1px solid #444; 
            padding: 8px 12px; 
            border-radius: 6px;
            cursor: pointer;
        }
        .settings-row input[type="range"] {
            width: 120px;
            accent-color: #ff8c00;
        }
        
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 12px; }
        .shop-item { 
            background: rgba(255,255,255,0.08); 
            padding: 15px; 
            border-radius: 10px; 
            text-align: center; 
            color: #fff;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .shop-item:hover { background: rgba(255,255,255,0.12); }
        .shop-item img { width: 56px; height: 56px; image-rendering: pixelated; }
        .shop-item.owned { border-color: #4ade80; }
        .shop-item.selected { border-color: #ffd700; box-shadow: 0 0 20px rgba(255,215,0,0.4); }
        .shop-item small { color: #aaa; }
        
        .upgrade-item { 
            background: rgba(255,255,255,0.05); 
            padding: 12px; 
            margin: 8px 0; 
            border-radius: 8px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            color: #ddd;
            transition: all 0.2s ease;
        }
        .upgrade-item:hover { background: rgba(255,255,255,0.08); }
        .upgrade-item.owned { background: rgba(74,222,128,0.15); }
        .upgrade-item span { color: #fff; }
        
        .tab-buttons { display: flex; gap: 8px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap; }
        .tab-btn { 
            padding: 10px 20px; 
            background: rgba(255,255,255,0.1); 
            color: #aaa; 
            border: none; 
            cursor: pointer; 
            border-radius: 6px;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        .tab-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
        .tab-btn.active { background: linear-gradient(135deg, #ff8c00, #ff4500); color: #fff; }
        .tab-content { display: none; max-width: 480px; margin: 0 auto; }
        .tab-content.active { display: block; }
        
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        
        #crosshair { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 6px; 
            height: 6px; 
            background: rgba(255,255,255,0.9); 
            border-radius: 50%; 
            box-shadow: 0 0 8px #fff, 0 0 16px rgba(255,255,255,0.5); 
        }
        
        #stamina-container { 
            position: absolute; 
            bottom: 35px; 
            left: 50%; 
            transform: translateX(-50%); 
            width: 220px; 
            height: 10px; 
            background: rgba(0,0,0,0.7); 
            border: 2px solid rgba(255,255,255,0.2); 
            border-radius: 6px;
            overflow: hidden;
        }
        #stamina-bar { 
            height: 100%; 
            width: 100%; 
            background: linear-gradient(90deg, #22c55e, #4ade80); 
            border-radius: 4px; 
            transition: width 0.15s ease;
            box-shadow: 0 0 10px rgba(74,222,128,0.5);
        }
        #stamina-bar.infinite { 
            background: linear-gradient(90deg, #f59e0b, #fbbf24); 
            animation: staminaPulse 0.4s infinite alternate;
            box-shadow: 0 0 15px rgba(251,191,36,0.7);
        }
        #stamina-bar.boosted { 
            background: linear-gradient(90deg, #ec4899, #f472b6);
            box-shadow: 0 0 15px rgba(236,72,153,0.7);
        }
        @keyframes staminaPulse { from { opacity: 0.8; } to { opacity: 1; } }
        
        #hud-coins { 
            position: absolute; 
            top: 22px; 
            left: 130px; 
            color: #ffd700; 
            font-size: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        #timer { 
            position: absolute; 
            top: 22px; 
            left: 22px; 
            color: #fff; 
            font-size: 24px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        #floor-indicator { 
            position: absolute; 
            top: 55px; 
            left: 22px; 
            color: #88ccff; 
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #warning { 
            position: absolute; 
            top: 110px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #ff4444; 
            font-size: 28px; 
            font-weight: bold;
            opacity: 0; 
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
            animation: warningPulse 0.5s infinite alternate;
        }
        @keyframes warningPulse {
            from { transform: translateX(-50%) scale(1); }
            to { transform: translateX(-50%) scale(1.05); }
        }
        
        #shield-indicator { 
            position: absolute; 
            top: 150px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #4ade80; 
            font-size: 20px; 
            opacity: 0;
            text-shadow: 0 0 15px rgba(74,222,128,0.8);
        }
        
        #pickup-msg { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, 60px); 
            color: #4ade80; 
            font-size: 22px; 
            font-weight: 600;
            opacity: 0; 
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            transition: opacity 0.3s ease;
        }
        
        #escape-hud { 
            position: absolute; 
            top: 22px; 
            left: 50%; 
            transform: translateX(-50%); 
            text-align: center; 
            display: none;
        }
        #escape-round { 
            color: #4ade80; 
            font-size: 28px; 
            font-weight: bold; 
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        #escape-door-indicator { 
            color: #22ff22; 
            font-size: 20px; 
            margin-top: 8px; 
            text-shadow: 0 0 20px #00ff00;
            animation: doorPulse 1.2s infinite alternate;
        }
        #escape-door-indicator.nearby { 
            color: #ffff00; 
            text-shadow: 0 0 25px #ffff00;
            font-size: 24px;
        }
        @keyframes doorPulse { from { opacity: 0.7; } to { opacity: 1; } }
        
        #powerups-display { 
            position: absolute; 
            bottom: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 18px;
        }
        .powerup-slot { 
            width: 56px; 
            height: 56px; 
            background: rgba(0,0,0,0.6); 
            border: 2px solid rgba(255,255,255,0.2); 
            border-radius: 10px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        .powerup-slot.active { 
            border-color: #4ade80; 
            box-shadow: 0 0 20px rgba(74,222,128,0.6);
            background: rgba(74,222,128,0.2);
        }
        
        #minimap { 
            position: absolute; 
            top: 22px; 
            right: 22px; 
            width: 180px; 
            height: 180px; 
            background: rgba(0,0,0,0.85); 
            border: 2px solid rgba(255,255,255,0.3); 
            border-radius: 8px;
            overflow: hidden;
        }
        #minimap-canvas { width: 100%; height: 100%; }
        #minimap-floor { 
            position: absolute; 
            top: 210px; 
            right: 22px; 
            width: 180px; 
            text-align: center; 
            color: #88ccff; 
            font-size: 13px; 
            background: rgba(0,0,0,0.7); 
            padding: 6px; 
            border-radius: 6px;
        }
        
        .vignette { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            z-index: 45; 
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.75) 100%);
        }
        
        #fear-overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            background: radial-gradient(ellipse at center, rgba(120,0,0,0.3) 0%, rgba(80,0,0,0.5) 100%);
            opacity: 0; 
            z-index: 50;
            transition: opacity 0.3s ease;
        }
        
        #freeze-overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            background: radial-gradient(ellipse at center, rgba(100,200,255,0.15) 0%, rgba(50,150,255,0.25) 100%);
            opacity: 0; 
            z-index: 48;
            transition: opacity 0.3s ease;
        }
        
        #death-screen { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(ellipse at center, rgba(100,0,0,0.9) 0%, rgba(40,0,0,0.98) 100%);
            display: none; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            z-index: 200;
        }
        #death-screen h1 { 
            color: #fff; 
            font-size: 72px; 
            text-shadow: 0 0 50px #ff0000, 0 0 100px #ff0000;
            margin-bottom: 25px;
            animation: deathPulse 1s infinite alternate;
        }
        @keyframes deathPulse {
            from { transform: scale(1); }
            to { transform: scale(1.02); }
        }
        #death-screen p { color: #fcc; font-size: 22px; margin-bottom: 12px; }
        #death-screen .coins-earned { color: #ffd700; font-size: 28px; margin: 20px 0; text-shadow: 0 0 15px rgba(255,215,0,0.5); }
        
        #pause-screen { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(0,0,0,0.92); 
            backdrop-filter: blur(10px);
            display: none; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            z-index: 250;
        }
        #pause-screen h1 { color: #fff; font-size: 56px; margin-bottom: 30px; }
        
        /* Loading screen */
        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #0f0f23);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 400;
        }
        #loading-screen.hidden { display: none; }
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255,140,0,0.3);
            border-top: 4px solid #ff8c00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading-text { color: #ffd700; font-size: 24px; }
        #loading-progress { color: #aaa; font-size: 14px; margin-top: 10px; }
    </style>
</head>
<body>
    <canvas id="application-canvas"></canvas>
    
    <!-- LOADING SCREEN -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div id="loading-text">Loading Olive Delights...</div>
        <div id="loading-progress">Initializing engine...</div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="menu-overlay hidden">
        <h1>ü´í OLIVE DELIGHTS ü´í</h1>
        <h2>Escape the Nextbot</h2>
        
        <div class="coins-display">üí∞ Coins: <span id="total-coins">0</span></div>
        
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="showTab('play')">PLAY</button>
            <button class="tab-btn" onclick="showTab('escape')">ESCAPE</button>
            <button class="tab-btn" onclick="showTab('shop')">SHOP</button>
            <button class="tab-btn" onclick="showTab('upgrades')">UPGRADES</button>
            <button class="tab-btn" onclick="showTab('settings')">SETTINGS</button>
        </div>
        
        <!-- PLAY TAB -->
        <div id="tab-play" class="tab-content active">
            <div class="menu-section">
                <h3>üèÜ TOP 3 RUNS</h3>
                <div class="highscores" id="highscores">
                    <span>1. --:--</span>
                    <span>2. --:--</span>
                    <span>3. --:--</span>
                </div>
            </div>
            
            <div class="menu-section">
                <p><strong>CONTROLS:</strong><br>
                WASD - Move | <span id="sprint-key-display">SHIFT</span> - Sprint | SPACE - Jump<br>
                ESC - Pause Menu</p>
            </div>
            
            <div class="menu-section">
                <label><input type="checkbox" id="start-shield-toggle"> Start with Shield (5 coins)</label>
            </div>
            
            <button class="menu-btn" onclick="startGame()">START GAME</button>
        </div>
        
        <!-- ESCAPE MODE TAB -->
        <div id="tab-escape" class="tab-content">
            <div class="menu-section">
                <h3>üö™ ESCAPE MODE</h3>
                <p>Find the exit door to escape each round!<br>
                How many times can you escape?<br>
                <strong>Map is 2x larger, no minimap!</strong></p>
            </div>
            <div class="menu-section">
                <h3>üèÜ BEST STREAK</h3>
                <div class="highscores">
                    <span id="escape-record">Best: 0 escapes</span>
                </div>
            </div>
            <div class="menu-section">
                <label><input type="checkbox" id="escape-shield-toggle"> Start with Shield (5 coins)</label>
            </div>
            <button class="menu-btn" onclick="startEscapeMode()">START ESCAPE MODE</button>
        </div>
        
        <!-- SHOP TAB -->
        <div id="tab-shop" class="tab-content">
            <div class="menu-section">
                <h3>üé≠ KANYE SKINS</h3>
                <div class="shop-grid" id="skin-shop"></div>
            </div>
        </div>
        
        <!-- UPGRADES TAB -->
        <div id="tab-upgrades" class="tab-content">
            <div class="menu-section">
                <h3>‚ùÑÔ∏è ICE UPGRADES</h3>
                <div id="ice-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>‚ö° SPEED UPGRADES</h3>
                <div id="speed-upgrades"></div>
            </div>
            <div class="menu-section">
                <h3>üõ°Ô∏è SHIELD UPGRADES</h3>
                <div id="shield-upgrades"></div>
            </div>
        </div>
        
        <!-- SETTINGS TAB -->
        <div id="tab-settings" class="tab-content">
            <div class="menu-section">
                <h3>‚öôÔ∏è SETTINGS</h3>
                <div class="settings-row">
                    <label>Sprint Key:</label>
                    <select id="sprint-key-select" onchange="updateSprintKey()">
                        <option value="ShiftLeft">Left Shift</option>
                        <option value="ShiftRight">Right Shift</option>
                        <option value="ControlLeft">Left Ctrl</option>
                        <option value="KeyC">C</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label>Mouse Sensitivity:</label>
                    <input type="range" id="sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
                </div>
                <div class="settings-row">
                    <label>Music Volume:</label>
                    <input type="range" id="music-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
                </div>
                <div class="settings-row">
                    <label>Graphics Quality:</label>
                    <select id="graphics-quality" onchange="updateGraphicsQuality()">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label>Show Minimap:</label>
                    <input type="checkbox" id="minimap-toggle" checked onchange="updateMinimapToggle()">
                </div>
            </div>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="ui" style="display: none;">
        <div id="crosshair"></div>
        <div id="stamina-container"><div id="stamina-bar"></div></div>
        <div id="powerups-display">
            <div class="powerup-slot" id="slot-ice"><span style="color:#666;font-size:28px;">‚ùÑÔ∏è</span></div>
            <div class="powerup-slot" id="slot-speed"><span style="color:#666;font-size:28px;">‚ö°</span></div>
            <div class="powerup-slot" id="slot-shield"><span style="color:#666;font-size:28px;">üõ°Ô∏è</span></div>
        </div>
        <div id="warning">‚ö†Ô∏è HE'S CLOSE ‚ö†Ô∏è</div>
        <div id="shield-indicator">üõ°Ô∏è SHIELD ACTIVE</div>
        <div id="timer">0:00</div>
        <div id="hud-coins">üí∞ 0</div>
        <div id="minimap"><canvas id="minimap-canvas" width="180" height="180"></canvas></div>
        <div id="minimap-floor">Map: Backrooms</div>
        <div id="pickup-msg"></div>
        <div id="escape-hud">
            <div id="escape-round">Round: 1</div>
            <div id="escape-door-indicator">üö™ FIND THE EXIT!</div>
        </div>
    </div>
    
    <div class="vignette" id="vignette" style="display: none;"></div>
    <div id="fear-overlay"></div>
    <div id="freeze-overlay"></div>

    <!-- PAUSE SCREEN -->
    <div id="pause-screen">
        <h1>‚è∏Ô∏è PAUSED</h1>
        <div class="menu-section">
            <div class="settings-row">
                <label>Music Volume:</label>
                <input type="range" id="pause-volume" min="0" max="100" value="100" onchange="updateMusicVolume()">
            </div>
            <div class="settings-row">
                <label>Sensitivity:</label>
                <input type="range" id="pause-sensitivity" min="1" max="10" value="5" onchange="updateSensitivity()">
            </div>
        </div>
        <button class="menu-btn" onclick="resumeGame()">RESUME</button>
        <button class="menu-btn secondary" onclick="quitGame()">QUIT (Lose Coins)</button>
    </div>

    <!-- DEATH SCREEN -->
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Kanye caught you...</p>
        <p id="survival-time">Survived: 0:00</p>
        <p class="coins-earned" id="coins-earned">+0 coins</p>
        <button class="menu-btn" onclick="restartGame()">TRY AGAIN</button>
        <button class="menu-btn secondary" onclick="returnToMenu()">MAIN MENU</button>
    </div>

    <script>
        // ============ PLAYCANVAS APPLICATION ============
        const canvas = document.getElementById('application-canvas');
        const app = new pc.Application(canvas, {
            mouse: new pc.Mouse(canvas),
            keyboard: new pc.Keyboard(window),
            graphicsDeviceOptions: {
                antialias: true,
                alpha: false,
                preserveDrawingBuffer: false,
                preferWebGl2: true
            }
        });
        
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        
        // Graphics quality settings
        let graphicsQuality = 'medium';
        
        function applyGraphicsSettings() {
            switch(graphicsQuality) {
                case 'low':
                    app.graphicsDevice.maxPixelRatio = 0.75;
                    break;
                case 'medium':
                    app.graphicsDevice.maxPixelRatio = 1;
                    break;
                case 'high':
                    app.graphicsDevice.maxPixelRatio = 1.5;
                    break;
                case 'ultra':
                    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
                    break;
            }
        }
        
        // ============ SAVE DATA ============
        let saveData = {
            coins: 0,
            highscores: [],
            escapeRecord: 0,
            ownedSkins: ['default'],
            selectedSkin: 'default',
            upgrades: { ice: 0, speed: 0, shield: 0 },
            settings: { 
                sprintKey: 'ShiftLeft', 
                sensitivity: 5, 
                musicVolume: 100, 
                minimapEnabled: true,
                graphicsQuality: 'medium'
            }
        };

        function loadSaveData() {
            try {
                const saved = localStorage.getItem('oliveDelightsPC');
                if (saved) saveData = { ...saveData, ...JSON.parse(saved) };
            } catch(e) {}
            graphicsQuality = saveData.settings.graphicsQuality || 'medium';
            updateUI();
        }

        function saveSaveData() {
            try { localStorage.setItem('oliveDelightsPC', JSON.stringify(saveData)); } catch(e) {}
        }

        // ============ SHOP DATA ============
        const SKINS = [
            { id: 'default', name: 'Classic Kanye', url: 'https://joercat.github.io/kanye.png', cost: 0 },
            { id: 'kanye2', name: 'Weird Kanye', url: 'https://joercat.github.io/kanye2.png', cost: 50 },
            { id: 'kanye3', name: 'Anime Kanye', url: 'https://joercat.github.io/kanye3.png', cost: 45 },
            { id: 'kanye4', name: 'Christmas Kanye', url: 'https://joercat.github.io/kanye4.png', cost: 55 },
            { id: 'kanye5', name: 'Fih', url: 'https://joercat.github.io/kanye5.png', cost: 50 },
            { id: 'kanye6', name: 'Obunga', url: 'https://joercat.github.io/knaye6.png', cost: 50 }
        ];

        const UPGRADES = {
            ice: [
                { level: 1, cost: 10, desc: '+1 sec freeze' },
                { level: 2, cost: 15, desc: '+3 sec freeze' },
                { level: 3, cost: 25, desc: '+3 sec freeze + 3 sec half speed' }
            ],
            speed: [
                { level: 1, cost: 10, desc: '+3 sec duration' },
                { level: 2, cost: 15, desc: '+5 sec duration' },
                { level: 3, cost: 25, desc: '+5 sec + speed boost' }
            ],
            shield: [
                { level: 1, cost: 10, desc: '+1 sec freeze on block' },
                { level: 2, cost: 15, desc: '+2 sec freeze on block' },
                { level: 3, cost: 25, desc: '2 hits + 2 sec freeze' }
            ]
        };

        // ============ GAME STATE ============
        let gameStarted = false;
        let isPaused = false;
        let isDead = false;
        let startTime = 0;
        let sessionCoins = 0;
        let sprintKeyCode = 'ShiftLeft';
        let mouseSensitivity = 0.002;
        let musicVolumeMultiplier = 1;
        let isEscapeMode = false;
        let escapeRound = 0;
        let baseGridSize = 25;
        let isLocked = false;

        // ============ MAP CONFIG ============
        const CELL = 4;
        let GRID_SIZE = 25;
        const WALL_H = 3.5;
        
        let maze = [];
        let walkableCells = [];
        let currentMap = 'backrooms';
        let decorations = [];
        
        // ============ ENTITIES ============
        let cameraEntity = null;
        let kanyeEntity = null;
        let escapeDoorEntity = null;
        const powerupEntities = [];
        const coinEntities = [];
        const wallEntities = [];
        const decorationEntities = [];
        const lightEntities = [];
        
        const POWERUP_TYPES = ['ice', 'speed', 'shield'];

        // ============ PLAYER ============
        const player = {
            x: 0, y: 1.6, z: 0,
            yaw: 0, pitch: 0,
            onGround: true, vy: 0,
            shieldHits: 0,
            infiniteStamina: false,
            infiniteStaminaTimer: 0,
            speedBoost: false,
            speedBoostTimer: 0
        };

        // ============ KANYE ============
        const kanye = {
            x: 0, z: 0, y: 1.25, vx: 0, vz: 0,
            pathTimer: 0,
            path: [], pathIndex: 0,
            frozen: false, frozenTimer: 0,
            halfSpeed: false, halfSpeedTimer: 0,
            turnSpeed: 3.5, maxSpeed: 7.5,
            currentSkinUrl: ''
        };

        // ============ INPUT ============
        const keys = {};
        let stamina = 100;
        let isSprinting = false;

        // ============ AUDIO ============
        let audioCtx, audioBuffer, audioSource, gainNode;
        let audioReady = false;
        let audioPlaying = false;

        // ============ TEXTURES & MATERIALS ============
        const assets = {};
        let texturesLoaded = false;
        
        // ============ UI FUNCTIONS ============
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tab-' + tabId).classList.add('active');
            event.target.classList.add('active');
        }

        function updateUI() {
            document.getElementById('total-coins').textContent = saveData.coins;
            document.getElementById('sprint-key-display').textContent = 
                saveData.settings.sprintKey.replace('ShiftLeft', 'SHIFT').replace('ShiftRight', 'R-SHIFT')
                .replace('ControlLeft', 'CTRL').replace('KeyC', 'C');
            
            // Highscores
            const hsDiv = document.getElementById('highscores');
            hsDiv.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const time = saveData.highscores[i];
                const span = document.createElement('span');
                if (time) {
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    span.textContent = `${i + 1}. ${mins}:${secs.toString().padStart(2, '0')}`;
                } else {
                    span.textContent = `${i + 1}. --:--`;
                }
                hsDiv.appendChild(span);
            }
            
            // Skins shop
            const skinShop = document.getElementById('skin-shop');
            skinShop.innerHTML = '';
            SKINS.forEach(skin => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (saveData.ownedSkins.includes(skin.id)) div.classList.add('owned');
                if (saveData.selectedSkin === skin.id) div.classList.add('selected');
                div.innerHTML = `<img src="${skin.url}"><br><small>${skin.name}</small><br>`;
                if (!saveData.ownedSkins.includes(skin.id)) {
                    div.innerHTML += `<button class="menu-btn small" onclick="buySkin('${skin.id}')">${skin.cost} üí∞</button>`;
                } else if (saveData.selectedSkin !== skin.id) {
                    div.innerHTML += `<button class="menu-btn small" onclick="selectSkin('${skin.id}')">SELECT</button>`;
                } else {
                    div.innerHTML += `<small style="color:#4ade80;">EQUIPPED</small>`;
                }
                skinShop.appendChild(div);
            });
            
            // Upgrades
            ['ice', 'speed', 'shield'].forEach(type => {
                const container = document.getElementById(type + '-upgrades');
                container.innerHTML = '';
                UPGRADES[type].forEach((upg, idx) => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    if (saveData.upgrades[type] >= upg.level) div.classList.add('owned');
                    div.innerHTML = `<span>Lv${upg.level}: ${upg.desc}</span>`;
                    if (saveData.upgrades[type] >= upg.level) {
                        div.innerHTML += `<span style="color:#4ade80;">‚úì</span>`;
                    } else if (saveData.upgrades[type] === upg.level - 1) {
                        div.innerHTML += `<button class="menu-btn small" onclick="buyUpgrade('${type}', ${upg.level})">${upg.cost} üí∞</button>`;
                    } else {
                        div.innerHTML += `<span style="color:#666;">üîí</span>`;
                    }
                    container.appendChild(div);
                });
            });
            
            // Settings
            document.getElementById('sprint-key-select').value = saveData.settings.sprintKey;
            document.getElementById('sensitivity').value = saveData.settings.sensitivity;
            document.getElementById('music-volume').value = saveData.settings.musicVolume;
            document.getElementById('minimap-toggle').checked = saveData.settings.minimapEnabled !== false;
            document.getElementById('graphics-quality').value = saveData.settings.graphicsQuality || 'medium';
            
            sprintKeyCode = saveData.settings.sprintKey;
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            
            const minimapVisible = saveData.settings.minimapEnabled !== false;
            document.getElementById('minimap').style.display = minimapVisible ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = minimapVisible ? 'block' : 'none';
            
            document.getElementById('escape-record').textContent = 'Best: ' + saveData.escapeRecord + ' escapes';
        }

        function buySkin(skinId) {
            const skin = SKINS.find(s => s.id === skinId);
            if (skin && saveData.coins >= skin.cost && !saveData.ownedSkins.includes(skinId)) {
                saveData.coins -= skin.cost;
                saveData.ownedSkins.push(skinId);
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function selectSkin(skinId) {
            if (saveData.ownedSkins.includes(skinId)) {
                saveData.selectedSkin = skinId;
                saveSaveData();
                updateUI();
            }
        }

        function buyUpgrade(type, level) {
            const upg = UPGRADES[type].find(u => u.level === level);
            if (upg && saveData.coins >= upg.cost && saveData.upgrades[type] === level - 1) {
                saveData.coins -= upg.cost;
                saveData.upgrades[type] = level;
                saveSaveData();
                updateUI();
            }
        }

        function updateSprintKey() {
            saveData.settings.sprintKey = document.getElementById('sprint-key-select').value;
            sprintKeyCode = saveData.settings.sprintKey;
            saveSaveData();
            updateUI();
        }

        function updateSensitivity() {
            const val = document.getElementById('sensitivity').value || document.getElementById('pause-sensitivity').value;
            saveData.settings.sensitivity = parseInt(val);
            mouseSensitivity = saveData.settings.sensitivity * 0.0004;
            saveSaveData();
        }

        function updateMusicVolume() {
            const val = document.getElementById('music-volume').value || document.getElementById('pause-volume').value;
            saveData.settings.musicVolume = parseInt(val);
            musicVolumeMultiplier = saveData.settings.musicVolume / 100;
            saveSaveData();
        }

        function updateMinimapToggle() {
            saveData.settings.minimapEnabled = document.getElementById('minimap-toggle').checked;
            saveSaveData();
            document.getElementById('minimap').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
            document.getElementById('minimap-floor').style.display = saveData.settings.minimapEnabled ? 'block' : 'none';
        }
        
        function updateGraphicsQuality() {
            graphicsQuality = document.getElementById('graphics-quality').value;
            saveData.settings.graphicsQuality = graphicsQuality;
            saveSaveData();
            applyGraphicsSettings();
        }

        // ============ TEXTURE LOADING ============
        function updateLoadingProgress(text) {
            document.getElementById('loading-progress').textContent = text;
        }
        
        function loadTextures(callback) {
            updateLoadingProgress('Loading textures...');
            
            const textureUrls = {
                wall: 'https://joercat.github.io/wall.png',
                floor: 'https://joercat.github.io/floor.jpg',
                kanye: SKINS.find(s => s.id === saveData.selectedSkin)?.url || SKINS[0].url,
                ice: 'https://joercat.github.io/ice.png',
                speed: 'https://joercat.github.io/speed.png',
                shield: 'https://joercat.github.io/shield.png',
                coin: 'https://joercat.github.io/coin.png'
            };
            
            let loaded = 0;
            const total = Object.keys(textureUrls).length;
            
            for (const [name, url] of Object.entries(textureUrls)) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const texture = new pc.Texture(app.graphicsDevice, {
                        width: img.width,
                        height: img.height,
                        format: pc.PIXELFORMAT_RGBA8,
                        mipmaps: true,
                        minFilter: pc.FILTER_LINEAR_MIPMAP_LINEAR,
                        magFilter: pc.FILTER_LINEAR,
                        addressU: pc.ADDRESS_REPEAT,
                        addressV: pc.ADDRESS_REPEAT,
                        anisotropy: 8
                    });
                    
                    texture.setSource(img);
                    assets[name] = texture;
                    
                    loaded++;
                    updateLoadingProgress(`Loading textures... (${loaded}/${total})`);
                    
                    if (loaded === total) {
                        texturesLoaded = true;
                        callback();
                    }
                };
                img.onerror = () => {
                    loaded++;
                    if (loaded === total) {
                        texturesLoaded = true;
                        callback();
                    }
                };
                img.src = url;
            }
        }

        // ============ AUDIO ============
        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioCtx.createGain();
                gainNode.gain.value = 0;
                gainNode.connect(audioCtx.destination);
                
                const resp = await fetch('https://joercat.github.io/olive.wav');
                const buf = await resp.arrayBuffer();
                audioBuffer = await audioCtx.decodeAudioData(buf);
                audioReady = true;
            } catch(e) { console.log('Audio failed:', e); }
        }

        function setAudioVolume(vol) {
            if (!audioReady) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (isPaused) {
                if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                return;
            }
            
            if (!audioPlaying && vol > 0) {
                audioSource = audioCtx.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.loop = true;
                audioSource.connect(gainNode);
                audioSource.start();
                audioPlaying = true;
            }
            
            const finalVol = Math.min(1, vol * musicVolumeMultiplier);
            if (gainNode) gainNode.gain.setTargetAtTime(finalVol, audioCtx.currentTime, 0.1);
        }

        function stopAudio() {
            if (audioSource) { try { audioSource.stop(); } catch(e) {} audioSource = null; audioPlaying = false; }
            if (gainNode) gainNode.gain.value = 0;
        }
        
        function pauseAudio() {
            if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        }

        // ============ MAZE GENERATION ============
        function generateMaze() {
            maze = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                maze[x] = [];
                for (let z = 0; z < GRID_SIZE; z++) {
                    maze[x][z] = 1;
                }
            }

            if (currentMap === 'warehouse') {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    for (let z = 1; z < GRID_SIZE - 1; z++) {
                        maze[x][z] = 0;
                    }
                }
                for (let x = 3; x < GRID_SIZE - 3; x += 4) {
                    for (let z = 3; z < GRID_SIZE - 3; z += 4) {
                        if (Math.random() < 0.35) {
                            maze[x][z] = 1;
                            if (Math.random() < 0.3 && x + 1 < GRID_SIZE - 2) maze[x+1][z] = 1;
                            if (Math.random() < 0.3 && z + 1 < GRID_SIZE - 2) maze[x][z+1] = 1;
                        }
                    }
                }
            } else {
                const stack = [];
                maze[1][1] = 0;
                stack.push({x: 1, z: 1});

                while (stack.length > 0) {
                    const cur = stack[stack.length - 1];
                    const dirs = [{dx: 0, dz: -2}, {dx: 0, dz: 2}, {dx: -2, dz: 0}, {dx: 2, dz: 0}];
                    
                    for (let i = dirs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                    }

                    let found = false;
                    for (const d of dirs) {
                        const nx = cur.x + d.dx;
                        const nz = cur.z + d.dz;
                        
                        if (nx > 0 && nx < GRID_SIZE - 1 && nz > 0 && nz < GRID_SIZE - 1 && maze[nx][nz] === 1) {
                            maze[cur.x + d.dx / 2][cur.z + d.dz / 2] = 0;
                            maze[nx][nz] = 0;
                            stack.push({x: nx, z: nz});
                            found = true;
                            break;
                        }
                    }
                    if (!found) stack.pop();
                }

                for (let x = 2; x < GRID_SIZE - 2; x++) {
                    for (let z = 2; z < GRID_SIZE - 2; z++) {
                        if (maze[x][z] === 1 && Math.random() < 0.2) {
                            let floors = 0;
                            if (maze[x-1][z] === 0) floors++;
                            if (maze[x+1][z] === 0) floors++;
                            if (maze[x][z-1] === 0) floors++;
                            if (maze[x][z+1] === 0) floors++;
                            if (floors >= 2) maze[x][z] = 0;
                        }
                    }
                }
            }

            walkableCells = [];
            for (let x = 1; x < GRID_SIZE - 1; x++) {
                for (let z = 1; z < GRID_SIZE - 1; z++) {
                    if (maze[x][z] === 0) walkableCells.push({x, z});
                }
            }
        }

        // ============ COORDINATE HELPERS ============
        function gridToWorld(gx, gz) {
            return { x: (gx - GRID_SIZE / 2 + 0.5) * CELL, z: (gz - GRID_SIZE / 2 + 0.5) * CELL };
        }

        function worldToGrid(wx, wz) {
            return { x: Math.floor(wx / CELL + GRID_SIZE / 2), z: Math.floor(wz / CELL + GRID_SIZE / 2) };
        }

        function isWalkableWorld(wx, wz, radius = 0.35) {
            const checks = [
                {x: wx, z: wz},
                {x: wx - radius, z: wz - radius},
                {x: wx + radius, z: wz - radius},
                {x: wx - radius, z: wz + radius},
                {x: wx + radius, z: wz + radius}
            ];
            
            for (const c of checks) {
                const g = worldToGrid(c.x, c.z);
                if (g.x < 0 || g.x >= GRID_SIZE || g.z < 0 || g.z >= GRID_SIZE) return false;
                if (!maze[g.x] || maze[g.x][g.z] !== 0) return false;
            }
            
            for (const d of decorations) {
                const dist = Math.hypot(wx - d.x, wz - d.z);
                const canJumpOver = d.height && d.height < 1.0 && player.y > 2.0;
                if (dist < d.radius + radius && !canJumpOver) return false;
            }
            
            return true;
        }

        function isWalkableGrid(gx, gz) {
            if (gx < 0 || gx >= GRID_SIZE || gz < 0 || gz >= GRID_SIZE) return false;
            if (!maze[gx] || maze[gx][gz] !== 0) return false;
            const worldPos = gridToWorld(gx, gz);
            for (const d of decorations) {
                if (Math.hypot(worldPos.x - d.x, worldPos.z - d.z) < d.radius + 1.0) {
                    return false;
                }
            }
            return true;
        }

        // ============ CLEAR WORLD ============
        function clearWorld() {
            // Remove all wall entities
            wallEntities.forEach(e => e.destroy());
            wallEntities.length = 0;
            
            // Remove decorations
            decorationEntities.forEach(e => e.destroy());
            decorationEntities.length = 0;
            decorations = [];
            
            // Remove lights
            lightEntities.forEach(e => e.destroy());
            lightEntities.length = 0;
            
            // Remove powerups
            powerupEntities.forEach(p => { if (p.entity) p.entity.destroy(); });
            powerupEntities.length = 0;
            
            // Remove coins
            coinEntities.forEach(c => { if (c.entity) c.entity.destroy(); });
            coinEntities.length = 0;
            
            // Remove kanye
            if (kanyeEntity) {
                kanyeEntity.destroy();
                kanyeEntity = null;
            }
            
            // Remove escape door
            if (escapeDoorEntity) {
                escapeDoorEntity.destroy();
                escapeDoorEntity = null;
            }
        }

        // ============ BUILD WORLD ============
        function buildWorld() {
            updateLoadingProgress('Building world...');
            
            // Get map-specific colors and fog
            let wallColor, floorColor, ceilColor, fogColor, fogDensity, ambientColor;
            
            if (currentMap === 'backrooms') {
                wallColor = new pc.Color(0.85, 0.78, 0.55);
                floorColor = new pc.Color(0.4, 0.35, 0.25);
                ceilColor = new pc.Color(0.15, 0.15, 0.15);
                fogColor = new pc.Color(0.1, 0.1, 0.1);
                fogDensity = 0.03;
                ambientColor = new pc.Color(0.5, 0.45, 0.35);
            } else if (currentMap === 'warehouse') {
                wallColor = new pc.Color(0.3, 0.3, 0.3);
                floorColor = new pc.Color(0.22, 0.22, 0.22);
                ceilColor = new pc.Color(0.1, 0.1, 0.1);
                fogColor = new pc.Color(0.04, 0.04, 0.04);
                fogDensity = 0.025;
                ambientColor = new pc.Color(0.4, 0.4, 0.4);
            } else if (currentMap === 'hospital') {
                wallColor = new pc.Color(0.83, 0.9, 0.83);
                floorColor = new pc.Color(0.9, 0.9, 0.9);
                ceilColor = new pc.Color(0.95, 0.95, 0.95);
                fogColor = new pc.Color(0.1, 0.15, 0.1);
                fogDensity = 0.025;
                ambientColor = new pc.Color(0.6, 0.65, 0.6);
            }
            
            // Set fog
            app.scene.fog = pc.FOG_EXP2;
            app.scene.fogColor = fogColor;
            app.scene.fogDensity = fogDensity;
            
            // Set ambient light
            app.scene.ambientLight = ambientColor;
            
            // Create wall material with improved graphics
            const wallMaterial = new pc.StandardMaterial();
            if (assets.wall && currentMap === 'backrooms') {
                wallMaterial.diffuseMap = assets.wall;
                wallMaterial.diffuseMapTiling = new pc.Vec2(2, 2);
            } else {
                wallMaterial.diffuse = wallColor;
            }
            wallMaterial.specular = new pc.Color(0.1, 0.1, 0.1);
            wallMaterial.shininess = 10;
            wallMaterial.update();
            
            // Create floor material
            const floorMaterial = new pc.StandardMaterial();
            if (assets.floor && currentMap === 'backrooms') {
                floorMaterial.diffuseMap = assets.floor;
                floorMaterial.diffuseMapTiling = new pc.Vec2(GRID_SIZE * 2, GRID_SIZE * 2);
            } else {
                floorMaterial.diffuse = floorColor;
            }
            floorMaterial.specular = new pc.Color(0.05, 0.05, 0.05);
            floorMaterial.shininess = 5;
            floorMaterial.update();
            
            // Create ceiling material
            const ceilMaterial = new pc.StandardMaterial();
            ceilMaterial.diffuse = ceilColor;
            ceilMaterial.emissive = new pc.Color(0.02, 0.02, 0.02);
            ceilMaterial.update();
            
            // Build walls with instancing for performance
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x][z] === 1) {
                        const pos = gridToWorld(x, z);
                        const wallEntity = new pc.Entity('wall');
                        wallEntity.addComponent('render', {
                            type: 'box',
                            material: wallMaterial,
                            castShadows: graphicsQuality !== 'low',
                            receiveShadows: graphicsQuality !== 'low'
                        });
                        wallEntity.setLocalScale(CELL, WALL_H, CELL);
                        wallEntity.setPosition(pos.x, WALL_H / 2, pos.z);
                        app.root.addChild(wallEntity);
                        wallEntities.push(wallEntity);
                    }
                }
            }
            
            // Create floor
            const floorEntity = new pc.Entity('floor');
            floorEntity.addComponent('render', {
                type: 'plane',
                material: floorMaterial,
                receiveShadows: true
            });
            floorEntity.setLocalScale(GRID_SIZE * CELL, 1, GRID_SIZE * CELL);
            floorEntity.setPosition(0, 0.01, 0);
            app.root.addChild(floorEntity);
            wallEntities.push(floorEntity);
            
            // Create ceiling
            const ceilEntity = new pc.Entity('ceiling');
            ceilEntity.addComponent('render', {
                type: 'plane',
                material: ceilMaterial
            });
            ceilEntity.setLocalScale(GRID_SIZE * CELL, 1, GRID_SIZE * CELL);
            ceilEntity.setPosition(0, WALL_H, 0);
            ceilEntity.setEulerAngles(180, 0, 0);
            app.root.addChild(ceilEntity);
            wallEntities.push(ceilEntity);
            
            // Add ceiling lights for better graphics
            if (graphicsQuality !== 'low') {
                addCeilingLights();
            }
            
            // Add map-specific decorations
            if (currentMap === 'warehouse') {
                addWarehouseDecorations();
            } else if (currentMap === 'hospital') {
                addHospitalDecorations();
            }
            
            // Add directional light for shadows
            const dirLight = new pc.Entity('dirLight');
            dirLight.addComponent('light', {
                type: 'directional',
                color: new pc.Color(1, 0.95, 0.9),
                intensity: 0.3,
                castShadows: graphicsQuality === 'high' || graphicsQuality === 'ultra',
                shadowBias: 0.2,
                shadowDistance: 40,
                shadowResolution: graphicsQuality === 'ultra' ? 2048 : 1024
            });
            dirLight.setEulerAngles(60, 30, 0);
            app.root.addChild(dirLight);
            lightEntities.push(dirLight);
        }
        
        function addCeilingLights() {
            // Add point lights at intervals for ambient lighting
            const spacing = 8;
            for (let x = -GRID_SIZE/2 * CELL + spacing; x < GRID_SIZE/2 * CELL; x += spacing * 2) {
                for (let z = -GRID_SIZE/2 * CELL + spacing; z < GRID_SIZE/2 * CELL; z += spacing * 2) {
                    const gx = Math.floor(x / CELL + GRID_SIZE / 2);
                    const gz = Math.floor(z / CELL + GRID_SIZE / 2);
                    if (gx >= 0 && gx < GRID_SIZE && gz >= 0 && gz < GRID_SIZE && maze[gx][gz] === 0) {
                        // Create light fixture visual
                        const fixture = new pc.Entity('lightFixture');
                        const fixtureMat = new pc.StandardMaterial();
                        fixtureMat.diffuse = new pc.Color(0.3, 0.3, 0.3);
                        fixtureMat.emissive = new pc.Color(1, 0.95, 0.85);
                        fixtureMat.emissiveIntensity = 2;
                        fixtureMat.update();
                        
                        fixture.addComponent('render', {
                            type: 'box',
                            material: fixtureMat
                        });
                        fixture.setLocalScale(0.8, 0.1, 0.4);
                        fixture.setPosition(x, WALL_H - 0.1, z);
                        app.root.addChild(fixture);
                        decorationEntities.push(fixture);
                        
                        // Add point light
                        if (graphicsQuality === 'high' || graphicsQuality === 'ultra') {
                            const light = new pc.Entity('ceilingLight');
                            light.addComponent('light', {
                                type: 'point',
                                color: new pc.Color(1, 0.95, 0.85),
                                intensity: 0.8,
                                range: 12,
                                castShadows: false
                            });
                            light.setPosition(x, WALL_H - 0.3, z);
                            app.root.addChild(light);
                            lightEntities.push(light);
                        }
                    }
                }
            }
        }
        
        function addWarehouseDecorations() {
            const crateMat = new pc.StandardMaterial();
            crateMat.diffuse = new pc.Color(0.55, 0.27, 0.07);
            crateMat.specular = new pc.Color(0.1, 0.05, 0.02);
            crateMat.shininess = 5;
            crateMat.update();
            
            const barrelMat = new pc.StandardMaterial();
            barrelMat.diffuse = new pc.Color(0.13, 0.33, 0.67);
            barrelMat.metalness = 0.3;
            barrelMat.shininess = 30;
            barrelMat.update();
            
            const shelfMat = new pc.StandardMaterial();
            shelfMat.diffuse = new pc.Color(0.35, 0.35, 0.35);
            shelfMat.metalness = 0.5;
            shelfMat.shininess = 40;
            shelfMat.update();
            
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(25, shuffled.length);
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const offsetX = (Math.random() - 0.5) * CELL * 0.3;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.3;
                const finalX = pos.x + offsetX;
                const finalZ = pos.z + offsetZ;
                
                let tooClose = false;
                for (const d of decorations) {
                    if (Math.hypot(finalX - d.x, finalZ - d.z) < 4.0) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;
                
                if (Math.random() < 0.6) {
                    // Crate stack
                    const stackHeight = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < stackHeight; j++) {
                        const crate = new pc.Entity('crate');
                        crate.addComponent('render', {
                            type: 'box',
                            material: crateMat,
                            castShadows: graphicsQuality !== 'low'
                        });
                        crate.setLocalScale(1.2, 1.0, 1.2);
                        crate.setPosition(finalX, 0.5 + j * 1.0, finalZ);
                        app.root.addChild(crate);
                        decorationEntities.push(crate);
                    }
                    decorations.push({ x: finalX, z: finalZ, radius: 0.7, height: stackHeight * 1.0 });
                } else {
                    // Barrel
                    const barrel = new pc.Entity('barrel');
                    barrel.addComponent('render', {
                        type: 'cylinder',
                        material: barrelMat,
                        castShadows: graphicsQuality !== 'low'
                    });
                    barrel.setLocalScale(1.0, 1.4, 1.0);
                    barrel.setPosition(finalX, 0.7, finalZ);
                    app.root.addChild(barrel);
                    decorationEntities.push(barrel);
                    decorations.push({ x: finalX, z: finalZ, radius: 0.55, height: 1.4 });
                }
            }
            
            // Shelving units
            for (let x = 2; x < GRID_SIZE - 2; x += 3) {
                for (let edge of [1, GRID_SIZE - 2]) {
                    if (maze[x] && maze[x][edge] === 0) {
                        const pos = gridToWorld(x, edge);
                        const shelf = new pc.Entity('shelf');
                        shelf.addComponent('render', {
                            type: 'box',
                            material: shelfMat,
                            castShadows: graphicsQuality !== 'low'
                        });
                        shelf.setLocalScale(2.0, WALL_H * 0.8, 1.0);
                        shelf.setPosition(pos.x, WALL_H * 0.4, pos.z);
                        app.root.addChild(shelf);
                        decorationEntities.push(shelf);
                        decorations.push({ x: pos.x, z: pos.z, radius: 1.1, height: WALL_H * 0.8 });
                    }
                }
            }
        }
        
        function addHospitalDecorations() {
            const gurneyMat = new pc.StandardMaterial();
            gurneyMat.diffuse = new pc.Color(0.67, 0.67, 0.67);
            gurneyMat.metalness = 0.6;
            gurneyMat.shininess = 60;
            gurneyMat.update();
            
            const sheetMat = new pc.StandardMaterial();
            sheetMat.diffuse = new pc.Color(0.95, 0.95, 0.95);
            sheetMat.update();
            
            const bloodMat = new pc.StandardMaterial();
            bloodMat.diffuse = new pc.Color(0.55, 0, 0);
            bloodMat.emissive = new pc.Color(0.1, 0, 0);
            bloodMat.update();
            
            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            const decorCount = Math.min(20, shuffled.length);
            
            for (let i = 0; i < decorCount; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const offsetX = (Math.random() - 0.5) * CELL * 0.25;
                const offsetZ = (Math.random() - 0.5) * CELL * 0.25;
                const finalX = pos.x + offsetX;
                const finalZ = pos.z + offsetZ;
                
                let tooClose = false;
                for (const d of decorations) {
                    if (Math.hypot(finalX - d.x, finalZ - d.z) < 4.5) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;
                
                const type = Math.random();
                
                if (type < 0.4) {
                    // Gurney
                    const gurneyGroup = new pc.Entity('gurney');
                    
                    const frame = new pc.Entity('frame');
                    frame.addComponent('render', { type: 'box', material: gurneyMat });
                    frame.setLocalScale(1.0, 0.1, 2.2);
                    frame.setPosition(0, 0.7, 0);
                    gurneyGroup.addChild(frame);
                    
                    const sheet = new pc.Entity('sheet');
                    sheet.addComponent('render', { type: 'box', material: sheetMat });
                    sheet.setLocalScale(0.9, 0.2, 2.0);
                    sheet.setPosition(0, 0.85, 0);
                    gurneyGroup.addChild(sheet);
                    
                    for (let lx = -0.4; lx <= 0.4; lx += 0.8) {
                        for (let lz = -0.9; lz <= 0.9; lz += 1.8) {
                            const leg = new pc.Entity('leg');
                            leg.addComponent('render', { type: 'box', material: gurneyMat });
                            leg.setLocalScale(0.1, 0.7, 0.1);
                            leg.setPosition(lx, 0.35, lz);
                            gurneyGroup.addChild(leg);
                        }
                    }
                    
                    gurneyGroup.setPosition(finalX, 0, finalZ);
                    gurneyGroup.setEulerAngles(0, Math.random() * 360, 0);
                    app.root.addChild(gurneyGroup);
                    decorationEntities.push(gurneyGroup);
                    decorations.push({ x: finalX, z: finalZ, radius: 1.2, height: 0.85 });
                    
                } else if (type < 0.7) {
                    // IV Stand
                    const stand = new pc.Entity('ivStand');
                    stand.addComponent('render', { type: 'cylinder', material: gurneyMat });
                    stand.setLocalScale(0.16, 1.8, 0.16);
                    stand.setPosition(finalX, 0.9, finalZ);
                    app.root.addChild(stand);
                    decorationEntities.push(stand);
                    decorations.push({ x: finalX, z: finalZ, radius: 0.3, height: 1.8 });
                    
                } else {
                    // Blood stain
                    const stain = new pc.Entity('blood');
                    stain.addComponent('render', { type: 'plane', material: bloodMat });
                    const size = 0.6 + Math.random() * 0.6;
                    stain.setLocalScale(size, 1, size);
                    stain.setPosition(finalX, 0.02, finalZ);
                    app.root.addChild(stain);
                    decorationEntities.push(stain);
                }
            }
        }

        // ============ CREATE KANYE ============
        function createKanye() {
            const skinUrl = SKINS.find(s => s.id === saveData.selectedSkin)?.url || SKINS[0].url;
            kanye.currentSkinUrl = skinUrl;
            
            // Create billboard sprite for Kanye
            kanyeEntity = new pc.Entity('kanye');
            
            // Load texture dynamically
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const texture = new pc.Texture(app.graphicsDevice, {
                    width: img.width,
                    height: img.height,
                    format: pc.PIXELFORMAT_RGBA8
                });
                texture.setSource(img);
                
                const material = new pc.StandardMaterial();
                material.diffuseMap = texture;
                material.emissive = new pc.Color(0.1, 0.1, 0.1);
                material.opacityMap = texture;
                material.opacityMapChannel = 'a';
                material.blendType = pc.BLEND_NORMAL;
                material.depthWrite = false;
                material.cull = pc.CULLFACE_NONE;
                material.update();
                
                kanyeEntity.addComponent('render', {
                    type: 'plane',
                    material: material
                });
                kanyeEntity.setLocalScale(2.5, 2.5, 1);
            };
            img.src = skinUrl;
            
            app.root.addChild(kanyeEntity);
            kanyeEntity.setPosition(kanye.x, kanye.y, kanye.z);
        }

        // ============ CREATE POWERUPS ============
        function createPowerups() {
            powerupEntities.forEach(p => { if (p.entity) p.entity.destroy(); });
            powerupEntities.length = 0;

            const shuffled = [...walkableCells].sort(() => Math.random() - 0.5);
            
            const powerupTextures = {
                ice: assets.ice,
                speed: assets.speed,
                shield: assets.shield
            };
            
            const powerupColors = {
                ice: new pc.Color(0.5, 0.8, 1),
                speed: new pc.Color(1, 0.8, 0.2),
                shield: new pc.Color(0.3, 1, 0.5)
            };

            for (let i = 0; i < 12 && i < shuffled.length; i++) {
                const type = POWERUP_TYPES[i % 3];
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const powerupEntity = new pc.Entity('powerup_' + type);
                
                // Create material with texture or color
                const material = new pc.StandardMaterial();
                if (powerupTextures[type]) {
                    material.diffuseMap = powerupTextures[type];
                    material.opacityMap = powerupTextures[type];
                    material.opacityMapChannel = 'a';
                }
                material.emissive = powerupColors[type];
                material.emissiveIntensity = 0.5;
                material.blendType = pc.BLEND_NORMAL;
                material.cull = pc.CULLFACE_NONE;
                material.depthWrite = false;
                material.update();
                
                powerupEntity.addComponent('render', {
                    type: 'plane',
                    material: material
                });
                powerupEntity.setLocalScale(1.2, 1.2, 1);
                powerupEntity.setPosition(pos.x, 0.8, pos.z);
                
                // Add point light for glow effect
                if (graphicsQuality !== 'low') {
                    const light = new pc.Entity('powerupLight');
                    light.addComponent('light', {
                        type: 'point',
                        color: powerupColors[type],
                        intensity: 0.5,
                        range: 3,
                        castShadows: false
                    });
                    light.setPosition(0, 0, 0);
                    powerupEntity.addChild(light);
                }
                
                app.root.addChild(powerupEntity);
                
                powerupEntities.push({
                    type: type,
                    x: pos.x,
                    z: pos.z,
                    entity: powerupEntity,
                    collected: false
                });
            }
        }

        // ============ CREATE COINS ============
        function createCoins() {
            coinEntities.forEach(c => { if (c.entity) c.entity.destroy(); });
            coinEntities.length = 0;
            spawnCoins();
        }

        function spawnCoins() {
            const available = walkableCells.filter(cell => {
                const pos = gridToWorld(cell.x, cell.z);
                return !coinEntities.some(c => !c.collected && Math.hypot(c.x - pos.x, c.z - pos.z) < 2);
            });
            
            const shuffled = available.sort(() => Math.random() - 0.5);
            const toSpawn = 5 - coinEntities.filter(c => !c.collected).length;
            
            const coinMaterial = new pc.StandardMaterial();
            if (assets.coin) {
                coinMaterial.diffuseMap = assets.coin;
                coinMaterial.opacityMap = assets.coin;
                coinMaterial.opacityMapChannel = 'a';
            } else {
                coinMaterial.diffuse = new pc.Color(1, 0.85, 0);
            }
            coinMaterial.emissive = new pc.Color(0.5, 0.4, 0);
            coinMaterial.emissiveIntensity = 0.3;
            coinMaterial.blendType = pc.BLEND_NORMAL;
            coinMaterial.cull = pc.CULLFACE_NONE;
            coinMaterial.depthWrite = false;
            coinMaterial.update();
            
            for (let i = 0; i < toSpawn && i < shuffled.length; i++) {
                const cell = shuffled[i];
                const pos = gridToWorld(cell.x, cell.z);
                
                const coinEntity = new pc.Entity('coin');
                coinEntity.addComponent('render', {
                    type: 'plane',
                    material: coinMaterial
                });
                coinEntity.setLocalScale(0.8, 0.8, 1);
                coinEntity.setPosition(pos.x, 0.6, pos.z);
                
                // Add glow
                if (graphicsQuality !== 'low') {
                    const light = new pc.Entity('coinLight');
                    light.addComponent('light', {
                        type: 'point',
                        color: new pc.Color(1, 0.85, 0),
                        intensity: 0.3,
                        range: 2,
                        castShadows: false
                    });
                    coinEntity.addChild(light);
                }
                
                app.root.addChild(coinEntity);
                
                coinEntities.push({
                    x: pos.x,
                    z: pos.z,
                    entity: coinEntity,
                    collected: false
                });
            }
        }

        // ============ CREATE ESCAPE DOOR ============
        function createEscapeDoor() {
            if (escapeDoorEntity) {
                escapeDoorEntity.destroy();
                escapeDoorEntity = null;
            }
            
            // Find valid door location
            const minDoorDist = 20;
            const doorCandidates = [];
            
            for (let x = 2; x < GRID_SIZE - 2; x++) {
                for (let z = 2; z < GRID_SIZE - 2; z++) {
                    if (maze[x][z] === 1) {
                        const adjacent = [
                            {wx: x-1, wz: z, dir: 'east'},
                            {wx: x+1, wz: z, dir: 'west'},
                            {wx: x, wz: z-1, dir: 'south'},
                            {wx: x, wz: z+1, dir: 'north'}
                        ];
                        for (const adj of adjacent) {
                            if (isWalkableGrid(adj.wx, adj.wz)) {
                                const doorPos = gridToWorld(x, z);
                                const adjPos = gridToWorld(adj.wx, adj.wz);
                                const dist = Math.hypot(doorPos.x - player.x, doorPos.z - player.z);
                                if (dist < minDoorDist) continue;
                                
                                let blocked = false;
                                for (const d of decorations) {
                                    if (Math.hypot(adjPos.x - d.x, adjPos.z - d.z) < d.radius + 0.5) {
                                        blocked = true;
                                        break;
                                    }
                                }
                                if (!blocked) {
                                    doorCandidates.push({x, z, adjX: adj.wx, adjZ: adj.wz, dir: adj.dir});
                                }
                            }
                        }
                    }
                }
            }
            
            if (doorCandidates.length === 0) return;
            
            const shuffledDoors = doorCandidates.sort(() => Math.random() - 0.5);
            const doorData = shuffledDoors[0];
            const doorWorldPos = gridToWorld(doorData.x, doorData.z);
            const adjWorldPos = gridToWorld(doorData.adjX, doorData.adjZ);
            
            // Create door entity
            escapeDoorEntity = new pc.Entity('escapeDoor');
            
            // Door frame material
            const frameMat = new pc.StandardMaterial();
            frameMat.diffuse = new pc.Color(0.24, 0.15, 0.09);
            frameMat.shininess = 20;
            frameMat.update();
            
            // Door panel material
            const doorMat = new pc.StandardMaterial();
            doorMat.diffuse = new pc.Color(0.36, 0.23, 0.13);
            doorMat.shininess = 30;
            doorMat.update();
            
            // Doorknob material
            const knobMat = new pc.StandardMaterial();
            knobMat.diffuse = new pc.Color(0.72, 0.53, 0.04);
            knobMat.metalness = 0.8;
            knobMat.shininess = 90;
            knobMat.update();
            
            // Calculate position and rotation
            let doorX = doorWorldPos.x;
            let doorZ = doorWorldPos.z;
            let rotY = 0;
            
            if (doorData.dir === 'east') {
                doorX = doorWorldPos.x - CELL/2 + 0.3;
                rotY = 90;
            } else if (doorData.dir === 'west') {
                doorX = doorWorldPos.x + CELL/2 - 0.3;
                rotY = 90;
            } else if (doorData.dir === 'south') {
                doorZ = doorWorldPos.z - CELL/2 + 0.3;
                rotY = 0;
            } else if (doorData.dir === 'north') {
                doorZ = doorWorldPos.z + CELL/2 - 0.3;
                rotY = 0;
            }
            
            // Frame parts
            const frameLeft = new pc.Entity('frameLeft');
            frameLeft.addComponent('render', { type: 'box', material: frameMat });
            frameLeft.setLocalScale(0.15, 2.8, 0.3);
            frameLeft.setLocalPosition(-0.55, 1.4, 0);
            escapeDoorEntity.addChild(frameLeft);
            
            const frameRight = new pc.Entity('frameRight');
            frameRight.addComponent('render', { type: 'box', material: frameMat });
            frameRight.setLocalScale(0.15, 2.8, 0.3);
            frameRight.setLocalPosition(0.55, 1.4, 0);
            escapeDoorEntity.addChild(frameRight);
            
            const frameTop = new pc.Entity('frameTop');
            frameTop.addComponent('render', { type: 'box', material: frameMat });
            frameTop.setLocalScale(1.25, 0.15, 0.3);
            frameTop.setLocalPosition(0, 2.75, 0);
            escapeDoorEntity.addChild(frameTop);
            
            // Door panel
            const doorPanel = new pc.Entity('doorPanel');
            doorPanel.addComponent('render', { type: 'box', material: doorMat });
            doorPanel.setLocalScale(1.0, 2.5, 0.15);
            doorPanel.setLocalPosition(0, 1.3, 0.25);
            escapeDoorEntity.addChild(doorPanel);
            
            // Doorknob
            const doorknob = new pc.Entity('doorknob');
            doorknob.addComponent('render', { type: 'sphere', material: knobMat });
            doorknob.setLocalScale(0.16, 0.16, 0.16);
            doorknob.setLocalPosition(0.35, 1.1, 0.38);
            escapeDoorEntity.addChild(doorknob);
            
            // Green glow light
            const glowLight = new pc.Entity('doorGlow');
            glowLight.addComponent('light', {
                type: 'point',
                color: new pc.Color(0.25, 1, 0.25),
                intensity: 2,
                range: 10,
                castShadows: false
            });
            glowLight.setLocalPosition(0, 1.5, 0.6);
            escapeDoorEntity.addChild(glowLight);
            
            escapeDoorEntity.setPosition(doorX, 0, doorZ);
            escapeDoorEntity.setEulerAngles(0, rotY, 0);
            app.root.addChild(escapeDoorEntity);
            
            // Store door data
            escapeDoorEntity.doorData = {
                x: adjWorldPos.x,
                z: adjWorldPos.z,
                gridX: doorData.x,
                gridZ: doorData.z
            };
        }

        // ============ SPAWN ENTITIES ============
        function spawnEntities() {
            if (walkableCells.length < 10) return;

            const pIdx = Math.floor(Math.random() * walkableCells.length);
            const pCell = walkableCells[pIdx];
            const pPos = gridToWorld(pCell.x, pCell.z);
            player.x = pPos.x;
            player.z = pPos.z;
            player.y = 1.6;
            player.yaw = 0;
            player.pitch = 0;
            player.vy = 0;
            player.onGround = true;
            player.shieldHits = 0;
            player.infiniteStamina = false;
            player.speedBoost = false;

            // Start with shield if purchased
            const shieldToggle = isEscapeMode ? 
                document.getElementById('escape-shield-toggle') : 
                document.getElementById('start-shield-toggle');
            
            if (shieldToggle && shieldToggle.checked && saveData.coins >= 5) {
                saveData.coins -= 5;
                player.shieldHits = saveData.upgrades.shield >= 3 ? 2 : 1;
                document.getElementById('shield-indicator').style.opacity = '1';
                document.getElementById('slot-shield').classList.add('active');
                saveSaveData();
                updateUI();
            }

            // Find valid spawn for Kanye
            const minSpawnDist = 20;
            const validKanyeSpawns = walkableCells.filter(c => {
                const pos = gridToWorld(c.x, c.z);
                const distFromPlayer = Math.hypot(pos.x - player.x, pos.z - player.z);
                if (distFromPlayer < minSpawnDist) return false;
                for (const d of decorations) {
                    if (Math.hypot(pos.x - d.x, pos.z - d.z) < d.radius + 0.5) return false;
                }
                return true;
            });
            
            const shuffledSpawns = validKanyeSpawns.sort(() => Math.random() - 0.5);
            let kCell = shuffledSpawns.length > 0 ? shuffledSpawns[0] : walkableCells[Math.floor(Math.random() * walkableCells.length)];
            const kPos = gridToWorld(kCell.x, kCell.z);
            kanye.x = kPos.x;
            kanye.z = kPos.z;
            kanye.vx = 0;
            kanye.vz = 0;
            kanye.pathTimer = 0;
            kanye.path = [];
            kanye.frozen = false;
            kanye.halfSpeed = false;

            if (kanyeEntity) {
                kanyeEntity.setPosition(kanye.x, kanye.y, kanye.z);
            }
            
            if (cameraEntity) {
                cameraEntity.setPosition(player.x, player.y, player.z);
            }

            createPowerups();
            createCoins();
        }

        // ============ A* PATHFINDING ============
        function findPath(startGx, startGz, endGx, endGz) {
            if (!isWalkableGrid(startGx, startGz) || !isWalkableGrid(endGx, endGz)) return [];

            const key = (x, z) => x * 1000 + z;
            const open = [{x: startGx, z: startGz, g: 0, f: 0}];
            const closed = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            gScore.set(key(startGx, startGz), 0);

            const h = (x, z) => Math.abs(x - endGx) + Math.abs(z - endGz);

            const maxIterations = GRID_SIZE > 30 ? 8000 : 3000;
            let iterations = 0;
            
            while (open.length > 0 && iterations < maxIterations) {
                iterations++;
                
                let bestIdx = 0;
                for (let i = 1; i < open.length; i++) {
                    if (open[i].f < open[bestIdx].f) bestIdx = i;
                }
                const cur = open.splice(bestIdx, 1)[0];
                const curKey = key(cur.x, cur.z);

                if (cur.x === endGx && cur.z === endGz) {
                    const path = [];
                    let k = curKey;
                    while (cameFrom.has(k)) {
                        path.unshift({x: Math.floor(k / 1000), z: k % 1000});
                        k = cameFrom.get(k);
                    }
                    return path;
                }

                closed.add(curKey);

                const neighbors = [
                    {x: cur.x + 1, z: cur.z},
                    {x: cur.x - 1, z: cur.z},
                    {x: cur.x, z: cur.z + 1},
                    {x: cur.x, z: cur.z - 1}
                ];

                for (const n of neighbors) {
                    if (!isWalkableGrid(n.x, n.z)) continue;
                    const nKey = key(n.x, n.z);
                    if (closed.has(nKey)) continue;

                    const tentG = (gScore.get(curKey) || 0) + 1;
                    
                    if (tentG < (gScore.get(nKey) || Infinity)) {
                        cameFrom.set(nKey, curKey);
                        gScore.set(nKey, tentG);
                        const f = tentG + h(n.x, n.z);
                        
                        const existing = open.find(o => o.x === n.x && o.z === n.z);
                        if (!existing) open.push({x: n.x, z: n.z, g: tentG, f: f});
                        else existing.f = f;
                    }
                }
            }
            return [];
        }

        // ============ UPDATE PLAYER ============
        function updatePlayer(dt) {
            if (!isLocked || isPaused) return;

            const walkSpeed = 6.0;
            let sprintSpeed = 8.5;
            
            if (player.speedBoost) {
                player.speedBoostTimer -= dt;
                sprintSpeed = 9.5;
                if (player.speedBoostTimer <= 0) player.speedBoost = false;
            }
            
            const jumpPower = 6.0;
            const gravity = 18;

            if (player.infiniteStamina) {
                player.infiniteStaminaTimer -= dt;
                if (player.infiniteStaminaTimer <= 0) {
                    player.infiniteStamina = false;
                    document.getElementById('stamina-bar').classList.remove('infinite');
                    document.getElementById('stamina-bar').classList.remove('boosted');
                }
            }

            const keyboard = app.keyboard;
            const wantSprint = isSprinting && (keyboard.isPressed(pc.KEY_W) || keyboard.isPressed(pc.KEY_S) || 
                keyboard.isPressed(pc.KEY_A) || keyboard.isPressed(pc.KEY_D));
            
            if (wantSprint && !player.infiniteStamina) {
                if (stamina > 0) stamina = Math.max(0, stamina - dt * 20);
            } else if (!wantSprint) {
                stamina = Math.min(100, stamina + dt * 15);
            }
            
            const canSprint = wantSprint && (stamina > 0 || player.infiniteStamina);
            const moveSpeed = canSprint ? sprintSpeed : walkSpeed;
            
            document.getElementById('stamina-bar').style.width = (player.infiniteStamina ? 100 : stamina) + '%';

            const forwardX = -Math.sin(player.yaw);
            const forwardZ = -Math.cos(player.yaw);
            const rightX = Math.cos(player.yaw);
            const rightZ = -Math.sin(player.yaw);

            let moveX = 0, moveZ = 0;
            if (keyboard.isPressed(pc.KEY_W)) { moveX += forwardX; moveZ += forwardZ; }
            if (keyboard.isPressed(pc.KEY_S)) { moveX -= forwardX; moveZ -= forwardZ; }
            if (keyboard.isPressed(pc.KEY_D)) { moveX += rightX; moveZ += rightZ; }
            if (keyboard.isPressed(pc.KEY_A)) { moveX -= rightX; moveZ -= rightZ; }

            const len = Math.hypot(moveX, moveZ);
            if (len > 0) {
                moveX = (moveX / len) * moveSpeed;
                moveZ = (moveZ / len) * moveSpeed;
            }

            if (keyboard.isPressed(pc.KEY_SPACE) && player.onGround) {
                player.vy = jumpPower;
                player.onGround = false;
            }

            player.vy -= gravity * dt;

            let newX = player.x + moveX * dt;
            let newZ = player.z + moveZ * dt;
            let newY = player.y + player.vy * dt;

            if (!isWalkableWorld(newX, player.z, 0.35)) newX = player.x;
            if (!isWalkableWorld(newX, newZ, 0.35)) newZ = player.z;

            player.x = newX;
            player.z = newZ;

            // Check standing on decorations
            let standingOnDecor = false;
            let decorTopY = 0;
            for (const d of decorations) {
                const distToDecor = Math.hypot(player.x - d.x, player.z - d.z);
                if (distToDecor < d.radius + 0.3 && d.height) {
                    const decorTop = d.height + 0.1;
                    if (player.vy <= 0 && newY <= decorTop + 1.6 && newY > decorTop + 0.5) {
                        decorTopY = decorTop;
                        standingOnDecor = true;
                        break;
                    }
                }
            }
            
            if (standingOnDecor && player.vy <= 0) {
                newY = decorTopY + 1.6;
                player.vy = 0;
                player.onGround = true;
            } else if (newY < 1.6) {
                newY = 1.6;
                player.vy = 0;
                player.onGround = true;
            }
            if (newY > WALL_H - 0.3) { newY = WALL_H - 0.3; player.vy = 0; }
            player.y = newY;

            // Update camera
            if (cameraEntity) {
                cameraEntity.setPosition(player.x, player.y, player.z);
                cameraEntity.setEulerAngles(
                    player.pitch * 180 / Math.PI,
                    player.yaw * 180 / Math.PI,
                    0
                );
            }
            
            checkPowerupCollection();
            checkCoinCollection();
            checkEscapeDoor();
        }

        // ============ POWERUP COLLECTION ============
        function checkPowerupCollection() {
            for (const p of powerupEntities) {
                if (p.collected) continue;
                const dist = Math.hypot(p.x - player.x, p.z - player.z);
                if (dist < 1.5) {
                    p.collected = true;
                    if (p.entity) p.entity.destroy();
                    activatePowerup(p.type);
                }
            }
        }

        function activatePowerup(type) {
            const msg = document.getElementById('pickup-msg');
            const upg = saveData.upgrades;
            
            if (type === 'ice') {
                let freezeTime = 3;
                if (upg.ice >= 1) freezeTime += 1;
                if (upg.ice >= 2) freezeTime += 2;
                if (upg.ice >= 3) { kanye.halfSpeed = true; kanye.halfSpeedTimer = 3; }
                
                kanye.frozen = true;
                kanye.frozenTimer = freezeTime;
                document.getElementById('freeze-overlay').style.opacity = '1';
                msg.textContent = `‚ùÑÔ∏è KANYE FROZEN FOR ${freezeTime} SECONDS!`;
                document.getElementById('slot-ice').classList.add('active');
                setTimeout(() => document.getElementById('slot-ice').classList.remove('active'), freezeTime * 1000);
                
            } else if (type === 'speed') {
                let duration = 10;
                if (upg.speed >= 1) duration += 3;
                if (upg.speed >= 2) duration += 2;
                if (upg.speed >= 3) { player.speedBoost = true; player.speedBoostTimer = 5; }
                
                player.infiniteStamina = true;
                player.infiniteStaminaTimer = duration;
                document.getElementById('stamina-bar').classList.add('infinite');
                if (upg.speed >= 3) document.getElementById('stamina-bar').classList.add('boosted');
                msg.textContent = `‚ö° INFINITE STAMINA FOR ${duration} SECONDS!`;
                document.getElementById('slot-speed').classList.add('active');
                setTimeout(() => document.getElementById('slot-speed').classList.remove('active'), duration * 1000);
                
            } else if (type === 'shield') {
                if (player.shieldHits > 0) {
                    msg.textContent = 'üõ°Ô∏è SHIELD ALREADY ACTIVE!';
                } else {
                    player.shieldHits = upg.shield >= 3 ? 2 : 1;
                    document.getElementById('shield-indicator').style.opacity = '1';
                    msg.textContent = upg.shield >= 3 ? 'üõ°Ô∏è DOUBLE SHIELD ACQUIRED!' : 'üõ°Ô∏è SHIELD ACQUIRED!';
                    document.getElementById('slot-shield').classList.add('active');
                }
            }
            
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 2000);
        }

        // ============ COIN COLLECTION ============
        function checkCoinCollection() {
            let needRespawn = false;
            for (const c of coinEntities) {
                if (c.collected) continue;
                const dist = Math.hypot(c.x - player.x, c.z - player.z);
                if (dist < 1.5) {
                    c.collected = true;
                    if (c.entity) c.entity.destroy();
                    sessionCoins++;
                    document.getElementById('hud-coins').textContent = 'üí∞ ' + sessionCoins;
                    needRespawn = true;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = 'üí∞ +1 COIN';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 1000);
                }
            }
            if (needRespawn) setTimeout(spawnCoins, 2000);
        }

        // ============ CHECK ESCAPE DOOR ============
        function checkEscapeDoor() {
            if (!isEscapeMode || !escapeDoorEntity || !escapeDoorEntity.doorData) return;
            
            const doorData = escapeDoorEntity.doorData;
            const doorWorldPos = gridToWorld(doorData.gridX, doorData.gridZ);
            const dist = Math.hypot(doorWorldPos.x - player.x, doorWorldPos.z - player.z);
            
            const indicator = document.getElementById('escape-door-indicator');
            if (dist < 15) {
                indicator.textContent = 'üö™ EXIT NEARBY!';
                indicator.classList.add('nearby');
            } else {
                indicator.textContent = 'üö™ FIND THE EXIT!';
                indicator.classList.remove('nearby');
            }
            
            if (dist < 2.5) {
                winEscapeRound();
            }
        }

        function winEscapeRound() {
            escapeRound++;
            
            if (escapeRound - 1 > saveData.escapeRecord) {
                saveData.escapeRecord = escapeRound - 1;
                saveSaveData();
            }
            
            const msg = document.getElementById('pickup-msg');
            msg.textContent = 'üö™ ESCAPED! Round ' + escapeRound + ' starting...';
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 2000);
            
            document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
            
            // Regenerate
            clearWorld();
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            createEscapeDoor();
        }

        // ============ UPDATE KANYE ============
        function updateKanye(dt) {
            if (!kanyeEntity || isPaused) return;

            if (kanye.frozen) {
                kanye.frozenTimer -= dt;
                if (kanye.frozenTimer <= 0) {
                    kanye.frozen = false;
                    document.getElementById('freeze-overlay').style.opacity = '0';
                }
                return;
            }
            
            if (kanye.halfSpeed) {
                kanye.halfSpeedTimer -= dt;
                if (kanye.halfSpeedTimer <= 0) kanye.halfSpeed = false;
            }

            let kanyeBaseSpeed = currentMap === 'warehouse' ? 8.5 : 7.5;
            const kanyeMaxSpeed = kanye.halfSpeed ? kanyeBaseSpeed * 0.6 : kanyeBaseSpeed;
            const kanyeTurnSpeed = 3.5;
            
            kanye.pathTimer -= dt;
            if (kanye.pathTimer <= 0) {
                kanye.pathTimer = 0.25;
                
                const kGrid = worldToGrid(kanye.x, kanye.z);
                const pGrid = worldToGrid(player.x, player.z);
                
                const keyboard = app.keyboard;
                const isMoving = keyboard.isPressed(pc.KEY_W) || keyboard.isPressed(pc.KEY_S) || 
                    keyboard.isPressed(pc.KEY_A) || keyboard.isPressed(pc.KEY_D);
                
                const predX = player.x + (isMoving ? -Math.sin(player.yaw) * 3 : 0);
                const predZ = player.z + (isMoving ? -Math.cos(player.yaw) * 3 : 0);
                const predGrid = worldToGrid(predX, predZ);
                
                let path = findPath(kGrid.x, kGrid.z, predGrid.x, predGrid.z);
                if (path.length === 0) path = findPath(kGrid.x, kGrid.z, pGrid.x, pGrid.z);
                
                kanye.path = path;
                kanye.pathIndex = 0;
            }

            let targetX = player.x;
            let targetZ = player.z;

            if (kanye.path.length > 0) {
                while (kanye.pathIndex < kanye.path.length) {
                    const node = kanye.path[kanye.pathIndex];
                    const nodePos = gridToWorld(node.x, node.z);
                    const distToNode = Math.hypot(nodePos.x - kanye.x, nodePos.z - kanye.z);
                    if (distToNode < 1.5 && kanye.pathIndex < kanye.path.length - 1) {
                        kanye.pathIndex++;
                    } else {
                        targetX = nodePos.x;
                        targetZ = nodePos.z;
                        break;
                    }
                }
            }

            const dx = targetX - kanye.x;
            const dz = targetZ - kanye.z;
            const dist = Math.hypot(dx, dz);

            if (dist > 0.1) {
                const desiredVx = (dx / dist) * kanyeMaxSpeed;
                const desiredVz = (dz / dist) * kanyeMaxSpeed;

                kanye.vx += (desiredVx - kanye.vx) * kanyeTurnSpeed * dt;
                kanye.vz += (desiredVz - kanye.vz) * kanyeTurnSpeed * dt;

                const speed = Math.hypot(kanye.vx, kanye.vz);
                if (speed > kanyeMaxSpeed) {
                    kanye.vx = (kanye.vx / speed) * kanyeMaxSpeed;
                    kanye.vz = (kanye.vz / speed) * kanyeMaxSpeed;
                }
            }

            let newX = kanye.x + kanye.vx * dt;
            let newZ = kanye.z + kanye.vz * dt;

            if (!isWalkableWorld(newX, kanye.z, 0.4)) { 
                newX = kanye.x; 
                kanye.vx *= -0.5;
                if (Math.abs(kanye.vz) > 0.5) kanye.vx = 0;
            }
            if (!isWalkableWorld(kanye.x, newZ, 0.4)) { 
                newZ = kanye.z; 
                kanye.vz *= -0.5;
                if (Math.abs(kanye.vx) > 0.5) kanye.vz = 0;
            }
            
            // Stuck detection
            const movement = Math.hypot(newX - kanye.x, newZ - kanye.z);
            if (movement < 0.01 * dt && Math.hypot(kanye.vx, kanye.vz) > 0.1) {
                kanye.pathTimer = 0;
                const randomAngle = Math.random() * Math.PI * 2;
                kanye.vx = Math.cos(randomAngle) * 2;
                kanye.vz = Math.sin(randomAngle) * 2;
            }
            
            kanye.x = newX;
            kanye.z = newZ;
            
            // Update Kanye entity position and make it face camera (billboard)
            if (kanyeEntity) {
                kanyeEntity.setPosition(kanye.x, kanye.y, kanye.z);
                
                // Billboard effect - face camera
                const dx = player.x - kanye.x;
                const dz = player.z - kanye.z;
                const angle = Math.atan2(dx, dz) * 180 / Math.PI;
                kanyeEntity.setEulerAngles(0, angle + 180, 0);
            }

            const distToPlayer = Math.hypot(kanye.x - player.x, kanye.z - player.z);

            // Audio
            const audioRange = 70;
            let vol = distToPlayer < audioRange ? Math.pow(1 - (distToPlayer / audioRange), 0.5) : 0;
            setAudioVolume(vol);

            // Fear effects
            const fear = document.getElementById('fear-overlay');
            const warn = document.getElementById('warning');
            if (distToPlayer < 20) {
                fear.style.opacity = (1 - distToPlayer / 20) * 0.6;
                warn.style.opacity = distToPlayer < 10 ? 1 : 0;
            } else {
                fear.style.opacity = 0;
                warn.style.opacity = 0;
            }

            // Collision with player
            if (distToPlayer < 1.2) {
                if (player.shieldHits > 0) {
                    player.shieldHits--;
                    
                    let freezeOnBlock = 0;
                    if (saveData.upgrades.shield >= 1) freezeOnBlock = 1;
                    if (saveData.upgrades.shield >= 2) freezeOnBlock = 2;
                    if (saveData.upgrades.shield >= 3) freezeOnBlock = 2;
                    
                    if (freezeOnBlock > 0) {
                        kanye.frozen = true;
                        kanye.frozenTimer = freezeOnBlock;
                    }
                    
                    if (player.shieldHits <= 0) {
                        document.getElementById('shield-indicator').style.opacity = '0';
                        document.getElementById('slot-shield').classList.remove('active');
                    }
                    
                    // Bounce kanye back
                    const bounceDir = Math.atan2(kanye.z - player.z, kanye.x - player.x);
                    kanye.x += Math.cos(bounceDir) * 8;
                    kanye.z += Math.sin(bounceDir) * 8;
                    kanye.vx = Math.cos(bounceDir) * 10;
                    kanye.vz = Math.sin(bounceDir) * 10;
                    
                    // Make sure kanye is in valid position
                    if (!isWalkableWorld(kanye.x, kanye.z, 0.4)) {
                        const kGrid = worldToGrid(kanye.x, kanye.z);
                        for (let r = 1; r < 10; r++) {
                            let found = false;
                            for (let ddx = -r; ddx <= r && !found; ddx++) {
                                for (let ddz = -r; ddz <= r && !found; ddz++) {
                                    if (isWalkableGrid(kGrid.x + ddx, kGrid.z + ddz)) {
                                        const pos = gridToWorld(kGrid.x + ddx, kGrid.z + ddz);
                                        kanye.x = pos.x;
                                        kanye.z = pos.z;
                                        found = true;
                                    }
                                }
                            }
                            if (found) break;
                        }
                    }
                    
                    kanye.pathTimer = 0;
                    
                    const msg = document.getElementById('pickup-msg');
                    msg.textContent = player.shieldHits > 0 ? 'üõ°Ô∏è SHIELD BLOCKED! 1 HIT LEFT!' : 'üõ°Ô∏è SHIELD BLOCKED KANYE!';
                    msg.style.opacity = '1';
                    setTimeout(() => { msg.style.opacity = '0'; }, 2000);
                } else {
                    killPlayer();
                }
            }
        }

        // ============ UPDATE BILLBOARDS ============
        function updateBillboards() {
            // Make powerups and coins face camera
            for (const p of powerupEntities) {
                if (!p.collected && p.entity) {
                    const dx = player.x - p.x;
                    const dz = player.z - p.z;
                    const angle = Math.atan2(dx, dz) * 180 / Math.PI;
                    p.entity.setEulerAngles(0, angle + 180, 0);
                    
                    // Floating animation
                    const time = Date.now() / 1000;
                    p.entity.setPosition(p.x, 0.8 + Math.sin(time * 2) * 0.1, p.z);
                }
            }
            
            for (const c of coinEntities) {
                if (!c.collected && c.entity) {
                    const dx = player.x - c.x;
                    const dz = player.z - c.z;
                    const angle = Math.atan2(dx, dz) * 180 / Math.PI;
                    c.entity.setEulerAngles(0, angle + 180, 0);
                    
                    // Spinning and floating
                    const time = Date.now() / 1000;
                    c.entity.setPosition(c.x, 0.6 + Math.sin(time * 3) * 0.05, c.z);
                }
            }
        }

        // ============ MINIMAP ============
        function updateMinimap() {
            if (isEscapeMode) return;
            
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const scale = w / GRID_SIZE;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);

            ctx.fillStyle = '#444';
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (maze[x] && maze[x][z] === 1) {
                        ctx.fillRect(x * scale, z * scale, scale, scale);
                    }
                }
            }
            
            // Powerups
            for (const p of powerupEntities) {
                if (p.collected) continue;
                const px = (p.x / CELL + GRID_SIZE / 2) * scale;
                const pz = (p.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = p.type === 'ice' ? '#88ccff' : p.type === 'speed' ? '#ffcc00' : '#44ff44';
                ctx.beginPath();
                ctx.arc(px, pz, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Coins
            for (const c of coinEntities) {
                if (c.collected) continue;
                const cx = (c.x / CELL + GRID_SIZE / 2) * scale;
                const cz = (c.z / CELL + GRID_SIZE / 2) * scale;
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(cx, cz, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            const playerMapX = (player.x / CELL + GRID_SIZE / 2) * scale;
            const playerMapZ = (player.z / CELL + GRID_SIZE / 2) * scale;
            
            ctx.fillStyle = '#4f4';
            ctx.beginPath();
            ctx.arc(playerMapX, playerMapZ, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#4f4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerMapX, playerMapZ);
            const dirLen = 14;
            const dirX = playerMapX - Math.sin(player.yaw) * dirLen;
            const dirZ = playerMapZ - Math.cos(player.yaw) * dirLen;
            ctx.lineTo(dirX, dirZ);
            ctx.stroke();

            const kanyeMapX = (kanye.x / CELL + GRID_SIZE / 2) * scale;
            const kanyeMapZ = (kanye.z / CELL + GRID_SIZE / 2) * scale;
            ctx.fillStyle = kanye.frozen ? '#88ccff' : '#f44';
            ctx.beginPath();
            ctx.arc(kanyeMapX, kanyeMapZ, 5, 0, Math.PI * 2);
            ctx.fill();
            
            const mapNames = { backrooms: 'üè¢ Backrooms', warehouse: 'üè≠ Warehouse', hospital: 'üè• Hospital' };
            document.getElementById('minimap-floor').textContent = mapNames[currentMap] || 'Unknown';
        }

        // ============ TIMER ============
        function updateTimer() {
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ============ DEATH ============
        function killPlayer() {
            if (isDead) return;
            isDead = true;
            
            const elapsed = (Date.now() - startTime) / 1000;
            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            
            saveData.highscores.push(elapsed);
            saveData.highscores.sort((a, b) => b - a);
            saveData.highscores = saveData.highscores.slice(0, 3);
            
            saveData.coins += sessionCoins;
            saveSaveData();
            
            document.getElementById('survival-time').textContent = `Survived: ${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('coins-earned').textContent = `+${sessionCoins} coins`;
            document.getElementById('death-screen').style.display = 'flex';
            
            stopAudio();
            document.exitPointerLock();
            isLocked = false;
        }

        // ============ PAUSE ============
        function togglePause() {
            if (!gameStarted || isDead) return;
            
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            
            if (isPaused) {
                pauseAudio();
                document.exitPointerLock();
                isLocked = false;
            } else {
                canvas.requestPointerLock();
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pause-screen').style.display = 'none';
            canvas.requestPointerLock();
        }

        function quitGame() {
            sessionCoins = 0;
            returnToMenu();
        }

        function returnToMenu() {
            gameStarted = false;
            isPaused = false;
            isDead = false;
            isEscapeMode = false;
            
            stopAudio();
            document.exitPointerLock();
            isLocked = false;
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('vignette').style.display = 'none';
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('escape-hud').style.display = 'none';
            
            updateUI();
        }

        // ============ START GAME ============
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui').style.display = 'block';
            document.getElementById('vignette').style.display = 'block';
            
            gameStarted = true;
            isEscapeMode = false;
            startTime = Date.now();
            stamina = 100;
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            
            const maps = ['backrooms', 'warehouse', 'hospital'];
            currentMap = maps[Math.floor(Math.random() * maps.length)];
            GRID_SIZE = baseGridSize;
            
            // Show minimap
            if (saveData.settings.minimapEnabled !== false) {
                document.getElementById('minimap').style.display = 'block';
                document.getElementById('minimap-floor').style.display = 'block';
            }
            document.getElementById('escape-hud').style.display = 'none';
            
            clearWorld();
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            
            initAudio();
            canvas.requestPointerLock();
        }

        // ============ START ESCAPE MODE ============
        function startEscapeMode() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui').style.display = 'block';
            document.getElementById('vignette').style.display = 'block';
            
            gameStarted = true;
            isEscapeMode = true;
            escapeRound = 1;
            startTime = Date.now();
            stamina = 100;
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            
            const escapeMaps = ['backrooms', 'hospital'];
            currentMap = escapeMaps[Math.floor(Math.random() * escapeMaps.length)];
            GRID_SIZE = baseGridSize * 2;
            
            // Hide minimap, show escape HUD
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('minimap-floor').style.display = 'none';
            document.getElementById('escape-hud').style.display = 'block';
            document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
            
            clearWorld();
            generateMaze();
            buildWorld();
            createKanye();
            spawnEntities();
            createEscapeDoor();
            
            initAudio();
            canvas.requestPointerLock();
        }

        // ============ RESTART GAME ============
        function restartGame() {
            clearWorld();
            
            if (isEscapeMode) {
                escapeRound = 1;
                GRID_SIZE = baseGridSize * 2;
                document.getElementById('escape-hud').style.display = 'block';
                document.getElementById('escape-round').textContent = 'Round: ' + escapeRound;
                document.getElementById('minimap').style.display = 'none';
                document.getElementById('minimap-floor').style.display = 'none';
                
                const escapeMaps = ['backrooms', 'hospital'];
                currentMap = escapeMaps[Math.floor(Math.random() * escapeMaps.length)];
                
                generateMaze();
                buildWorld();
                createKanye();
                spawnEntities();
                createEscapeDoor();
            } else {
                GRID_SIZE = baseGridSize;
                document.getElementById('escape-hud').style.display = 'none';
                
                if (saveData.settings.minimapEnabled !== false) {
                    document.getElementById('minimap').style.display = 'block';
                    document.getElementById('minimap-floor').style.display = 'block';
                }
                
                const maps = ['backrooms', 'warehouse', 'hospital'];
                currentMap = maps[Math.floor(Math.random() * maps.length)];
                
                generateMaze();
                buildWorld();
                createKanye();
                spawnEntities();
            }
            
            isDead = false;
            stamina = 100;
            startTime = Date.now();
            sessionCoins = 0;
            document.getElementById('hud-coins').textContent = 'üí∞ 0';
            kanye.pathTimer = 0;
            kanye.frozen = false;
            kanye.halfSpeed = false;
            kanye.vx = 0;
            kanye.vz = 0;
            
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('fear-overlay').style.opacity = 0;
            document.getElementById('warning').style.opacity = 0;
            document.getElementById('freeze-overlay').style.opacity = 0;
            document.getElementById('shield-indicator').style.opacity = 0;
            document.getElementById('stamina-bar').classList.remove('infinite', 'boosted');
            document.querySelectorAll('.powerup-slot').forEach(s => s.classList.remove('active'));
            
            canvas.requestPointerLock();
        }

        // ============ INPUT HANDLING ============
        function setupInput() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                if (e.code === sprintKeyCode) isSprinting = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape' && gameStarted && !isDead) {
                    e.preventDefault();
                    togglePause();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === sprintKeyCode) isSprinting = false;
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isLocked || !gameStarted || isDead || isPaused) return;
                player.yaw -= e.movementX * mouseSensitivity;
                player.pitch -= e.movementY * mouseSensitivity;
                player.pitch = Math.max(-1.4, Math.min(1.4, player.pitch));
            });

            // Pointer lock
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === canvas;
            });

            canvas.addEventListener('click', () => {
                if (gameStarted && !isDead && !isPaused) {
                    canvas.requestPointerLock();
                }
            });
        }

        // ============ INITIALIZE ============
        function init() {
            updateLoadingProgress('Loading save data...');
            loadSaveData();
            
            updateLoadingProgress('Initializing PlayCanvas...');
            
            // Create camera
            cameraEntity = new pc.Entity('camera');
            cameraEntity.addComponent('camera', {
                clearColor: new pc.Color(0.1, 0.1, 0.1),
                fov: 75,
                nearClip: 0.1,
                farClip: 100
            });
            app.root.addChild(cameraEntity);
            
            // Start application
            app.start();
            applyGraphicsSettings();
            
            // Load textures then show menu
            loadTextures(() => {
                updateLoadingProgress('Ready!');
                
                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                    document.getElementById('start-screen').classList.remove('hidden');
                    updateUI();
                }, 500);
            });
            
            setupInput();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                app.resizeCanvas();
            });
        }

        // ============ GAME LOOP ============
        let lastTime = 0;
        
        app.on('update', (dt) => {
            // Cap delta time
            dt = Math.min(dt, 0.05);
            
            if (gameStarted && !isDead && !isPaused) {
                updatePlayer(dt);
                updateKanye(dt);
                updateBillboards();
                updateMinimap();
                updateTimer();
            }
        });

        // Start initialization
        init();
    </script>
</body>
</html>
